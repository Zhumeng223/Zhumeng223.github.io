[{"title":"12种Flutter开发工具推荐","path":"/Flutter/12种Flutter开发工具推荐/","content":"Panache：Flutter material 主题编辑器 Panache 是Flutter 的开源、基于浏览器的 material 主题编辑器，可让你为 Flutter 应用创建美观且可高度自定义的主题。使用这个 Flutter 开发工具，你可以自定义组件和小部件的颜色，并将主题导出为 theme.dart 文件。 项目地址 https://rxlabz.github.io/panache Supernova：Flutter 设计到代码工具 Supernova 是一款功能强大的设计到代码工具，可将你的 Sketch 和 Adobe XD 移动设计转换为适用于 iOS、Android、ReactNative，当然还有 Flutter 的原生前端代码。导入应用设计时，Supernova 还可以处理资产创建和重复数据删除工作，并允许你编辑设计并实时查看代码更改。Supernova 目前仅提供了 macOS 应用，但很快就会发布云端版本。 项目地址 https://supernova.io/ Codemagic：FlutterCI&#x2F;CD 工具 Codemagic 是 Nevercode 创建的第一个专注于 Flutter 的 CI&#x2F;CD 工具。它可以轻松识别你的 Flutter 应用，并与所有你喜欢的工具集成，以自动化你的整个构建、测试和发布流程。Codemagic 还相当实惠，每月提供 500 个免费的 Mac mini 构建分钟，以及按需付费的额外分钟计费方案。 项目地址 https://codemagic.io/ Sylph：Flutter 设备农场测试工具 Sylph 是由 Maurice McCabe 创建的开源命令行工具，本质上是 AWS 设备农场的包装器。借助 Sylph，你可以在 AWS 设备农场中一次在数百个真实的 iOS 和 Android 设备上运行 Flutter 集成和端到端测试。 项目地址 https://pub.dev/packages/sylph Amplitude：Flutter 应用内分析工具 Amplitude 是一种著名的应用内分析工具，可帮助你了解用户如何与你的应用交互。现在，它也是一种流行的 Flutter 开发工具，可以帮助你跟踪和监视各种数据，并与所有流行的移动应用开发流程集成，从而使你能够根据数据采取行动。 项目地址 https://github.com/mmcc007 Count.ly：Flutter 应用内分析工具 Count.ly 是一个开源分析工具，专注于数据的安全性和隐私性。Count.ly 的免费版本允许你跟踪显示应用性能的基本指标和 KPI。但它们还提供付费版本，其中包含一组更广泛的指标以及其他许多功能。Count.ly 的付费版本可以在内部或云中托管，并提供额外的特性标志、A&#x2F;B 测试和推送通知功能。 项目地址 https://count.ly/ AppsFlyer：Flutter 归因工具 AppsFlyer 是一种移动归因工具，可帮助你了解用户的来源并了解应用安装量和特定营销活动之间的联系。它提供了一个仪表板，可以帮助你了解营销渠道和广告系列在各种设备和应用上的效果如何，并与 6000 多家媒体合作伙伴集成。 项目地址 https://www.appsflyer.com/ Instabug：Flutter 应用内错误报告、崩溃报告和调查工具 Instabug 是一个用于移动应用实时上下文洞察的平台，可用于应用内错误报告、崩溃报告、调查和功能请求。将 Instabug 的 Flutter SDK 集成到你的应用中后，你就可以允许用户在不离开应用的情况下报告他们遇到的错误。Instabug 可以捕获截图，支持用户注释和模糊，并能捕获全面的日志和设备详细信息，以帮助你更快地发现和解决问题。崩溃报告也会与你定位确切问题所需的所有日志和设备详细信息一起发送。你还可以向你的用户发送定向调查，以更好地了解用户操作背后的原因，并允许用户请求功能，对请求进行投票。 项目地址 https://instabug.com/?src=InstabugBlog&amp;mdm=internal&amp;term=flutter_tools Airship：Flutter 应用内消息工具 Airship 是一个客户参与平台，允许你向用户发送推送通知和应用内消息，以吸引他们并改善他们的转化率。它还允许你创建一个应用内消息中心，该中心创建一个应用内收件箱，你可以在其中向用户发送持久消息。 项目地址 https://www.airship.com/ WonderPush：Fluttet 推送通知工具 WonderPush 是另一个通知推送和应用内消息传递工具，你可以在 Flutter 应用中使用该工具来提高用户的参与度。它以低廉的价格提供了许多强大的功能，包括细分和定位、地理位置定位以及 A&#x2F;B 测试。 项目地址 https://www.wonderpush.com/ Revenue Cat：Flutter 应用内购买工具 RevenueCat 是一款应用内购买和订阅管理工具，支持 iOS、Android 和 Stripe。使用这一工具，你可以轻松创建和管理应用内购买和订阅模块，它可以完成所有繁重的工作并处理计费基础架构。它还支持开箱即用的 LTV、MRR、客户流失率等指标测量，来跟踪你的应用成绩。 项目地址 https://www.revenuecat.com/ Square：Flutter 应用内支付工具 Square 是一个应用内支付管理平台，可为你处理支付操作带来的所有复杂性。借助其 Flutter SDK，你可以通过易于定制的 UI 接收应用内付款，该 UI 支持数字钱包和存储卡以进行快速结帐。 项目地址 https://www.revenuecat.com/","categories":["Flutter","资源库"]},{"title":"iOS资源整理","path":"/iOS/资源库/iOS资源整理/","content":"RunTimeRuntime 10种用法（没有比这更全的了 开源项目成为iOS顶尖高手，你必须来这里(这里有最好的开源项目和文章) MVVMTableView之MVVM与MVC之对比 使用MVVM减少控制器代码实战(减少56%) 面向协议的 MVVM 架构介绍 网络iOS 升级HTTPS通过ATS你所要知道的 iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求 iOS开发之AFNetworking 3.0.4使用 iOS开发 AFNetworking 3.0使用遇到的问题补充 正确使用AFNetworking的SSL保证网络安全 iOS开发中WiFi相关功能总结 iOS应用支持IPV6，就那点事儿 基于iOS 10、realm封装的下载器（支持存储读取、断点续传、后台下载、杀死APP重启后的断点续传等功能） 网络层的搭建需要解决哪些问题 YTKNetwork集成教程以及相关问题思考 关于iOS工程中网络请求管理的头脑风暴 计算机网络中的TCP&#x2F;UDP协议到底是怎么回事（一） 计算机网络中的TCP&#x2F;UDP协议到底是怎么回事（二）","categories":["iOS","资源库"]},{"title":"iOS开发兵器进阶","path":"/iOS/资源库/iOS开发兵器进阶/","content":"开篇 悟空道：“我自生身之后，出家修行，得一个无生无灭之体。近因教演儿孙，守护山洞，奈何没件兵器。久闻贤邻享乐瑶宫贝阙，必有多余神器，特来告求一件。” – 《西游记》第三回 四海千山皆拱伏 九幽十类尽除名 常言道：“工欲善其事，必先利其器。”各位看官，今天咱们就介绍几件在 iOS 开发中几件趁手的兵器。 开发Reveal 教程：iOS开发中集成Reveal 破解版用于学习途径，请自行搜索。 Charles 教程：Charles 从入门到精通 下载：Charles 官网 破解版用于学习途径，请自行搜索。 SimPholdersSimPholders 是一款Mac上的iOS开发辅助工具，能够在菜单栏上快速的访问iPhone Simulator中的应用的文件夹，从而帮助我们进行应用开发。 下载：Simpholders PaintCode 教程：PaintCode 教程 (1) | PaintCode 教程 (2) 下载：PaintCode 官网 Conerstone 教程：用CornerStone配置SVN，HTTP及svn简单使用说明 破解版用于学习途径，请自行搜索。 iFunBoxiFunBox是一款小巧的iPhone文件管理软件，界面类似于windows资源管理器，以简练时尚的窗口方式浏览和管理iPhone、iPad、iPod touch上的文件和目录。既可以在手机与电脑之间同步传递数据，使你轻松上传电影、音乐、电子书、桌面、照片以及应用程序。 下载：iFunBox 官网 iTerm 你应该知道的 iTerm2 使用方法–MAC终端工具 iTerm2 - macOS Terminal Replacement 官网 zsh zsh 全程指南 zsh 官网 VisualDifferVisualDiffer比较文件夹和文件并排侧使用颜色直观地显示差异。 防火墙 Little Snitch主要用途，阻止 Mac 内具体哪个应用联网，实时查看电脑流量是否有异常。 介绍：你的隐私看门人：Mac 双向防火墙 Little Snitch flux长期看电脑屏幕，护眼软件。 flux 官网 效率有道词典不多说，阅读英文文档和翻译的辅助。全球 Mac Appstore 均有销售。 Dash全栈工程师开发文档大全。全球 Mac Appstore 均有销售。 MindNode Pro思维导图，帮助梳理逻辑。 StarUML画UML，类图的工具。StarUML 官网 OmniGraffle画UML，类图的工具，与StarUML比较看个人爱好了。 知识输入印象笔记印象笔记，有道笔记，为知笔记，笔记是一定要有的，那么多东西谁天天记在脑子了，关键的东西记笔记里，如果实在忘了，Google一下。 Reeder常看的blog记得订阅。 知识输出Markdown + Quiver + 坚果云 程序员专用笔记软件Quiver 坚果云怎么样？ - 网盘 - 知乎 U图床 + 七牛云 U 图床：MacAppStore 下载 U 图床：Github 开源 搭配 Markdown 书写，够了。 LicecapLicecap 是一款屏幕录制工具，支持导出 GIF 动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围。 官方主页 GitHub最好的开源项目集散地(没有“之一”)。同样是你的作品得到认可的地方。 Blog技术blog非常棒，好的技术或方案应该记录下并传播出去，坚持做下去。Hexo+gitpage 搭建个人技术博客 简书大牛都在简书上写博客，你不跟着节奏么？ 开发者头条技术自媒体发散渠道，同时也是好的知识输入渠道。 掘金技术自媒体发散渠道，同时也是好的知识输入渠道。 科学上网科学上网用于学习途径，关于 ShadowsockesX 的内容，来自 使用ShadowSocks科学上网及突破公司内网这篇文章。 ShadowsockesXShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由@clowwindy开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。 ShadowsocksX-NG:Github Proxifier该工具的作用就是接管运行中的所有应用发出的所有请求，然后通过代理进行转发，这样就可以让不支持代理的应用也可以走代理了。 Proxifier 官网 破解和使用教程看这篇：proxifier注册码以及配合shadowsocks上网 - 科学上网 其他姿势科学上网，有需要请私信我。Chrome 插件翻墙后，全球 Chrome 商店均有销售。 Proxy SwitchyOmegaChrome 浏览器 配合 Proxy SwitchyOmega 插件 + 代理服务器，轻松登陆Google。 FireShot截取整个网页的截屏工具 有道词典不多说，网页浏览英文随时翻译。 开发者头条第一时间掌握技术圈最新自媒体动态。 掘金第一时间掌握技术圈最新自媒体动态，和github每日更新仓库。 Copy as Markdown配合 Markdown 图片、链接跳转方便粘贴。 AdBlock去除广告，专注网页内容。 印象笔记·剪藏配合印象笔记，知识输入重要来源，点击一下，直接将网页正文存入印象笔记。 新浪微博图床免费开源的微博图床。 新浪微博图床：Github 结尾 悟空笑道：“古人云：‘愁海龙王没宝哩！’你再去寻寻看。若有可意的，一一奉价。” 这是小生工作中常用的几件工具介绍给大家，也欢迎有好的工具咱们奔走相告，提高工作效率的同时，也学习工具开发者的设计思想。","categories":["iOS","资源库"]},{"title":"几个超棒的iOS学习网站","path":"/iOS/几个超棒的iOS学习网站/","content":"我相信，要想从一个“还不错”的人编程一个卓越的人，我们需要不停地向他人学习，同时还要尽早地适应最新的技术和工具。除了苹果官方文档网站之外，我列举了一些能获取有价值的文章和资源的网站，这些网站能够帮助我们更上一个台阶！ 让我们先看一些原创的内容博客： objc.io这个网站由世界级的iOS工程师每月进行更新。上面可以看到关于某些话题的高质量文章和深度讨论，同时他们还提供了基于订阅的杂志iPad应用。该网站由Chris Eidhof、Daniel Eggert和Florian Kugler发现并提供。 Subjective-C该网站以解析和重构创新模式和著名应用的UI而闻名。该网站为他们的实验提供程序性文章和代码库。由Sam Page主笔。有点遗憾的是，作者决定暂停更新网站，不过好在那些旧的教程仍然很值得一看。 NSHipster以类为基础进行逐步讲解并附有示例代码的网站。其文章探讨了编程风格，以及最前沿的类的使用和实现。由AFNetworking的作者Mattt Thompson创建，目前由Nate Cook进行管理。 Peter Steinberger本站为个人博客，其作者是著名的iOS商业PDF库的创始人，该产品曾被Dropbox和Evernote这样著名的应用使用过。网站内容包括一些令人惊叹的黑客资源和debug资源，以帮助开发者学习和实践。 Ole Begemann本博客重点分享个人经历,同时讨论代码样式和API设计,有时还会透露一些苹果所使用的私密而有趣的类。 Florian KuglerObjC.IO的合著者所写的个人博客。你可以在上面找到很多关于性能检测的文章和讨论，包括应用于多核心数据的UI绘制。 NSBlog用有趣的问答形式创作，包含了关于Objective-C和其他主题的深度问题。如果你对于重建像NSObject这样的基本类持有疑问，可以向Mike Ash提出。 Cocoa从iOS开发者的Tumblr上摘取的iOS开发源码和深度观察，有点随机但是还是很有用。 下面有一些博客，可以帮我们获取最新讯息。 iOS Dev Weekly自2011年起每周更新，订阅者已经超过20,000。它可以帮我们从网络上获取有用的iOS文章。还提供了Safari的推送通知功能。由Dave Verwer发现并提供。 iOS Developer Tips2008年以来最早的几个每天更新的iOS推送资源之一。包括很多领域的文章，例如开发小技巧、UX、流言、个人经历和故事等。由John Muchow策划。 iOS Goodies较新的iOS资讯站。内容包括论文、控件&#x2F;工具、商务、UI以及各种媒体类型等等。由Rui Peres和Tiago Almeida每周更新。 AppCoda由我在香港的一个开发者朋友创建，他最近辞掉了工作来专心维护这个网站。包括在线的文章和支付后可下载的文章，重点在用于执行的最新的API和结构上。由Simon Ng创建，值得一看。 两个有价值的原创内容博客。 Krzysztof Zab?ocki提供关于代码结构、工具和Xcode的技巧，当然，在我第一次发表这篇博客的时候我把它给遗漏了。我们从这些高阶的文章中学到了很多。 iOS Development tips相对较新的博客，有一些关于使用Xcode和API的细致的提示，即使你再匆忙也值得去看一眼。作者是Rounak Jain。 时间很宝贵，所以我们必须聪明地选择新闻来源。 读的越好,做的越好。 读的越多，做的越少。","categories":["iOS","资源库"]},{"title":"iOS面试题","path":"/iOS/面试/iOS面试题/","content":"1、一个NSObject对象占用多少内存？回答：系统分配了16个字节给NSObject对象（通过malloc_size函数获得）（因为内存对齐，必须是16的倍数）但NSObject对象内部只有一个isa指针，只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 2、对象的isa指针指向哪里？回答：instance对象的isa指针指向class对象class对象的isa指针指向meta-class对象meta-class对象的isa指针指向基类的meta-class对象 3、OC的类信息存放在哪里？回答：对象方法、属性、成员变量、协议信息，存放在class对象中类方法，存放在meta-class对象中成员变量的具体值，存放在instance对象中 4、iOS用什么方式实现对一个对象的KVO？（KVO的本质是什么？）回答：利用RuntimeAPI生成一个子类NSKVOXXXNotifying，并且让instance对象的isa指针指向这个全新的子类当修改instance对象的属性时，会调用Foundation框架中的_NSSetXXXValueAndNotify函数（重写了setter方法）：willChangeValueForKey:父类原来的setter方法didChangeValueForKey:内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context） 5、如何手动触发KVO？回答：手动去调用willChangeValueForKey:和didChangeValueForKey:的方法 6、直接修改成员变量会触发KVO吗？回答：不会，因为修改成员变量并不会调用setter方法 7、通过KVC修改属性会触发KVO吗？回答：会触发KVO，通过KVC修改相当于手动调用了willChangeValueForKey:和didChangeValueForKey: 8、KVC的赋值和取值的过程是怎样的？原理是什么？回答：赋值：取值： 9、Category的使用场合是什么？回答：类包含了很多个方法实现，而这些方法需要不同团队的成员来实现当你在使用基础类库中的类时，你不想继承这些类，而只是想添加一些方法的时候 10、Category的实现原理回答：Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中） 11、Category和Class Extension的区别是什么？回答：Class Extension是在程序编译的时候，它的数据就已经包含在类信息中了Category在底层是以结构体的形式存在，在程序运行的时候，才会将数据合并到类信息中 12、Category中有load方法吗？load方法是什么时候调用的？load方法能继承吗？回答：有load方法load方法在runtime加载类、分类的时候调用，而且只调用一次load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用 13、load、initialize方法的区别是什么？它们在category中的调用顺序？以及出现继承时它们之间的调用过程？回答：load方法load方法会在Runtime加载类、分类的时候调用每个类、分类的load，在程序运行的过程中只调用一次调用顺序：先调用类的load按照编译的先后顺序调用（先编译，先调用）调用子类的load之前会先调用父类的load再调用分类的load按照编译先后顺序调用（先编译，先调用）load方法系统调用和主动调用的区别系统调用load是直接找到类或分类中的方法的内存地址直接调用主动调用load是通过消息机制来发送消息的，会在对应的消息列表里按顺序遍历一层层查找，找到就调用initialize方法initialize方法会在类第一次接收到消息时调用调用顺序：先调用父类的initialize，再调用子类的initialize，每个类只会初始化1次（如果子类没有实现initialize方法，会调用父类的initialize方法，所以父类的initialize方法可能会调用多次）initialize的调用是通过消息机制来发送消息的 14、Category能否添加成员变量？如果可以，如何给Category添加成员变量？回答：不能直接给Category添加成员变量，但是可以简介实现Category有成员变量的效果——关联对象 15、Block的原理是怎样的？Block的本质是什么？回答：其本质就是封装了函数调用以及调用环境的OC对象 16、__block的作用是什么？有什么使用注意点？回答：可以将修饰的对象包装成一个对象，解决在block内部无法修改外部变量的问题。__block内部会进行内存管理，在MRC环境下不会对对象进行强引用。 17、看下面代码，分别输出的值是什么？1234567891011121314151617181920212223int a = 10;static int b = 10;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; auto int age = 10; static int height = 10; void (^block)(void) = ^&#123; NSLog(@&quot;age is %d, height is %d&quot;, age, height); NSLog(@&quot;a is %d, b is %d&quot;, a, b); &#125;; age = 20; height = 20; a = 20; b = 20; block();\t&#125; return 0;&#125; 回答：输出结果为：age&#x3D;10，height&#x3D;20，a&#x3D;20，b&#x3D;20 age是自动变量，是值传递height表示的是指针传递，block获取的是该变量的地址而a/b都是全局变量，block不会捕获，需要时直接拿取当前最新的值就可以了12345678910111213141516171819202122232425262728293031323334int a = 10;static int b = 10;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; int *height; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; auto int age = 10; static int height = 10; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height)); age = 20; height = 20; a = 20; b = 20; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); &#125; return 0;&#125; 18、看下面代码，block内部会不会捕获self？123456789101112131415161718192021222324252627@interface Person : NSObject@property (copy, nonatomic) NSString *name;- (instancetype)initWithName:(NSString *)name;@end@implementation Person- (void)test&#123; void (^block)(void) = ^&#123; NSLog(@&quot;-------%d&quot;, [self name]); &#125;; block();&#125; - (instancetype)initWithName:(NSString *)name&#123; if (self = [super init]) &#123; self.name = name; &#125; return self;&#125;@end 回答：会捕获，因为self本质上也是一个局部变量，block内部会生成一个变量来保存Person对象的地址123456789101112131415161718struct __Person__test_block_impl_0 &#123; struct __block_impl impl; struct __Person__test_block_desc_0* Desc; Person *self; __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// 函数都会生成隐式参数self和_cmdstatic void _I_Person_test(Person * self, SEL _cmd) &#123; void (*block)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);&#125; 19、Block的属性词为什么是Copy？使用Block有哪些注意事项？回答：block如果没有进行copy操作，就不会放在堆上。放到堆上的主要目的是方便我们来控制它的生命周期，可以更有效的进行内存管理。注意事项：注意不要产生循环引用"},{"title":"iOS易忘图","path":"/iOS/OC底层原理/易忘图/","content":"isa和superclass指针 KVCsetValue:forKey:的原理 KVCvalueForKey:的原理 关联对象的本质 @encode&#96;字符串编码 类的底层结构 常见的深浅拷贝 同步异步&#x2F;串行并发 动态方法解析 消息转发 排序算法时间复杂度","categories":["iOS"]},{"title":"Mac常用代码","path":"/iOS/资源库/Mac常用代码/","content":"一、Git创建新分支1git checkout -b dev 相当于以下两条命令： 12git branch devgit checkout dev 提交的时候执行： 1git push --set-upstream origin dev 二、文件夹的显示和隐藏1、Mac显示隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder 2、Mac隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 三、给安卓手机安装软件1adb install -r（然后拖入apk文件） 四、OC代码转为C++代码1xcrun -sdk iphoneos clang arm64 -rewrite-objc main.m 如果代码里有weak的话使用以下代码： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m"},{"title":"探索Objective-C底层 - 开发统计","path":"/iOS/OC底层原理/探索Objective - C底层 - 开发统计/","content":"引言在iOS开发过程中，开发统计是一项至关重要的工作。通过对各种数据进行统计和分析，我们可以深入了解应用的运行状况、用户行为以及潜在的问题，从而为优化应用、提升用户体验提供有力的支持。本文将详细介绍在Objective - C开发中常见的开发统计知识点，包括崩溃率统计、用户数量统计、埋点统计功能用户数量以及用户操作步骤统计等，并结合具体的例子进行说明，同时阐述这些统计方案的实现原理。 一、崩溃率统计：使用Bugly1.1 Bugly简介Bugly是腾讯提供的一款专业的应用崩溃分析工具，它可以帮助开发者快速定位和解决应用中的崩溃问题。通过Bugly，我们可以实时监控应用的崩溃率，查看崩溃报告，分析崩溃原因，从而及时修复问题，提高应用的稳定性。 1.2 集成Bugly首先，我们需要在项目中集成Bugly SDK。可以通过CocoaPods进行集成，在Podfile中添加以下内容： 1pod &#x27;Bugly&#x27; 然后在终端执行pod install命令进行安装。 1.3 初始化Bugly在AppDelegate.m文件中进行Bugly的初始化： 123456789101112#import &quot;AppDelegate.h&quot;#import &lt;Bugly/Bugly.h&gt;@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 初始化Bugly [Bugly startWithAppId:@&quot;your_app_id&quot;]; return YES;&#125;@end 将your_app_id替换为你在Bugly平台上申请的App ID。 1.4 可能造成崩溃的地方及解决方法1.4.1 空指针异常空指针异常是最常见的崩溃原因之一，当我们尝试访问一个空对象的属性或方法时，就会导致崩溃。 示例代码： 12NSString *str = nil;NSLog(@&quot;%@&quot;, [str uppercaseString]); // 这里会导致崩溃 解决方法：在访问对象的属性或方法之前，先进行空值判断。 1234NSString *str = nil;if (str) &#123; NSLog(@&quot;%@&quot;, [str uppercaseString]);&#125; 1.4.2 数组越界当我们访问数组中不存在的索引时，会导致数组越界崩溃。 示例代码： 12NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];NSLog(@&quot;%@&quot;, array[3]); // 数组索引越界，会导致崩溃 解决方法：在访问数组元素之前，先检查索引是否在有效范围内。 12345NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;];NSInteger index = 3;if (index &gt;= 0 &amp;&amp; index &lt; array.count) &#123; NSLog(@&quot;%@&quot;, array[index]);&#125; 1.4.3 未实现的方法调用当我们调用一个对象未实现的方法时，会导致崩溃。 示例代码： 12345678@interface MyClass : NSObject@end@implementation MyClass@endMyClass *obj = [[MyClass alloc] init];[obj performSelector:@selector(nonExistentMethod)]; // 调用未实现的方法，会导致崩溃 解决方法：在调用方法之前，先检查对象是否实现了该方法。 12345678910@interface MyClass : NSObject@end@implementation MyClass@endMyClass *obj = [[MyClass alloc] init];if ([obj respondsToSelector:@selector(nonExistentMethod)]) &#123; [obj performSelector:@selector(nonExistentMethod)];&#125; 1.4.4 内存泄漏内存泄漏会导致应用的内存占用不断增加，最终可能导致崩溃。 示例代码： 12345678910@interface MyObject : NSObject@end@implementation MyObject@endwhile (1) &#123; MyObject *obj = [[MyObject alloc] init]; // 没有释放对象，会导致内存泄漏&#125; 解决方法：确保在不需要使用对象时，及时释放对象的内存。可以使用ARC（自动引用计数）来管理内存，避免手动管理内存带来的问题。 1.5 Bugly实现原理Bugly的实现原理主要基于以下几个方面： 异常捕获：Bugly SDK会在应用启动时注册异常处理回调函数，当应用发生崩溃时，系统会触发这些回调函数。Bugly会捕获这些异常信息，包括崩溃的堆栈信息、设备信息、应用版本信息等。 数据收集：Bugly会收集崩溃现场的各种数据，如线程状态、内存信息、CPU信息等，这些数据有助于更全面地分析崩溃原因。 数据上传：Bugly将收集到的崩溃数据加密后上传到Bugly服务器。上传过程采用了安全的传输协议，确保数据的安全性。 符号化处理：服务器接收到崩溃数据后，需要对堆栈信息进行符号化处理。符号化是将崩溃堆栈中的内存地址转换为具体的方法名、文件名和行号的过程。这需要使用应用的符号表文件（DSYM文件）。 崩溃报告生成：经过符号化处理后，Bugly服务器会生成详细的崩溃报告，包括崩溃的基本信息、堆栈信息、设备信息等，开发者可以在Bugly平台上查看这些报告。 1.6 上传符号表的过程上传符号表是为了让Bugly能够将崩溃堆栈中的内存地址转换为具体的方法名、文件名和行号，从而更方便地定位崩溃问题。以下是上传符号表的具体步骤： 1.6.1 获取DSYM文件在Xcode中，当我们打包应用时，Xcode会自动生成DSYM文件。DSYM文件包含了应用的符号信息，它与应用的二进制文件是一一对应的。DSYM文件通常位于以下路径： 1~/Library/Developer/Xcode/Archives/[日期]/[应用名称].xcarchive/dSYMs/[应用名称].app.dSYM 1.6.2 上传DSYM文件到Bugly平台 手动上传：登录Bugly平台，在应用管理页面中找到“符号表管理”选项，点击“上传符号表”按钮，选择对应的DSYM文件进行上传。 脚本上传：Bugly提供了脚本工具，可以通过命令行的方式上传DSYM文件。首先，下载Bugly提供的符号表上传脚本，然后在终端中执行以下命令：1python buglySymboliOS.py -i [DSYM文件路径] -u [Bugly App ID] -k [Bugly App Key] 将[DSYM文件路径]替换为实际的DSYM文件路径，[Bugly App ID]和[Bugly App Key]替换为你在Bugly平台上申请的App ID和App Key。 1.7 查看Bugly崩溃报告集成Bugly并运行应用后，当应用发生崩溃时，Bugly会自动收集崩溃信息并上传到Bugly平台。我们可以登录Bugly平台，查看详细的崩溃报告，包括崩溃的堆栈信息、设备信息、用户信息等，从而定位和解决崩溃问题。 二、用户数量统计：使用友盟2.1 友盟简介友盟是一家提供移动应用统计分析服务的平台，它可以帮助开发者统计应用的用户数量、用户留存率、用户活跃度等信息，为应用的运营和推广提供数据支持。 2.2 集成友盟同样可以通过CocoaPods进行集成，在Podfile中添加以下内容： 12pod &#x27;UMCommon&#x27;pod &#x27;UMAnalytics&#x27; 然后执行pod install命令进行安装。 2.3 初始化友盟在AppDelegate.m文件中进行友盟的初始化： 1234567891011121314#import &quot;AppDelegate.h&quot;#import &lt;UMCommon/UMCommon.h&gt;#import &lt;UMAnalytics/MobClick.h&gt;@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 初始化友盟 [UMConfigure initWithAppkey:@&quot;your_app_key&quot; channel:@&quot;App Store&quot;]; [MobClick startWithConfigure:[UMAnalyticsConfig new]]; return YES;&#125;@end 将your_app_key替换为你在友盟平台上申请的App Key。 2.4 统计用户数量友盟会自动统计应用的新增用户数和活跃用户数。我们可以登录友盟平台，在“统计分析”模块中查看这些数据。新增用户数表示第一次使用应用的用户数量，活跃用户数表示在一定时间内使用过应用的用户数量。 2.5 友盟实现原理友盟统计用户数量的实现原理主要基于设备标识和事件记录： 设备标识：友盟通过获取设备的唯一标识（如IDFA、IDFV等）来区分不同的设备和用户。当应用启动时，友盟SDK会将设备标识上传到友盟服务器。 新增用户统计：当一个新的设备标识首次上传到友盟服务器时，友盟会将该设备对应的用户记录为新增用户。 活跃用户统计：友盟通过记录应用的启动事件来统计活跃用户。当应用启动时，友盟SDK会向服务器发送启动事件，服务器根据事件的时间戳来判断用户是否为活跃用户。 三、埋点统计功能用户数量3.1 埋点统计简介埋点统计是指在应用的关键位置插入代码，记录用户的操作行为，从而统计使用某个功能的用户数量。通过埋点统计，我们可以了解用户对不同功能的使用情况，为功能优化和产品决策提供依据。 3.2 使用友盟进行埋点统计友盟提供了丰富的埋点统计功能，我们可以使用友盟的API进行埋点。 3.2.1 简单埋点在需要统计的功能入口处添加埋点代码。 示例代码： 12345// 在某个功能按钮的点击事件中添加埋点- (IBAction)buttonClicked:(id)sender &#123; [MobClick event:@&quot;function_click&quot;]; // 执行功能逻辑&#125; 在友盟平台上，我们可以通过“事件分析”模块查看function_click事件的触发次数和触发用户数，从而统计使用该功能的用户数量。 3.2.2 带参数的埋点如果需要统计不同条件下的功能使用情况，可以使用带参数的埋点。 示例代码： 123456// 在某个功能按钮的点击事件中添加带参数的埋点- (IBAction)buttonClicked:(id)sender &#123; NSDictionary *parameters = @&#123;@&quot;type&quot;: @&quot;type1&quot;, @&quot;value&quot;: @&quot;value1&quot;&#125;; [MobClick event:@&quot;function_click&quot; attributes:parameters]; // 执行功能逻辑&#125; 在友盟平台上，我们可以根据参数进行筛选和分析，了解不同条件下的功能使用情况。 3.3 埋点统计实现原理埋点统计的实现原理主要基于事件记录和数据上传： 事件记录：在应用中插入埋点代码后，当用户触发相应的操作时，SDK会记录该事件，并将事件信息（如事件名称、参数等）保存到本地。 数据上传：SDK会在合适的时机（如应用进入后台、网络连接良好等）将本地记录的事件信息上传到服务器。 数据分析：服务器接收到事件数据后，会对数据进行分析和统计，计算每个事件的触发次数、触发用户数等信息，开发者可以在统计平台上查看这些数据。 四、统计用户的操作步骤4.1 操作步骤统计简介统计用户的操作步骤可以帮助我们了解用户在应用中的使用流程，发现用户可能遇到的问题，从而优化应用的用户体验。 4.2 使用友盟进行操作步骤统计我们可以通过友盟的自定义事件和页面统计功能来统计用户的操作步骤。 4.2.1 自定义事件统计操作步骤在用户的每个操作步骤处添加自定义事件埋点。 示例代码： 1234567891011121314151617// 用户进入某个页面- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; [MobClick event:@&quot;step_1_enter_page&quot;];&#125;// 用户在页面上进行某个操作- (IBAction)actionButtonClicked:(id)sender &#123; [MobClick event:@&quot;step_2_action&quot;]; // 执行操作逻辑&#125;// 用户离开页面- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; [MobClick event:@&quot;step_3_leave_page&quot;];&#125; 通过在友盟平台上查看这些自定义事件的触发顺序和时间间隔，我们可以了解用户的操作步骤和操作流程。 4.2.2 页面统计友盟还提供了页面统计功能，可以自动统计用户在各个页面的停留时间和访问次数。 示例代码： 12345678910// 在ViewController中添加页面统计代码- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [MobClick beginLogPageView:@&quot;ViewController&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [MobClick endLogPageView:@&quot;ViewController&quot;];&#125; 在友盟平台上，我们可以通过“页面分析”模块查看各个页面的访问情况和用户停留时间，从而了解用户的操作步骤和行为习惯。 4.3 操作步骤统计实现原理操作步骤统计的实现原理与埋点统计类似，主要基于事件记录和数据上传： 事件记录：在用户的每个操作步骤处添加自定义事件埋点，当用户触发相应的操作时，SDK会记录该事件，并将事件信息保存到本地。 数据上传：SDK会在合适的时机将本地记录的事件信息上传到服务器。 数据分析：服务器接收到事件数据后，会根据事件的触发顺序和时间戳进行分析，生成用户的操作步骤和操作流程数据，开发者可以在统计平台上查看这些数据。 五、其他统计方案5.1 Firebase AnalyticsFirebase Analytics是Google提供的一款免费的应用分析工具，它可以帮助开发者统计应用的用户行为、事件、用户留存率等信息。集成Firebase Analytics需要在项目中添加Firebase SDK，并在Firebase控制台进行相关配置。 5.1.1 实现原理Firebase Analytics的实现原理基于事件驱动和数据收集： 事件定义：开发者可以在应用中定义各种事件，如用户登录、购买商品等。当这些事件发生时，SDK会记录事件信息。 数据收集：SDK会收集用户的设备信息、应用使用情况、事件信息等数据，并将这些数据上传到Firebase服务器。 数据分析：Firebase服务器会对上传的数据进行分析和处理，生成各种统计报表和可视化图表，开发者可以在Firebase控制台查看这些数据。 5.2 Flurry AnalyticsFlurry Analytics是雅虎提供的一款应用分析工具，它可以提供详细的用户行为分析、广告分析等功能。集成Flurry Analytics需要在项目中添加Flurry SDK，并在Flurry控制台进行相关配置。 5.2.1 实现原理Flurry Analytics的实现原理与友盟和Firebase Analytics类似，主要包括以下几个方面： 事件跟踪：在应用中插入Flurry SDK提供的事件跟踪代码，当用户触发相应的操作时，SDK会记录事件信息。 数据收集：SDK会收集用户的设备信息、应用使用情况、事件信息等数据，并将这些数据上传到Flurry服务器。 数据分析：Flurry服务器会对上传的数据进行分析和处理，生成各种统计报表和分析结果，开发者可以在Flurry控制台查看这些数据。 六、总结开发统计在iOS开发中起着至关重要的作用。通过使用Bugly进行崩溃率统计，我们可以及时发现和解决应用中的崩溃问题，提高应用的稳定性；使用友盟进行用户数量统计、埋点统计和操作步骤统计，我们可以深入了解用户的行为和需求，为应用的优化和推广提供有力的支持。此外，还有其他一些统计方案可供选择，开发者可以根据自己的需求和项目特点选择合适的统计工具。 希望本文对大家在Objective - C开发中的统计工作有所帮助。 参考资料： Bugly官方文档：https://bugly.qq.com/docs/ 友盟官方文档：https://developer.umeng.com/docs/ Firebase Analytics官方文档：https://firebase.google.com/docs/analytics Flurry Analytics官方文档：https://developer.yahoo.com/flurry/docs/","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - 架构设计","path":"/iOS/OC底层原理/探索Objective - C底层 - 架构设计/","content":"引言在iOS开发的世界里，Objective - C作为一门经典的编程语言，其底层架构设计和设计模式对于构建高质量、可维护和可扩展的应用程序起着至关重要的作用。深入理解Objective - C的底层架构和设计模式，不仅能够帮助开发者更好地应对各种复杂的开发场景，还能提升代码的质量和性能。本文将深入探讨Objective - C底层架构设计和设计模式的相关知识点，结合具体的例子进行详细阐述。 一、架构设计基础概念1.1 分层架构分层架构是一种常见的架构设计模式，它将应用程序按照功能划分为不同的层次，每个层次负责特定的职责，层次之间通过接口进行交互。常见的分层架构有三层架构，包括表示层、业务逻辑层和数据访问层。 表示层（Presentation Layer）表示层负责与用户进行交互，展示数据和接收用户输入。在iOS开发中，通常由视图控制器（ViewController）和视图（View）组成。 1234567891011121314151617181920// 表示层示例：ViewController#import &quot;ViewController.h&quot;#import &quot;UserViewModel.h&quot;@interface ViewController ()@property (nonatomic, strong) UserViewModel *viewModel;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.viewModel = [[UserViewModel alloc] init]; [self.viewModel fetchUserInfoWithCompletion:^(NSString *userName) &#123; // 更新UI self.title = userName; &#125;];&#125;@end 业务逻辑层（Business Logic Layer）业务逻辑层负责处理应用程序的业务逻辑，如数据验证、计算等。在上面的例子中，UserViewModel 就属于业务逻辑层。 123456789101112131415161718192021222324252627// 业务逻辑层示例：UserViewModel#import &quot;UserViewModel.h&quot;#import &quot;UserService.h&quot;@interface UserViewModel ()@property (nonatomic, strong) UserService *userService;@end@implementation UserViewModel- (instancetype)init &#123; self = [super init]; if (self) &#123; self.userService = [[UserService alloc] init]; &#125; return self;&#125;- (void)fetchUserInfoWithCompletion:(void(^)(NSString *userName))completion &#123; [self.userService getUserInfoWithCompletion:^(NSString *userName) &#123; if (completion) &#123; completion(userName); &#125; &#125;];&#125;@end 数据访问层（Data Access Layer）数据访问层负责与数据源进行交互，如数据库、网络等。在上面的例子中，UserService 就属于数据访问层。 1234567891011121314151617181920212223242526272829// 数据访问层示例：UserService#import &quot;UserService.h&quot;@interface UserService ()@end@implementation UserService- (void)getUserInfoWithCompletion:(void(^)(NSString *userName))completion &#123; // 模拟网络请求 [self simulateNetworkRequestWithCompletion:^(NSDictionary *response) &#123; NSString *userName = response[@&quot;userName&quot;]; if (completion) &#123; completion(userName); &#125; &#125;];&#125;- (void)simulateNetworkRequestWithCompletion:(void(^)(NSDictionary *response))completion &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSDictionary *response = @&#123;@&quot;userName&quot;: @&quot;John Doe&quot;&#125;; if (completion) &#123; completion(response); &#125; &#125;);&#125;@end 1.2 模块化架构模块化架构将应用程序拆分为多个独立的模块，每个模块具有独立的功能和职责。模块之间通过接口进行通信，降低了模块之间的耦合度，提高了代码的可维护性和可扩展性。 模块划分原则 功能内聚：每个模块应该具有明确的功能，模块内部的代码应该紧密相关。 低耦合：模块之间的依赖关系应该尽量简单，避免模块之间的强耦合。 示例：一个电商应用可以划分为商品模块、订单模块、用户模块等。1234567891011121314151617181920// 商品模块接口@protocol ProductModuleProtocol &lt;NSObject&gt;- (void)showProductDetailWithProductID:(NSString *)productID;@end// 商品模块实现@interface ProductModule : NSObject &lt;ProductModuleProtocol&gt;@end@implementation ProductModule- (void)showProductDetailWithProductID:(NSString *)productID &#123; // 显示商品详情页 NSLog(@&quot;Showing product detail for product ID: %@&quot;, productID);&#125;@end 1.3 微服务架构微服务架构是一种将应用程序拆分为多个小型、自治的服务的架构模式。每个服务都可以独立开发、部署和扩展，通过网络进行通信。在iOS开发中，微服务架构通常用于与后端服务进行交互。 示例：一个社交应用可以将用户服务、消息服务、好友服务等拆分为独立的微服务。123456789101112131415161718192021222324252627282930313233// 用户服务接口@protocol UserServiceProtocol &lt;NSObject&gt;- (void)getUserInfoWithUserID:(NSString *)userID completion:(void(^)(NSDictionary *userInfo))completion;@end// 用户服务实现@interface UserService : NSObject &lt;UserServiceProtocol&gt;@end@implementation UserService- (void)getUserInfoWithUserID:(NSString *)userID completion:(void(^)(NSDictionary *userInfo))completion &#123; // 模拟网络请求获取用户信息 [self simulateNetworkRequestWithUserID:userID completion:^(NSDictionary *response) &#123; if (completion) &#123; completion(response); &#125; &#125;];&#125;- (void)simulateNetworkRequestWithUserID:(NSString *)userID completion:(void(^)(NSDictionary *response))completion &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSDictionary *response = @&#123;@&quot;userID&quot;: userID, @&quot;userName&quot;: @&quot;John Doe&quot;&#125;; if (completion) &#123; completion(response); &#125; &#125;);&#125;@end 二、常见架构模式2.1 MVC（Model - View - Controller）MVC是一种经典的架构模式，它将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。 模型（Model）模型负责存储和管理应用程序的数据和业务逻辑。 12345678910111213141516171819202122// 模型示例：UserModel@interface UserModel : NSObject@property (nonatomic, strong) NSString *userName;@property (nonatomic, strong) NSString *userID;- (instancetype)initWithUserName:(NSString *)userName userID:(NSString *)userID;@end@implementation UserModel- (instancetype)initWithUserName:(NSString *)userName userID:(NSString *)userID &#123; self = [super init]; if (self) &#123; self.userName = userName; self.userID = userID; &#125; return self;&#125;@end 视图（View）视图负责显示数据和接收用户输入。 12345678910111213141516171819// 视图示例：UserView@interface UserView : UIView@property (nonatomic, strong) UILabel *userNameLabel;@end@implementation UserView- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.userNameLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 200, 30)]; [self addSubview:self.userNameLabel]; &#125; return self;&#125;@end 控制器（Controller）控制器负责协调模型和视图之间的交互。 123456789101112131415161718192021222324252627282930313233343536// 控制器示例：UserViewController@interface UserViewController : UIViewController@property (nonatomic, strong) UserModel *userModel;@property (nonatomic, strong) UserView *userView;@end@implementation UserViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self fetchUserInfo];&#125;- (void)fetchUserInfo &#123; [self simulateNetworkRequestWithCompletion:^(NSDictionary *response) &#123; NSString *userName = response[@&quot;userName&quot;]; NSString *userID = response[@&quot;userID&quot;]; self.userModel = [[UserModel alloc] initWithUserName:userName userID:userID]; self.userView = [[UserView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.userView]; self.userView.userNameLabel.text = self.userModel.userName; &#125;];&#125;- (void)simulateNetworkRequestWithCompletion:(void(^)(NSDictionary *response))completion &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSDictionary *response = @&#123;@&quot;userName&quot;: @&quot;John Doe&quot;, @&quot;userID&quot;: @&quot;123&quot;&#125;; if (completion) &#123; completion(response); &#125; &#125;);&#125;@end 2.2 MVVM（Model - View - ViewModel）MVVM是在MVC基础上发展而来的架构模式，它引入了视图模型（ViewModel）来处理视图的显示逻辑。 视图模型（ViewModel）视图模型负责将模型数据转换为视图可以显示的格式，并处理视图的交互逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 视图模型示例：UserViewModel@interface UserViewModel : NSObject@property (nonatomic, strong) UserModel *userModel;@property (nonatomic, strong) NSString *displayName;- (instancetype)initWithUserModel:(UserModel *)userModel;- (void)fetchUserInfoWithCompletion:(void(^)(void))completion;@end@implementation UserViewModel- (instancetype)initWithUserModel:(UserModel *)userModel &#123; self = [super init]; if (self) &#123; self.userModel = userModel; self.displayName = [NSString stringWithFormat:@&quot;Name: %@&quot;, userModel.userName]; &#125; return self;&#125;- (void)fetchUserInfoWithCompletion:(void(^)(void))completion &#123; [self simulateNetworkRequestWithCompletion:^(NSDictionary *response) &#123; NSString *userName = response[@&quot;userName&quot;]; NSString *userID = response[@&quot;userID&quot;]; self.userModel = [[UserModel alloc] initWithUserName:userName userID:userID]; self.displayName = [NSString stringWithFormat:@&quot;Name: %@&quot;, self.userModel.userName]; if (completion) &#123; completion(); &#125; &#125;];&#125;- (void)simulateNetworkRequestWithCompletion:(void(^)(NSDictionary *response))completion &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSDictionary *response = @&#123;@&quot;userName&quot;: @&quot;John Doe&quot;, @&quot;userID&quot;: @&quot;123&quot;&#125;; if (completion) &#123; completion(response); &#125; &#125;);&#125;@end 视图和控制器视图和控制器的职责与MVC类似，但视图和控制器的耦合度更低，通过视图模型进行数据绑定。 123456789101112131415161718192021// 视图控制器示例：UserViewController@interface UserViewController : UIViewController@property (nonatomic, strong) UserViewModel *userViewModel;@property (nonatomic, strong) UserView *userView;@end@implementation UserViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.userViewModel = [[UserViewModel alloc] initWithUserModel:nil]; [self.userViewModel fetchUserInfoWithCompletion:^&#123; self.userView = [[UserView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.userView]; self.userView.userNameLabel.text = self.userViewModel.displayName; &#125;];&#125;@end 2.3 MVP（Model - View - Presenter）MVP将视图和业务逻辑分离，通过Presenter来协调两者之间的交互。 视图（View）视图负责显示数据和接收用户输入，并将用户操作传递给Presenter。 1234567891011121314151617181920212223242526272829// 视图示例：UserView@protocol UserViewProtocol &lt;NSObject&gt;- (void)displayUserName:(NSString *)userName;@end@interface UserView : UIView &lt;UserViewProtocol&gt;@property (nonatomic, strong) UILabel *userNameLabel;@end@implementation UserView- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.userNameLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 200, 30)]; [self addSubview:self.userNameLabel]; &#125; return self;&#125;- (void)displayUserName:(NSString *)userName &#123; self.userNameLabel.text = userName;&#125;@end 呈现器（Presenter）Presenter负责处理业务逻辑，并更新视图。 123456789101112131415161718192021222324252627282930313233343536373839404142// 呈现器示例：UserPresenter@interface UserPresenter : NSObject@property (nonatomic, weak) id&lt;UserViewProtocol&gt; view;@property (nonatomic, strong) UserModel *userModel;- (instancetype)initWithView:(id&lt;UserViewProtocol&gt;)view;- (void)fetchUserInfo;@end@implementation UserPresenter- (instancetype)initWithView:(id&lt;UserViewProtocol&gt;)view &#123; self = [super init]; if (self) &#123; self.view = view; &#125; return self;&#125;- (void)fetchUserInfo &#123; [self simulateNetworkRequestWithCompletion:^(NSDictionary *response) &#123; NSString *userName = response[@&quot;userName&quot;]; NSString *userID = response[@&quot;userID&quot;]; self.userModel = [[UserModel alloc] initWithUserName:userName userID:userID]; if (self.view) &#123; [self.view displayUserName:self.userModel.userName]; &#125; &#125;];&#125;- (void)simulateNetworkRequestWithCompletion:(void(^)(NSDictionary *response))completion &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSDictionary *response = @&#123;@&quot;userName&quot;: @&quot;John Doe&quot;, @&quot;userID&quot;: @&quot;123&quot;&#125;; if (completion) &#123; completion(response); &#125; &#125;);&#125;@end 视图控制器视图控制器负责创建Presenter和视图，并进行初始化。 12345678910111213141516171819// 视图控制器示例：UserViewController@interface UserViewController : UIViewController@property (nonatomic, strong) UserView *userView;@property (nonatomic, strong) UserPresenter *userPresenter;@end@implementation UserViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.userView = [[UserView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.userView]; self.userPresenter = [[UserPresenter alloc] initWithView:self.userView]; [self.userPresenter fetchUserInfo];&#125;@end 2.4 VIPER（View - Interactor - Presenter - Entity - Router）VIPER是一种更复杂的架构模式，它将应用程序分为五个部分：视图（View）、交互器（Interactor）、呈现器（Presenter）、实体（Entity）和路由器（Router）。 实体（Entity）实体负责存储应用程序的基本数据模型。 1234567891011// 实体示例：UserEntity@interface UserEntity : NSObject@property (nonatomic, strong) NSString *userName;@property (nonatomic, strong) NSString *userID;@end@implementation UserEntity@end 交互器（Interactor）交互器负责处理业务逻辑和数据访问。 1234567891011121314151617181920212223242526272829303132// 交互器示例：UserInteractor@interface UserInteractor : NSObject@property (nonatomic, strong) UserEntity *userEntity;- (void)fetchUserInfoWithCompletion:(void(^)(UserEntity *userEntity))completion;@end@implementation UserInteractor- (void)fetchUserInfoWithCompletion:(void(^)(UserEntity *userEntity))completion &#123; [self simulateNetworkRequestWithCompletion:^(NSDictionary *response) &#123; UserEntity *userEntity = [[UserEntity alloc] init]; userEntity.userName = response[@&quot;userName&quot;]; userEntity.userID = response[@&quot;userID&quot;]; if (completion) &#123; completion(userEntity); &#125; &#125;];&#125;- (void)simulateNetworkRequestWithCompletion:(void(^)(NSDictionary *response))completion &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSDictionary *response = @&#123;@&quot;userName&quot;: @&quot;John Doe&quot;, @&quot;userID&quot;: @&quot;123&quot;&#125;; if (completion) &#123; completion(response); &#125; &#125;);&#125;@end 呈现器（Presenter）Presenter负责协调视图和交互器之间的交互。 1234567891011121314151617181920212223242526272829// 呈现器示例：UserPresenter@protocol UserViewProtocol;@interface UserPresenter : NSObject@property (nonatomic, weak) id&lt;UserViewProtocol&gt; view;@property (nonatomic, strong) UserInteractor *userInteractor;- (void)viewDidLoad;@end@protocol UserViewProtocol &lt;NSObject&gt;- (void)displayUserInfo:(UserEntity *)userEntity;@end@implementation UserPresenter- (void)viewDidLoad &#123; [self.userInteractor fetchUserInfoWithCompletion:^(UserEntity *userEntity) &#123; if (self.view) &#123; [self.view displayUserInfo:userEntity]; &#125; &#125;];&#125;@end 视图（View）视图负责显示数据和接收用户输入。 1234567891011121314151617181920212223// 视图示例：UserView@interface UserView : UIView &lt;UserViewProtocol&gt;@property (nonatomic, strong) UILabel *userNameLabel;@end@implementation UserView- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.userNameLabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 10, 200, 30)]; [self addSubview:self.userNameLabel]; &#125; return self;&#125;- (void)displayUserInfo:(UserEntity *)userEntity &#123; self.userNameLabel.text = userEntity.userName;&#125;@end 路由器（Router）路由器负责处理视图之间的导航。 123456789101112131415// 路由器示例：UserRouter@interface UserRouter : NSObject+ (void)presentUserViewControllerFromViewController:(UIViewController *)viewController;@end@implementation UserRouter+ (void)presentUserViewControllerFromViewController:(UIViewController *)viewController &#123; UserViewController *userViewController = [[UserViewController alloc] init]; [viewController presentViewController:userViewController animated:YES completion:nil];&#125;@end 视图控制器视图控制器负责创建和协调VIPER组件。 1234567891011121314151617181920212223// 视图控制器示例：UserViewController@interface UserViewController : UIViewController@property (nonatomic, strong) UserView *userView;@property (nonatomic, strong) UserPresenter *userPresenter;@property (nonatomic, strong) UserInteractor *userInteractor;@end@implementation UserViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.userView = [[UserView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:self.userView]; self.userInteractor = [[UserInteractor alloc] init]; self.userPresenter = [[UserPresenter alloc] init]; self.userPresenter.view = self.userView; self.userPresenter.userInteractor = self.userInteractor; [self.userPresenter viewDidLoad];&#125;@end 三、组件化架构3.1 组件化概述组件化架构是将一个大型应用拆分成多个独立的组件，每个组件可以独立开发、测试和维护。组件之间通过接口进行通信，降低了组件之间的耦合度，提高了代码的可维护性和可扩展性。在iOS开发中，组件化可以将不同的业务模块拆分成独立的组件，例如用户模块、商品模块、订单模块等。 3.2 组件化的实现方式3.2.1 基于URL路由的组件化通过URL路由的方式实现组件之间的通信，每个组件可以注册自己的URL，当需要调用某个组件时，通过URL进行跳转。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 路由管理类@interface RouterManager : NSObject+ (instancetype)sharedManager;- (void)registerURLPattern:(NSString *)pattern handler:(void (^)(NSDictionary *parameters))handler;- (BOOL)openURL:(NSString *)url;@end@implementation RouterManager+ (instancetype)sharedManager &#123; static RouterManager *sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedManager = [[RouterManager alloc] init]; &#125;); return sharedManager;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; self.routeHandlers = [NSMutableDictionary dictionary]; &#125; return self;&#125;- (void)registerURLPattern:(NSString *)pattern handler:(void (^)(NSDictionary *parameters))handler &#123; if (pattern &amp;&amp; handler) &#123; self.routeHandlers[pattern] = handler; &#125;&#125;- (BOOL)openURL:(NSString *)url &#123; NSURL *nsURL = [NSURL URLWithString:url]; NSString *host = nsURL.host; NSString *query = nsURL.query; NSDictionary *parameters = [self parseQueryString:query]; void (^handler)(NSDictionary *parameters) = self.routeHandlers[host]; if (handler) &#123; handler(parameters); return YES; &#125; return NO;&#125;- (NSDictionary *)parseQueryString:(NSString *)query &#123; NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; if (query.length &gt; 0) &#123; NSArray *pairs = [query componentsSeparatedByString:@&quot;&amp;&quot;]; for (NSString *pair in pairs) &#123; NSArray *keyValue = [pair componentsSeparatedByString:@&quot;=&quot;]; if (keyValue.count == 2) &#123; NSString *key = keyValue[0]; NSString *value = keyValue[1]; parameters[key] = value; &#125; &#125; &#125; return parameters;&#125;@end 3.2.2 基于协议的组件化通过定义协议的方式实现组件之间的通信，每个组件实现自己的协议，其他组件通过协议来调用该组件的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 组件协议@protocol UserComponentProtocol &lt;NSObject&gt;- (void)showUserProfileWithUserID:(NSString *)userID;@end// 用户组件实现@interface UserComponent : NSObject &lt;UserComponentProtocol&gt;@end@implementation UserComponent- (void)showUserProfileWithUserID:(NSString *)userID &#123; NSLog(@&quot;Showing user profile for user ID: %@&quot;, userID);&#125;@end// 组件管理类@interface ComponentManager : NSObject+ (instancetype)sharedManager;- (void)registerComponent:(id)component forProtocol:(Protocol *)protocol;- (id)getComponentForProtocol:(Protocol *)protocol;@end@implementation ComponentManager+ (instancetype)sharedManager &#123; static ComponentManager *sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedManager = [[ComponentManager alloc] init]; &#125;); return sharedManager;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; self.componentMap = [NSMutableDictionary dictionary]; &#125; return self;&#125;- (void)registerComponent:(id)component forProtocol:(Protocol *)protocol &#123; if (component &amp;&amp; protocol) &#123; NSString *protocolName = NSStringFromProtocol(protocol); self.componentMap[protocolName] = component; &#125;&#125;- (id)getComponentForProtocol:(Protocol *)protocol &#123; NSString *protocolName = NSStringFromProtocol(protocol); return self.componentMap[protocolName];&#125;@end 3.3 组件化示例假设我们有一个电商应用，包含商品模块和用户模块，我们可以将这两个模块拆分成独立的组件。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 商品模块@interface ProductComponent : NSObject- (void)showProductList;@end@implementation ProductComponent- (void)showProductList &#123; NSLog(@&quot;Showing product list&quot;);&#125;@end// 用户模块@interface UserComponent : NSObject- (void)showUserLogin;@end@implementation UserComponent- (void)showUserLogin &#123; NSLog(@&quot;Showing user login page&quot;);&#125;@end// 在AppDelegate中注册组件- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [ComponentManager.sharedManager registerComponent:[[ProductComponent alloc] init] forProtocol:@protocol(ProductComponentProtocol)]; [ComponentManager.sharedManager registerComponent:[[UserComponent alloc] init] forProtocol:@protocol(UserComponentProtocol)]; return YES;&#125;// 在其他地方调用组件功能id&lt;ProductComponentProtocol&gt; productComponent = [ComponentManager.sharedManager getComponentForProtocol:@protocol(ProductComponentProtocol)];[productComponent showProductList];id&lt;UserComponentProtocol&gt; userComponent = [ComponentManager.sharedManager getComponentForProtocol:@protocol(UserComponentProtocol)];[userComponent showUserLogin]; 四、设计模式4.1 单例模式单例模式确保一个类只有一个实例，并提供一个全局访问点。在iOS开发中，单例模式常用于管理共享资源，如网络请求管理器、数据库管理器等。 1234567891011121314151617181920212223242526272829303132// 单例模式示例：NetworkManager@interface NetworkManager : NSObject+ (instancetype)sharedManager;- (void)sendRequestWithURL:(NSString *)url completion:(void(^)(NSData *data, NSError *error))completion;@end@implementation NetworkManager+ (instancetype)sharedManager &#123; static NetworkManager *sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedManager = [[NetworkManager alloc] init]; &#125;); return sharedManager;&#125;- (void)sendRequestWithURL:(NSString *)url completion:(void(^)(NSData *data, NSError *error))completion &#123; // 模拟网络请求 NSURL *requestURL = [NSURL URLWithString:url]; NSURLSessionDataTask *task = [[NSURLSession sharedSession] dataTaskWithURL:requestURL completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (completion) &#123; completion(data, error); &#125; &#125;]; [task resume];&#125;@end 4.2 观察者模式观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会得到通知并自动更新。在iOS开发中，NSNotificationCenter 就是一个典型的观察者模式的实现。 12345678910// 观察者模式示例：通知中心// 发布通知[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;DataUpdatedNotification&quot; object:nil userInfo:@&#123;@&quot;data&quot;: @&quot;New Data&quot;&#125;];// 注册观察者[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;DataUpdatedNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSDictionary *userInfo = note.userInfo; NSString *data = userInfo[@&quot;data&quot;]; NSLog(@&quot;Received updated data: %@&quot;, data);&#125;]; 4.3 工厂模式工厂模式是一种创建对象的设计模式，它将对象的创建和使用分离，通过一个工厂类来创建对象。在iOS开发中，工厂模式常用于创建不同类型的视图、控制器等。 1234567891011121314151617181920212223// 工厂模式示例：视图工厂@interface ViewFactory : NSObject+ (UIView *)createViewWithType:(NSString *)type;@end@implementation ViewFactory+ (UIView *)createViewWithType:(NSString *)type &#123; if ([type isEqualToString:@&quot;redView&quot;]) &#123; UIView *redView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; redView.backgroundColor = [UIColor redColor]; return redView; &#125; else if ([type isEqualToString:@&quot;blueView&quot;]) &#123; UIView *blueView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; blueView.backgroundColor = [UIColor blueColor]; return blueView; &#125; return nil;&#125;@end 4.4 代理模式代理模式是一种对象行为模式，它允许一个对象将某些任务委托给另一个对象来完成。在iOS开发中，代理模式常用于处理用户交互、数据传递等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 代理模式示例：协议和代理@protocol CustomViewDelegate &lt;NSObject&gt;- (void)customViewDidTap:(id)customView;@end@interface CustomView : UIView@property (nonatomic, weak) id&lt;CustomViewDelegate&gt; delegate;@end@implementation CustomView- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTap:)]; [self addGestureRecognizer:tapGesture]; &#125; return self;&#125;- (void)handleTap:(UITapGestureRecognizer *)gesture &#123; if ([self.delegate respondsToSelector:@selector(customViewDidTap:)]) &#123; [self.delegate customViewDidTap:self]; &#125;&#125;@end// 使用代理@interface ViewController () &lt;CustomViewDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CustomView *customView = [[CustomView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)]; customView.delegate = self; [self.view addSubview:customView];&#125;- (void)customViewDidTap:(id)customView &#123; NSLog(@&quot;Custom view was tapped&quot;);&#125;@end 4.5 装饰器模式装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。在iOS开发中，装饰器模式可以用于动态地给视图添加额外的功能，如边框、阴影等。 123456789101112131415161718192021222324// 装饰器模式示例：视图装饰器@interface ViewDecorator : UIView@property (nonatomic, strong) UIView *decoratedView;- (instancetype)initWithView:(UIView *)view;@end@implementation ViewDecorator- (instancetype)initWithView:(UIView *)view &#123; self = [super initWithFrame:view.frame]; if (self) &#123; self.decoratedView = view; [self addSubview:view]; // 添加装饰效果，如边框 self.layer.borderColor = [UIColor blackColor].CGColor; self.layer.borderWidth = 1.0; &#125; return self;&#125;@end 五、设计模式的原则5.1 单一职责原则（SRP）一个类应该只有一个引起它变化的原因。在iOS开发中，例如一个视图控制器只负责处理视图的显示和用户交互，而不负责数据的获取和处理。 123456789101112131415161718192021222324// 单一职责原则示例：ViewController@interface ViewController : UIViewController@property (nonatomic, strong) UIButton *button;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.button = [UIButton buttonWithType:UIButtonTypeSystem]; self.button.frame = CGRectMake(100, 100, 100, 50); [self.button setTitle:@&quot;Click Me&quot; forState:UIControlStateNormal]; [self.button addTarget:self action:@selector(buttonTapped) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:self.button];&#125;- (void)buttonTapped &#123; // 只处理按钮点击的UI交互 NSLog(@&quot;Button tapped&quot;);&#125;@end 5.2 开放 - 封闭原则（OCP）软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。在iOS开发中，可以通过使用协议和继承来实现开放 - 封闭原则。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 开放 - 封闭原则示例：图形绘制@protocol ShapeProtocol &lt;NSObject&gt;- (void)draw;@end@interface Circle : NSObject &lt;ShapeProtocol&gt;@end@implementation Circle- (void)draw &#123; NSLog(@&quot;Drawing a circle&quot;);&#125;@end@interface Rectangle : NSObject &lt;ShapeProtocol&gt;@end@implementation Rectangle- (void)draw &#123; NSLog(@&quot;Drawing a rectangle&quot;);&#125;@end// 新增三角形@interface Triangle : NSObject &lt;ShapeProtocol&gt;@end@implementation Triangle- (void)draw &#123; NSLog(@&quot;Drawing a triangle&quot;);&#125;@end 5.3 里氏替换原则（LSP）子类可以替换其父类并且出现在父类能够出现的任何地方。在iOS开发中，例如自定义的视图类可以替换其父类 UIView。 1234567891011// 里氏替换原则示例：自定义视图@interface CustomView : UIView@end@implementation CustomView@end// 在使用UIView的地方可以使用CustomViewUIView *view = [[CustomView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; 5.4 接口隔离原则（ISP）客户端不应该依赖它不需要的接口。在iOS开发中，例如一个视图控制器只需要实现它需要的协议方法。 123456789// 接口隔离原则示例：协议@protocol DataSourceProtocol &lt;NSObject&gt;- (NSInteger)numberOfItems;- (id)itemAtIndex:(NSInteger)index;@end@protocol DelegateProtocol &lt;","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - 性能优化","path":"/iOS/OC底层原理/探索Objective - C底层 - 性能优化/","content":"引言在iOS开发领域，性能优化是一项至关重要且极具挑战性的工作。良好的性能优化不仅能显著提升用户体验，减少用户等待时间和操作卡顿，还能降低设备资源消耗，延长设备续航时间。而深入理解Objective - C底层机制则是进行高效性能优化的关键所在。本文将从多个角度、多个维度探讨iOS应用的性能优化方案，涵盖CPU、内存、磁盘I&#x2F;O、网络、渲染、耗电、App卡顿、App启动、App瘦身等方面，同时结合具体例子详细阐述每个方案的实现原理和应用场景，并介绍如何对这些性能指标进行监测，包含具体的操作步骤和预期显示结果。 一、CPU性能优化1.1 算法和数据结构优化选择合适的算法和数据结构能够大幅减少CPU的计算量。例如，在需要频繁查找元素的场景中，使用NSDictionary或NSSet比使用NSArray更高效，因为NSDictionary和NSSet的查找操作时间复杂度为O(1)，而NSArray的查找操作时间复杂度为O(n)。 12345678910111213// 使用NSArray查找元素NSArray *array = @[@1, @2, @3, @4, @5];BOOL isFoundInArray = NO;for (NSNumber *num in array) &#123; if ([num isEqualToNumber:@3]) &#123; isFoundInArray = YES; break; &#125;&#125;// 使用NSDictionary查找元素NSDictionary *dictionary = @&#123;@&quot;key1&quot;: @1, @&quot;key2&quot;: @2, @&quot;key3&quot;: @3&#125;;BOOL isFoundInDictionary = [dictionary objectForKey:@&quot;key3&quot;] != nil; 1.2 避免频繁的方法调用频繁的方法调用会带来额外的CPU开销，特别是在循环中。可以将一些不变的计算结果提前计算好，避免在循环中重复计算。 1234567891011// 未优化的代码for (int i = 0; i &lt; 1000; i++) &#123; CGFloat width = [UIScreen mainScreen].bounds.size.width; // 使用width进行一些操作&#125;// 优化后的代码CGFloat screenWidth = [UIScreen mainScreen].bounds.size.width;for (int i = 0; i &lt; 1000; i++) &#123; // 使用screenWidth进行一些操作&#125; 1.3 多线程优化合理使用多线程可以将一些耗时的操作放在后台线程执行，避免阻塞主线程，从而提高应用的响应性能。例如，在进行网络请求或大量数据处理时，可以使用GCD（Grand Central Dispatch）或NSOperationQueue。 1234567891011// 使用GCD进行异步网络请求dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 模拟网络请求 NSURL *url = [NSURL URLWithString:@&quot;https://example.com&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; dispatch_async(dispatch_get_main_queue(), ^&#123; if (data) &#123; // 在主线程更新UI &#125; &#125;);&#125;); 1.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择CPU Usage模板。 点击红色录制按钮开始录制，此时Instruments会开始收集应用的CPU使用数据。 在应用中进行一些操作，模拟用户的正常使用场景。 操作完成后，点击停止按钮结束录制。 预期显示结果 CPU使用率图表：展示应用在不同时间点的CPU使用率，你可以看到CPU使用率的波动情况。如果某个时间段CPU使用率过高，可能意味着该时间段内有大量的CPU计算任务正在执行。 线程活动列表：列出应用中所有线程的活动情况，包括线程的名称、状态、CPU使用率等。你可以通过查看线程的CPU使用率，找出占用CPU资源较多的线程。例如，如果发现某个自定义线程的CPU使用率一直很高，可能需要检查该线程中执行的代码是否存在性能问题。 二、内存性能优化2.1 避免内存泄漏内存泄漏会导致应用的内存占用不断增加，最终可能导致应用崩溃。常见的内存泄漏场景包括循环引用、未释放的对象等。可以使用Instruments工具来检测内存泄漏。 1234567891011121314151617181920212223242526// 循环引用示例@interface MyClass : NSObject@property (nonatomic, strong) void (^block)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; self.block = ^&#123; // 这里会产生循环引用 [self doSomething]; &#125;; &#125; return self;&#125;@end// 解决循环引用__weak typeof(self) weakSelf = self;self.block = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomething]; &#125;&#125;; 2.2 合理使用缓存缓存可以减少重复的计算和数据加载，从而降低内存和CPU的开销。例如，在图片加载场景中，可以使用NSCache来缓存已经加载过的图片。 1234567891011121314151617181920212223242526@interface ImageLoader : NSObject@property (nonatomic, strong) NSCache *imageCache;@end@implementation ImageLoader- (instancetype)init &#123; self = [super init]; if (self) &#123; self.imageCache = [[NSCache alloc] init]; &#125; return self;&#125;- (UIImage *)loadImageWithURL:(NSURL *)url &#123; UIImage *image = [self.imageCache objectForKey:url]; if (!image) &#123; // 从网络加载图片 NSData *data = [NSData dataWithContentsOfURL:url]; image = [UIImage imageWithData:data]; if (image) &#123; [self.imageCache setObject:image forKey:url]; &#125; &#125; return image;&#125;@end 2.3 及时释放不再使用的对象在对象不再使用时，及时将其置为nil，以便系统能够及时回收内存。 123NSMutableArray *array = [NSMutableArray array];// 使用array进行一些操作array = nil; // 释放array占用的内存 2.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择Allocations模板。 点击红色录制按钮开始录制，Instruments会开始记录应用的内存分配和释放情况。 在应用中进行一系列操作，模拟用户的正常使用流程。 操作结束后，点击停止按钮停止录制。 预期显示结果 内存分配图表：展示应用在不同时间点的内存分配情况，包括对象的创建和销毁。你可以观察到内存的增长趋势，如果内存持续增长而没有相应的下降，可能存在内存泄漏问题。 对象分配列表：列出应用中所有分配的对象，包括对象的类名、分配时间、占用内存大小等信息。通过查看这个列表，你可以找出占用内存较多的对象类型。例如，如果发现某个自定义的大数组对象一直存在且占用大量内存，可能需要检查该对象的使用和释放逻辑。 内存泄漏检测结果：Instruments会标记出可能存在内存泄漏的对象。如果检测到内存泄漏，会在列表中显示泄漏对象的相关信息，你可以点击这些对象查看具体的堆栈信息，从而定位到泄漏的代码位置。 三、磁盘I&#x2F;O性能优化3.1 批量读写操作频繁的磁盘读写操作会导致性能下降，可以将一些小的读写操作合并成批量操作，减少磁盘I&#x2F;O的次数。 1234567891011// 未优化的代码for (NSString *string in stringArray) &#123; [string writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:nil];&#125;// 优化后的代码NSMutableString *combinedString = [NSMutableString string];for (NSString *string in stringArray) &#123; [combinedString appendString:string];&#125;[combinedString writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:nil]; 3.2 使用异步读写操作使用异步读写操作可以避免阻塞主线程，提高应用的响应性能。可以使用GCD来实现异步读写操作。 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSString *filePath = @&quot;/path/to/file&quot;; NSString *content = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; if (content) &#123; // 在主线程更新UI &#125; &#125;);&#125;); 3.3 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择File Activity模板。 点击红色录制按钮开始录制，Instruments会开始收集应用的磁盘I&#x2F;O活动数据。 在应用中进行涉及磁盘读写的操作，如保存文件、读取配置等。 操作完成后，点击停止按钮结束录制。 预期显示结果 磁盘I&#x2F;O活动图表：展示应用在不同时间点的磁盘读写操作情况，包括读写的时间、读写的数据量等。你可以看到磁盘I&#x2F;O的频率和数据量的变化。如果发现某个时间段内磁盘I&#x2F;O非常频繁，可能需要优化该时间段内的读写操作。 文件操作列表：列出应用进行的所有文件操作，包括文件的路径、操作类型（读或写）、操作时间、操作的数据量等信息。通过查看这个列表，你可以找出耗时较长或数据量较大的文件操作。例如，如果发现某个大文件的读取操作耗时过长，可能需要考虑优化文件的读取方式或使用缓存。 四、网络性能优化4.1 减少网络请求次数合并一些小的网络请求，减少网络连接的建立和断开次数，从而降低网络开销。例如，将多个小的数据请求合并成一个大的请求。 123456789// 未优化的代码NSURL *url1 = [NSURL URLWithString:@&quot;https://example.com/api1&quot;];NSURL *url2 = [NSURL URLWithString:@&quot;https://example.com/api2&quot;];NSData *data1 = [NSData dataWithContentsOfURL:url1];NSData *data2 = [NSData dataWithContentsOfURL:url2];// 优化后的代码NSURL *combinedURL = [NSURL URLWithString:@&quot;https://example.com/api?param1=value1&amp;param2=value2&quot;];NSData *combinedData = [NSData dataWithContentsOfURL:combinedURL]; 4.2 压缩传输数据对传输的数据进行压缩可以减少数据量，从而提高网络传输速度。例如，在发送JSON数据时，可以使用NSJSONSerialization将数据转换为JSON格式，并使用NSData的gzipData方法进行压缩。 123NSDictionary *dataDict = @&#123;@&quot;key1&quot;: @&quot;value1&quot;, @&quot;key2&quot;: @&quot;value2&quot;&#125;;NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dataDict options:0 error:nil];NSData *compressedData = [jsonData gzipData]; 4.3 使用缓存机制对于一些不经常变化的数据，可以使用缓存机制，避免重复的网络请求。例如，使用NSURLCache来缓存网络响应。 123456789101112NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil];[NSURLCache setSharedURLCache:urlCache];NSURL *url = [NSURL URLWithString:@&quot;https://example.com&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:60.0];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (data) &#123; // 处理响应数据 &#125;&#125;];[task resume]; 4.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择Network模板。 点击红色录制按钮开始录制，Instruments会开始记录应用的网络请求情况。 在应用中进行网络相关的操作，如登录、获取数据等。 操作完成后，点击停止按钮结束录制。 预期显示结果 网络请求列表：列出应用进行的所有网络请求，包括请求的URL、请求方法（GET、POST等）、请求时间、响应时间、请求数据大小、响应数据大小等信息。通过查看这个列表，你可以找出耗时较长或数据量较大的网络请求。例如，如果发现某个请求的响应时间过长，可能需要检查服务器端的性能或优化请求的参数。 网络流量图表：展示应用在不同时间点的网络流量情况，包括上传和下载的数据量。你可以观察到网络流量的变化趋势，判断是否存在异常的流量高峰。如果发现某个时间段内网络流量突然增大，可能需要检查是否有不必要的网络请求或数据传输。 五、渲染性能优化5.1 减少视图层级复杂的视图层级会增加渲染的复杂度，导致性能下降。可以通过合并视图、减少不必要的视图嵌套等方式来简化视图层级。 123456789// 未优化的视图层级UIView *view1 = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];UIView *view2 = [[UIView alloc] initWithFrame:CGRectMake(10, 10, 80, 80)];[view1 addSubview:view2];UIView *view3 = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 60, 60)];[view2 addSubview:view3];// 优化后的视图层级UIView *optimizedView = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 60, 60)]; 5.2 避免离屏渲染离屏渲染会消耗额外的CPU和GPU资源，导致性能下降。可以通过设置视图的属性来避免离屏渲染，例如，避免使用cornerRadius和masksToBounds同时设置。 123456789// 可能导致离屏渲染的代码UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];view.layer.cornerRadius = 10;view.layer.masksToBounds = YES;// 优化后的代码CAShapeLayer *shapeLayer = [CAShapeLayer layer];shapeLayer.path = [UIBezierPath bezierPathWithRoundedRect:view.bounds cornerRadius:10].CGPath;view.layer.mask = shapeLayer; 5.3 异步绘制对于一些复杂的绘制操作，可以使用异步绘制来避免阻塞主线程。可以使用UIGraphicsBeginImageContextWithOptions和UIGraphicsEndImageContext来实现异步绘制。 1234567891011dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, [UIScreen mainScreen].scale); // 进行绘制操作 CGContextRef context = UIGraphicsGetCurrentContext(); // ... UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; &#125;);&#125;); 5.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择Core Animation模板。 点击红色录制按钮开始录制，Instruments会开始收集应用的渲染性能数据。 在应用中进行一些涉及界面渲染的操作，如滚动列表、切换视图等。 操作完成后，点击停止按钮结束录制。 预期显示结果 帧率图表：展示应用在不同时间点的帧率情况，正常情况下帧率应该保持在60fps左右。如果帧率低于60fps，可能会出现卡顿现象。你可以观察帧率的波动情况，找出帧率下降的时间段和操作场景。 离屏渲染检测结果：Instruments会标记出可能存在离屏渲染的视图。如果检测到离屏渲染，会在列表中显示相关视图的信息，你可以点击这些视图查看具体的堆栈信息，从而定位到产生离屏渲染的代码位置。 视图层级分析：可以查看应用的视图层级结构，了解每个视图的大小、位置、透明度等属性。通过分析视图层级，你可以找出过于复杂的视图层级，进行优化。 六、耗电优化6.1 减少不必要的后台任务应用在后台运行时会消耗电量，因此应尽量减少不必要的后台任务。可以使用UIApplication的beginBackgroundTaskWithName:expirationHandler:方法来管理后台任务，并在任务完成后及时结束。 1234567891011__block UIBackgroundTaskIdentifier backgroundTask = [application beginBackgroundTaskWithName:@&quot;MyBackgroundTask&quot; expirationHandler:^&#123; [application endBackgroundTask:backgroundTask]; backgroundTask = UIBackgroundTaskInvalid;&#125;];// 执行后台任务dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 任务代码 [application endBackgroundTask:backgroundTask]; backgroundTask = UIBackgroundTaskInvalid;&#125;); 6.2 优化网络请求网络请求是耗电的主要原因之一，应尽量减少不必要的网络请求，并优化请求的频率和数据量。例如，使用缓存机制避免重复请求，合理设置请求的时间间隔等。 6.3 优化传感器使用如果应用使用了传感器（如GPS、加速度计等），应合理使用传感器，避免长时间开启。例如，在不需要使用GPS时及时关闭，或者降低传感器的采样频率。 6.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择Energy Log模板。 点击红色录制按钮开始录制，Instruments会开始监测应用的能耗情况。 在应用中进行各种操作，模拟用户的正常使用场景。 操作完成后，点击停止按钮结束录制。 预期显示结果 能耗概述：显示应用在录制时间段内的总能耗情况，包括CPU、网络、传感器等方面的能耗占比。你可以通过这个概述了解应用的主要能耗来源。 能耗详细数据：列出应用在不同时间点的各项能耗数据，如CPU使用率、网络流量、传感器使用情况等。通过查看这些详细数据，你可以找出能耗过高的时间段和操作场景。例如，如果发现某个时间段内GPS传感器的能耗过高，可能需要检查GPS的使用逻辑是否合理。 七、App卡顿优化7.1 屏幕成像原理和卡顿产生的原因屏幕成像的基本原理是CPU负责计算显示内容，如视图的布局、绘制等；GPU负责将CPU计算好的内容进行渲染，生成图像帧；然后将图像帧发送到屏幕进行显示。屏幕会按照固定的帧率（如60Hz）进行刷新，即每秒刷新60次。 卡顿产生的原因主要是CPU或GPU的处理时间过长，导致无法在屏幕刷新周期内完成图像帧的计算和渲染。例如，在主线程进行大量的计算或I&#x2F;O操作，或者视图层级过于复杂导致渲染时间过长等。 7.2 优化方案 避免在主线程进行耗时操作：将耗时的操作（如网络请求、数据处理等）放在后台线程执行，避免阻塞主线程。 优化视图渲染：减少视图层级，避免离屏渲染，使用异步绘制等方法来提高渲染性能。 优化数据加载：使用缓存机制，避免重复加载数据，同时优化数据加载的方式，减少加载时间。 7.3 通过CADisplayLink显示帧率为了实时监测每个页面的帧率并根据帧率范围显示不同颜色，我们创建一个 FPSLabel 类，它继承自 UILabel，并利用 CADisplayLink 来实现该功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import &lt;UIKit/UIKit.h&gt;@interface FPSLabel : UILabel@end@implementation FPSLabel &#123; CADisplayLink *displayLink; NSUInteger frameCount; NSTimeInterval lastTime;&#125;- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.textAlignment = NSTextAlignmentCenter; self.font = [UIFont systemFontOfSize:12]; self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.7]; self.textColor = [UIColor whiteColor]; self.layer.cornerRadius = 5; self.clipsToBounds = YES; displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)]; [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes]; lastTime = CACurrentMediaTime(); &#125; return self;&#125;- (void)tick:(CADisplayLink *)link &#123; frameCount++; NSTimeInterval currentTime = CACurrentMediaTime(); if (currentTime - lastTime &gt;= 1.0) &#123; float fps = frameCount / (currentTime - lastTime); frameCount = 0; lastTime = currentTime; UIColor *color; if (fps &gt; 55) &#123; color = [UIColor greenColor]; &#125; else if (fps &gt;= 50) &#123; color = [UIColor yellowColor]; &#125; else &#123; color = [UIColor redColor]; &#125; self.textColor = color; self.text = [NSString stringWithFormat:@&quot;%.0f FPS&quot;, fps]; &#125;&#125;- (void)dealloc &#123; [displayLink invalidate];&#125;@end 在每个页面的 viewDidLoad 方法中添加 FPSLabel： 1234567891011121314151617#import &quot;ViewController.h&quot;#import &quot;FPSLabel.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; FPSLabel *fpsLabel = [[FPSLabel alloc] initWithFrame:CGRectMake(10, 10, 60, 20)]; [self.view addSubview:fpsLabel];&#125;@end 7.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择Core Animation模板。 点击红色录制按钮开始录制，Instruments会开始收集应用的帧率数据。 在应用中进行各种可能导致卡顿的操作，如快速滚动列表、切换复杂视图等。 操作完成后，点击停止按钮结束录制。 预期显示结果 帧率变化图表：展示应用在操作过程中的帧率变化情况。如果帧率持续低于60fps，或者在某些操作时帧率急剧下降，说明可能存在卡顿问题。你可以根据帧率下降的时间点和操作场景，定位到可能导致卡顿的代码位置。例如，如果在快速滚动列表时帧率明显下降，可能需要检查列表的数据源加载和单元格渲染逻辑。 八、App启动优化8.1 启动流程分析App的启动过程主要分为冷启动和热启动。冷启动是指应用从完全关闭状态启动，需要进行一系列的初始化操作，如加载Mach - O文件、执行静态初始化代码、创建UI等；热启动是指应用在后台运行时被切换到前台，启动速度相对较快。 8.2 优化方案 减少静态初始化代码：将一些不必要的静态初始化代码延迟到需要使用时再执行，减少启动时的初始化时间。 优化Main函数之前的加载时间：可以通过精简Mach - O文件、减少动态库的加载等方式来优化Main函数之前的加载时间。 异步加载数据：将一些不影响UI显示的数据加载操作放在后台线程执行，避免阻塞主线程。 8.3 通过dyld打印启动耗时动态链接器（dyld）是负责在程序启动时加载和链接共享库的程序。我们可以借助环境变量 DYLD_PRINT_STATISTICS 来打印出 dyld 加载过程中的详细时间统计信息。 在 Xcode 中配置环境变量步骤如下： 选择你的项目 target。 切换到 Edit Scheme。 在 Run 配置的 Arguments 选项卡中，在 Environment Variables 部分添加一个新的变量，名称为 DYLD_PRINT_STATISTICS，值设置为 1。 当你再次运行应用时，控制台会输出类似如下的启动耗时信息： 1234567891011121314151617dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundationdyld: loaded: /System/Library/Frameworks/CoreGraphics.framework/Versions/A/CoreGraphicsdyld: total time: 1.234 seconds (100.0%)dyld: total images loaded: 123dyld: total segments mapped: 12, into 234 pagesdyld: total images loading time: 0.123 seconds (10.0%)dyld: total dtrace DOF registration time: 0.012 seconds (1.0%)dyld: total rebase fixups: 12345dyld: total rebase fixups time: 0.023 seconds (1.9%)dyld: total binding fixups: 1234dyld: total binding fixups time: 0.034 seconds (2.8%)dyld: total weak binding fixups time: 0.001 seconds (0.1%)dyld: total redo shared cached bindings time: 0.002 seconds (0.2%)dyld: total bindings lazily fixed up: 0 of 123dyld: total initializer time: 0.890 seconds (72.1%)dyld: total dtrace DIF registration time: 0.001 seconds (0.1%)dyld: total termination time: 0.001 seconds (0.1%) 这些信息详细展示了 dyld 在加载过程中各个阶段所花费的时间，通过分析这些数据，你可以找出启动过程中的性能瓶颈，从而进行针对性的优化。 8.4 性能监测操作步骤 打开Xcode，运行你的iOS应用。 选择Xcode -&gt; Open Developer Tool -&gt; Instruments。 在Instruments模板选择界面，选择Launch Time模板。 点击红色录制按钮开始录制，Instruments会开始记录应用的启动时间。 等待应用启动完成。 应用启动完成后，点击停止按钮结束录制。 预期显示结果 启动时间分解：显示应用启动过程中各个阶段的时间消耗，包括Main函数之前的加载时间、Main函数之后的初始化时间、UI显示时间等。通过查看这些时间消耗，你可以找出启动时间过长的阶段，进行针对性的优化。例如，如果发现Main函数之前的加载时间过长，可能需要检查Mach - O文件的大小和动态库的加载情况。 启动时间趋势图：展示多次启动应用的时间变化趋势。如果启动时间逐渐变长，可能说明应用在启动过程中存在一些性能问题，需要进一步排查。 九、App瘦身9.1 资源文件优化 图片优化：使用合适的图片格式（如WebP），并对图片进行压缩处理，减少图片的大小。 移除无用资源：通过工具（如LSUnusedResources）找出项目中未使用的资源文件，并将其移除。 9.2 代码优化 移除无用代码：使用工具（如AppCode的Code Cleanup功能）找出项目中未使用的代码，并将其移除。 减少第三方库的使用：只引入必要的第三方库，并对第三方库进行评估，选择体积较小的库。 9.3 性能监测操作步骤 在Xcode中，选择Product -&gt; Archive，对应用进行归档。 归档完成后，在Archives窗口中选择对应的归档文件。 点击Distribute App按钮，选择App Thinning Size Report。 选择要分析的设备和配置，点击Next。 Xcode会生成App在不同设备和配置下的大小报告。 预期显示结果 App大小报告：显示App在不同设备和配置下的安装包大小、下载大小等信息。你可以对比优化前后的报告，查看App瘦身的效果。同时，报告中还会列出各个资源文件和代码模块的大小，帮助你找出占用空间较大的部分，进行针对性的优化。例如，如果发现某个图片资源占用空间过大，可以对其进行压缩或更换格式。 十、总结iOS应用的性能优化是一个综合性的工作，需要从CPU、内存、磁盘I&#x2F;O、网络、渲染、耗电、App卡顿、App启动、App瘦身等多个角度进行考虑。通过合理选择算法和数据结构、避免内存泄漏、优化磁盘I&#x2F;O和网络请求、简化视图层级、减少不必要的后台任务等方法，可以显著提升应用的性能。同时，使用Instruments等工具进行性能分析和调试也是非常重要的，它可以帮助我们找出性能瓶颈并进行针对性的优化。希望本文介绍的性能优化方案能够对你在iOS开发中的性能优化工作有所帮助。 参考资料： Apple Developer Documentation WWDC Sessions on Performance Optimization Advanced iOS Performance Tuning","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - 内存管理","path":"/iOS/OC底层原理/探索Objective - C底层 - 内存管理/","content":"引言在iOS开发中，内存管理是至关重要的一环。合理的内存管理能够提升应用的性能和稳定性，避免内存泄漏和崩溃等问题。本文将深入探索Objective - C底层的内存管理机制，涵盖Mach - O文件、TaggedPointer、对象的内存管理、copy、引用计数、weak指针、autorelease等关键知识点，并结合底层实现逻辑、底层代码和底层结构进行详细说明。 一、Mach - O文件1.1 概念Mach - O（Mach Object）是一种用于可执行文件、目标代码、动态库等的文件格式，它是macOS和iOS系统上的标准二进制文件格式。Mach - O文件包含了程序的代码、数据、符号表等信息，操作系统通过解析Mach - O文件来加载和执行程序。 1.2 组成部分1.2.1 HeaderHeader 包含了文件的基本信息，如文件类型（可执行文件、动态库等）、CPU 架构等。在底层，Header 是一个结构体，不同的 CPU 架构可能有不同的 Header 结构体定义。以下是一个简化的 64 位 Header 结构体示例： 12345678910struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; 1.2.2 Load CommandsLoad Commands 描述了如何加载文件内容到内存中，包括代码段、数据段的加载位置等信息。Load Commands 也是以结构体的形式存在，每个 Load Command 有一个固定的头部，包含命令类型和命令长度等信息。以下是一个简化的 Load Command 头部结构体示例： 1234struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 1.2.3 SectionsSections 是实际的代码和数据部分，如 .text 段存放程序的代码，.data 段存放已初始化的全局变量和静态变量，.bss 段存放未初始化的全局变量和静态变量。每个 Section 也有一个对应的结构体来描述其属性，以下是一个简化的 Section 结构体示例： 1234567891011121314struct section_64 &#123; char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes) */ uint32_t reserved1; /* reserved */ uint32_t reserved2; /* reserved */ uint32_t reserved3; /* reserved */&#125;; 1.3 示例可以使用 otool 命令查看 Mach - O 文件的信息： 1otool -h /path/to/your/app 上述命令将显示指定应用的 Mach - O 文件的头部信息。 二、TaggedPointer2.1 背景在 64 位系统下，如果继续使用传统的指针来存储小对象（如 NSNumber、NSDate 等），会造成内存的浪费。因为指针本身需要 8 个字节的存储空间，而小对象实际所需的存储空间可能远小于 8 个字节。为了解决这个问题，苹果引入了 TaggedPointer 技术。 2.2 原理TaggedPointer 并不是真正的指针，而是将数据直接存储在指针的值中。它通过在指针的最高位或其他特定位置设置标记位来表明这是一个 TaggedPointer，从而可以快速判断并直接从指针中提取数据，而无需进行额外的内存访问。 在底层，TaggedPointer 的实现依赖于指针的位操作。例如，对于一个存储整数的 TaggedPointer，可能会将整数的值直接编码在指针的低几位，而高几位用于存储标记信息。以下是一个简化的示例代码，展示如何判断一个指针是否为 TaggedPointer： 123BOOL isTaggedPointer(id pointer) &#123; return ((uintptr_t)pointer &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;&#125; 其中，_OBJC_TAG_MASK 是一个预定义的掩码，用于提取标记位。 2.3 示例1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSNumber *number1 = @1; NSNumber *number2 = @1000; // 判断是否为TaggedPointer if (isTaggedPointer((__bridge_retained void *)number1)) &#123; NSLog(@&quot;number1 is a TaggedPointer&quot;); &#125; if (isTaggedPointer((__bridge_retained void *)number2)) &#123; NSLog(@&quot;number2 is a TaggedPointer&quot;); &#125; &#125; return 0;&#125; 三、对象的内存管理3.1 手动引用计数（MRC）在早期的 Objective - C 开发中，使用手动引用计数（MRC）来管理对象的内存。开发者需要手动调用 retain、release 和 autorelease 方法来增加和减少对象的引用计数。 在底层，每个对象都有一个引用计数表，用于记录对象的引用计数。当调用 retain 方法时，引用计数加 1；当调用 release 方法时，引用计数减 1。以下是一个简化的 retain 和 release 方法的底层实现示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface MyObject : NSObject@end@implementation MyObject &#123; int _retainCount;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; _retainCount = 1; &#125; return self;&#125;- (instancetype)retain &#123; _retainCount++; return self;&#125;- (void)release &#123; _retainCount--; if (_retainCount == 0) &#123; [self dealloc]; &#125;&#125;- (void)dealloc &#123; NSLog(@&quot;MyObject deallocated&quot;); [super dealloc];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject *obj = [[MyObject alloc] init]; // 引用计数为 1 [obj retain]; // 引用计数为 2 [obj release]; // 引用计数为 1 [obj release]; // 引用计数为 0，对象被释放 &#125; return 0;&#125; 3.2 自动引用计数（ARC）为了简化内存管理，苹果引入了自动引用计数（ARC）。在 ARC 模式下，编译器会自动插入 retain、release 和 autorelease 调用，开发者无需手动管理对象的引用计数。 在底层，ARC 依赖于编译器的静态分析和代码插桩技术。编译器会在合适的位置插入 retain 和 release 调用，以确保对象的引用计数正确。例如，在一个方法返回一个对象时，编译器会自动插入 retain 调用，以保证对象在返回后仍然有效；在对象超出作用域时，编译器会自动插入 release 调用，以释放对象的内存。 四、copy4.1 概念在 Objective - C 中，copy 方法用于创建对象的副本。根据对象是否遵循 NSCopying 协议，copy 方法的行为有所不同。 4.2 浅拷贝和深拷贝 浅拷贝：只复制对象本身，而不复制对象所引用的内容。新对象和原对象共享相同的内容。 深拷贝：不仅复制对象本身，还复制对象所引用的内容。新对象和原对象拥有各自独立的内容。 4.3 底层实现要实现 copy 功能，对象需要遵循 NSCopying 协议，并实现 copyWithZone: 方法。以下是一个示例代码，展示了如何实现 copyWithZone: 方法： 12345678910111213141516171819202122232425262728#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject &lt;NSCopying&gt;@property (nonatomic, strong) NSArray *array;@end@implementation MyClass- (id)copyWithZone:(NSZone *)zone &#123; MyClass *copy = [[[self class] allocWithZone:zone] init]; copy.array = [self.array copy]; // 这里的 copy 是浅拷贝 return copy;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *original = [[MyClass alloc] init]; original.array = @[@1, @2, @3]; MyClass *copy = [original copy]; NSLog(@&quot;Original array: %@&quot;, original.array); NSLog(@&quot;Copy array: %@&quot;, copy.array); &#125; return 0;&#125; 在底层，copyWithZone: 方法的实现通常涉及到对象的属性复制。对于基本数据类型的属性，可以直接复制；对于对象类型的属性，需要根据具体需求进行浅拷贝或深拷贝。 五、引用计数5.1 底层结构在Objective - C中，对象的引用计数管理有不同的实现方式，这取决于对象的类型和系统的优化策略。 5.1.1 散列表（SideTables）在64位系统中，为了避免多个线程同时操作同一个对象的引用计数时产生数据竞争问题，Objective - C使用了多个散列表（SideTables）来存储对象的引用计数。散列表本质上是一个全局的哈希表数组，每个散列表都有自己的锁，这样不同的对象可以在不同的散列表中操作，减少锁竞争。 1234567891011// 简化的SideTables结构示意static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; static StripedMap&lt;SideTable&gt; tables; return tables;&#125;struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table;&#125;; spinlock_t slock：用于保护散列表的自旋锁，确保同一时间只有一个线程可以访问该散列表。 RefcountMap refcnts：一个哈希表，用于存储对象的引用计数。键是对象的指针，值是对象的引用计数。 weak_table_t weak_table：用于管理对象的弱引用，后续在weak指针部分会详细介绍。 5.1.2 引用计数的存储对象的引用计数存储在RefcountMap中，它是一个std::unordered_map类型的哈希表。在实际存储时，引用计数并不是简单的整数值，而是采用了位域的方式，将不同的信息存储在不同的位上。例如，除了引用计数本身，还会存储一些标记位，如是否正在析构、是否使用了弱引用等。 5.2 底层原理5.2.1 retain操作当调用对象的retain方法时，底层会进行以下操作： 根据对象的地址找到对应的散列表。 加锁，确保线程安全。 在RefcountMap中查找该对象的引用计数。 如果找到了，将引用计数加1；如果没找到，说明该对象是第一次被引用，将引用计数初始化为1。 解锁。 12345678910111213141516171819202122232425262728293031323334id objc_object::retain() &#123; assert(!isTaggedPointer()); return rootRetain();&#125;id objc_object::rootRetain() &#123; if (isTaggedPointer()) return (id)this; bool sideTableLocked = false; bool transcribeToSideTable = false; isa_t oldisa; isa_t newisa; do &#123; transcribeToSideTable = false; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; if (slowpath(!newisa.nonpointer)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) &#123; sidetable_unlock(); &#125; return sidetable_retain(); &#125; // ... 其他逻辑 newisa.retain(); &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); if (slowpath(transcribeToSideTable)) &#123; sidetable_addExtraRC_nolock(RC_ONE); &#125; if (slowpath(sideTableLocked)) sidetable_unlock(); return (id)this;&#125; 5.2.2 release操作当调用对象的release方法时，底层会进行以下操作： 根据对象的地址找到对应的散列表。 加锁，确保线程安全。 在RefcountMap中查找该对象的引用计数。 如果找到了，将引用计数减1；如果引用计数减为0，调用对象的dealloc方法释放对象。 解锁。 123456789101112131415161718192021222324252627282930void objc_object::release() &#123; assert(!isTaggedPointer()); rootRelease();&#125;bool objc_object::rootRelease() &#123; if (isTaggedPointer()) return false; bool sideTableLocked = false; isa_t oldisa; isa_t newisa; do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; if (slowpath(!newisa.nonpointer)) &#123; ClearExclusive(&amp;isa.bits); if (sideTableLocked) &#123; sidetable_unlock(); &#125; return sidetable_release(true); &#125; // ... 其他逻辑 uintptr_t carry; newisa.release(&amp;carry); // ... 其他逻辑 &#125; while (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits))); if (slowpath(sideTableLocked)) sidetable_unlock(); return true;&#125; 六、weak指针6.1 底层结构6.1.1 弱引用表（weak_table_t）弱引用表是一个全局的哈希表，用于存储对象的弱引用信息。它存储在每个散列表（SideTable）中。 123456struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;&#125;; weak_entry_t *weak_entries：一个数组，存储所有的弱引用条目。 size_t num_entries：当前弱引用条目的数量。 uintptr_t mask：用于哈希计算的掩码。 uintptr_t max_hash_displacement：最大哈希冲突位移量。 6.1.2 弱引用条目（weak_entry_t）每个弱引用条目对应一个对象，存储了所有指向该对象的弱引用指针。 1234567891011121314151617181920struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;; bool out_of_line() &#123; return (out_of_line_ness == REFERRERS_OUT_OF_LINE); &#125; weak_entry_t&amp; operator=(const weak_entry_t&amp; other);&#125;; DisguisedPtr&lt;objc_object&gt; referent：被引用的对象。 weak_referrer_t *referrers：指向弱引用指针的数组。 uintptr_t num_refs：当前弱引用指针的数量。 6.2 底层原理6.2.1 弱引用的创建当创建一个weak指针时，底层会进行以下操作： 根据对象的地址找到对应的散列表。 在弱引用表中查找该对象的弱引用条目。 如果找到了，将weak指针添加到该条目的弱引用指针数组中；如果没找到，创建一个新的弱引用条目，并将weak指针添加到其中。 12345678id objc_initWeak(id *location, id newObj) &#123; if (!newObj) &#123; *location = nil; return nil; &#125; return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);&#125; 6.2.2 弱引用的清理当对象被释放时，底层会进行以下操作： 根据对象的地址找到对应的散列表。 在弱引用表中查找该对象的弱引用条目。 如果找到了，遍历该条目的弱引用指针数组，将所有的弱引用指针置为nil。 从弱引用表中移除该对象的弱引用条目。 123456789101112131415161718192021222324252627void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; return; &#125; // 清除所有弱引用指针 weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line()) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; &#125; &#125; // 移除弱引用条目 weak_entry_remove(weak_table, entry);&#125; 七、autorelease7.1 底层结构7.1.1 自动释放池页（AutoreleasePoolPage）自动释放池是由一系列的自动释放池页（AutoreleasePoolPage）组成的，这些页以双向链表的形式连接起来。每个自动释放池页是一个栈结构，用于存储自动释放的对象。 1234567891011121314151617181920212223242526272829class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;public: static size_t const SIZE = #if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_SIZE; // size and alignment, power of 2#endif explicit AutoreleasePoolPage(AutoreleasePoolPage *newParent) : magic(), next(begin()), thread(pthread_self()), parent(newParent), child(nil), depth(parent ? 1+parent-&gt;depth : 0), hiwat(parent ? parent-&gt;hiwat : 0) &#123; if (parent) &#123; parent-&gt;check(); assert(!parent-&gt;child); parent-&gt;child = this; &#125; &#125; // ... 其他方法&#125;; magic_t const magic：用于验证自动释放池页的有效性。 id *next：指向栈顶的指针，用于记录下一个可存储对象的位置。 pthread_t const thread：当前线程的ID，确保每个线程有自己独立的自动释放池。 AutoreleasePoolPage * const parent：指向前一个自动释放池页的指针。 AutoreleasePoolPage *child：指向后一个自动释放池页的指针。 7.2 底层原理7.2.1 autorelease操作当调用对象的autorelease方法时，底层会进行以下操作： 获取当前线程的自动释放池页。 如果当前页还有空间，将对象压入栈中；如果当前页已满，创建一个新的自动释放池页，并将对象压入新页的栈中。 12345678910111213141516171819202122232425262728293031323334id objc_object::autorelease() &#123; assert(!isTaggedPointer()); return rootAutorelease();&#125;id objc_object::rootAutorelease() &#123; if (isTaggedPointer()) return (id)this; if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this; return rootAutorelease2();&#125;id objc_object::rootAutorelease2() &#123; assert(!isTaggedPointer()); return AutoreleasePoolPage::autorelease((objc_object *)this);&#125;static inline id autorelease(id obj) &#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); assert(!dest || dest == EMPTY_POOL_PLACEHOLDER || *dest == obj); return obj;&#125;static inline id *autoreleaseFast(id obj) &#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 7.2.2 自动释放池的销毁当自动释放池被销毁时，底层会进行以下操作： 从当前自动释放池页的栈顶开始，依次弹出对象并调用它们的release方法。 如果当前页的所有对象都被释放，且有父页，将当前页销毁，并继续处理父页。 1234567891011121314151617181920212223242526272829303132333435363738void AutoreleasePoolPage::pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; // 处理空池占位符 page = hotPage(); if (!page) &#123; // 没有自动释放池页，直接返回 return setHotPage(nil); &#125; // 找到最老的页 while (page-&gt;parent) &#123; page = page-&gt;parent; &#125; page-&gt;fastPop(page-&gt;begin()); return; &#125; page = pageForPointer(token); stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // 单个页的情况 &#125; else &#123; // 错误处理 return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;fastPop(stop); // 释放多余的页 if (page-&gt;child) &#123; if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 八、总结Objective - C 的内存管理机制是一个复杂而重要的主题。通过深入理解 Mach - O 文件、TaggedPointer、对象的内存管理、copy、引用计数、weak 指针和 autorelease 等知识点，以及它们的底层实现逻辑、底层代码和底层结构，开发者可以更好地掌握内存管理的技巧，编写出高效、稳定的 iOS 应用。同时，合理使用 ARC 和相关的内存管理技术，可以避免常见的内存问题，提升应用的性能和用户体验。 参考资料： Apple Developer Documentation Advanced Memory Management Programming Guide objc4 开源代码","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - 多线程技术","path":"/iOS/OC底层原理/探索Objective - C底层 - 多线程技术/","content":"引言在iOS开发中，多线程技术是提升应用性能与响应能力的关键。它能让应用在同一时间处理多个任务，避免主线程阻塞，为用户带来流畅的体验。本文将深入探讨Objective - C底层的多线程技术，涵盖原子锁atomic、GCD Timer、NSTimer、CADisplayLink等知识点，并结合示例代码进行详细说明。同时，会着重分析NSTimer和CADisplayLink可能造成的循环引用问题以及相应的解决办法。 一、原子锁 atomic1.1 原理在Objective - C中，atomic 是属性声明时的一个修饰符。当一个属性被声明为 atomic 时，编译器会自动生成一些额外的代码来保证该属性的 setter 和 getter 方法是原子操作。也就是说，在多线程环境下，同一时间只会有一个线程对该属性进行读写操作，从而避免数据竞争。 1.2 使用示例123456789101112131415161718192021222324252627282930313233#import &lt;Foundation/Foundation.h&gt;@interface AtomicExample : NSObject@property (atomic, assign) NSInteger counter;@end@implementation AtomicExample@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; AtomicExample *example = [[AtomicExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; example.counter++; &#125; &#125;); dispatch_async(queue, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; example.counter++; &#125; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 1.3 优缺点 优点：使用方便，只需要在属性声明时添加 atomic 修饰符，编译器会自动处理线程安全问题。 缺点：atomic 只能保证属性的 setter 和 getter 方法是原子操作，但不能保证整个操作的原子性。例如，对于 self.counter++ 操作，它包含了读取、加一和写入三个步骤，atomic 无法保证这三个步骤的原子性。而且，atomic 会带来一定的性能开销，因为它需要进行额外的锁操作。 二、GCD Timer2.1 原理GCD Timer 是基于 Grand Central Dispatch（GCD）实现的定时器。GCD 是苹果提供的一套多线程编程解决方案，它将任务封装成块（block）并放入队列中执行。GCD Timer 利用 GCD 的特性，在指定的时间间隔内重复执行任务。 2.2 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;@interface GCDTimerExample : NSObject@property (nonatomic, strong) dispatch_source_t timer;@end@implementation GCDTimerExample- (void)startTimer &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 设置定时器的开始时间、间隔和精度 dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)); uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC); dispatch_source_set_timer(self.timer, start, interval, 0); // 设置定时器的回调函数 __weak typeof(self) weakSelf = self; dispatch_source_set_event_handler(self.timer, ^&#123; [weakSelf timerFired]; &#125;); // 启动定时器 dispatch_resume(self.timer);&#125;- (void)timerFired &#123; NSLog(@&quot;GCD Timer fired&quot;);&#125;- (void)stopTimer &#123; if (self.timer) &#123; dispatch_source_cancel(self.timer); self.timer = nil; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; GCDTimerExample *example = [[GCDTimerExample alloc] init]; [example startTimer]; sleep(5); [example stopTimer]; &#125; return 0;&#125; 2.3 优缺点 优点：精度高，不会受到 RunLoop 的影响；可以在后台线程执行任务，不影响主线程的响应；可以通过 dispatch_source_set_timer 方法灵活设置定时器的开始时间、间隔和精度。 缺点：使用相对复杂，需要手动管理定时器的创建、启动和停止。 三、NSTimer3.1 原理NSTimer 是基于 RunLoop 实现的定时器。RunLoop 是一个事件循环机制，负责处理各种事件，如触摸事件、定时器事件等。当创建一个 NSTimer 并将其添加到 RunLoop 中时，RunLoop 会在指定的时间间隔内触发定时器事件。 3.2 使用示例12345678910111213141516171819202122232425262728293031323334353637383940#import &lt;Foundation/Foundation.h&gt;@interface NSTimerExample : NSObject@property (nonatomic, strong) NSTimer *timer;@end@implementation NSTimerExample- (void)startTimer &#123; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerFired) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;- (void)timerFired &#123; NSLog(@&quot;NSTimer fired&quot;);&#125;- (void)stopTimer &#123; if (self.timer) &#123; [self.timer invalidate]; self.timer = nil; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSTimerExample *example = [[NSTimerExample alloc] init]; [example startTimer]; sleep(5); [example stopTimer]; &#125; return 0;&#125; 3.3 循环引用问题在上述示例中，NSTimer 的 target 是 self，这会导致循环引用问题。NSTimer 会强引用 target，而 target 又持有 NSTimer 的引用，当 target 所在的对象需要被释放时，由于 NSTimer 对其的强引用，对象无法被释放，从而造成内存泄漏。 3.4 解决办法3.4.1 使用中间对象（NSProxy）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import &lt;Foundation/Foundation.h&gt;@interface WeakProxy : NSProxy@property (nonatomic, weak, readonly) id target;- (instancetype)initWithTarget:(id)target;+ (instancetype)proxyWithTarget:(id)target;@end@implementation WeakProxy- (instancetype)initWithTarget:(id)target &#123; _target = target; return self;&#125;+ (instancetype)proxyWithTarget:(id)target &#123; return [[WeakProxy alloc] initWithTarget:target];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; return [self.target methodSignatureForSelector:sel];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end@interface NSTimerProxyExample : NSObject@property (nonatomic, strong) NSTimer *timer;@end@implementation NSTimerProxyExample- (void)startTimer &#123; WeakProxy *proxy = [WeakProxy proxyWithTarget:self]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:proxy selector:@selector(timerFired) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;- (void)timerFired &#123; NSLog(@&quot;NSTimer fired&quot;);&#125;- (void)stopTimer &#123; if (self.timer) &#123; [self.timer invalidate]; self.timer = nil; &#125;&#125;@end 使用 NSProxy 作为中间对象，NSTimer 强引用 NSProxy，而 NSProxy 弱引用 target，避免了循环引用。 3.4.2 在合适的时机手动停止定时器在 target 即将被释放时，手动调用 invalidate 方法停止定时器，打破循环引用。 1234- (void)dealloc &#123; [self.timer invalidate]; self.timer = nil;&#125; 3.5 优缺点 优点：使用简单，只需要创建一个 NSTimer 并将其添加到 RunLoop 中即可；可以方便地设置定时器的时间间隔、是否重复等属性。 缺点：精度相对较低，因为它依赖于 RunLoop 的运行状态。如果 RunLoop 被阻塞，定时器可能会延迟触发；只能在主线程或指定的 RunLoop 中运行；容易造成循环引用问题。 四、CADisplayLink4.1 原理CADisplayLink 是一个与屏幕刷新率同步的定时器，它会在每次屏幕刷新时触发一次回调。CADisplayLink 通常用于实现动画效果，因为它可以保证动画的流畅性。 4.2 使用示例12345678910111213141516171819202122232425262728293031323334353637#import &lt;Foundation/Foundation.h&gt;#import &lt;QuartzCore/QuartzCore.h&gt;@interface CADisplayLinkExample : NSObject@property (nonatomic, strong) CADisplayLink *displayLink;@end@implementation CADisplayLinkExample- (void)startDisplayLink &#123; self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkFired)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)displayLinkFired &#123; NSLog(@&quot;CADisplayLink fired&quot;);&#125;- (void)stopDisplayLink &#123; if (self.displayLink) &#123; [self.displayLink invalidate]; self.displayLink = nil; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; CADisplayLinkExample *example = [[CADisplayLinkExample alloc] init]; [example startDisplayLink]; sleep(5); [example stopDisplayLink]; &#125; return 0;&#125; 4.3 循环引用问题与 NSTimer 类似，CADisplayLink 的 target 强引用 self，而 self 又持有 CADisplayLink 的引用，会造成循环引用，导致 self 无法被释放，造成内存泄漏。 4.4 解决办法4.4.1 使用中间对象（NSProxy）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &lt;Foundation/Foundation.h&gt;#import &lt;QuartzCore/QuartzCore.h&gt;@interface WeakProxy : NSProxy@property (nonatomic, weak, readonly) id target;- (instancetype)initWithTarget:(id)target;+ (instancetype)proxyWithTarget:(id)target;@end@implementation WeakProxy- (instancetype)initWithTarget:(id)target &#123; _target = target; return self;&#125;+ (instancetype)proxyWithTarget:(id)target &#123; return [[WeakProxy alloc] initWithTarget:target];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; return [self.target methodSignatureForSelector:sel];&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [invocation invokeWithTarget:self.target];&#125;@end@interface CADisplayLinkProxyExample : NSObject@property (nonatomic, strong) CADisplayLink *displayLink;@end@implementation CADisplayLinkProxyExample- (void)startDisplayLink &#123; WeakProxy *proxy = [WeakProxy proxyWithTarget:self]; self.displayLink = [CADisplayLink displayLinkWithTarget:proxy selector:@selector(displayLinkFired)]; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)displayLinkFired &#123; NSLog(@&quot;CADisplayLink fired&quot;);&#125;- (void)stopDisplayLink &#123; if (self.displayLink) &#123; [self.displayLink invalidate]; self.displayLink = nil; &#125;&#125;@end 利用 NSProxy 作为中间层，避免了 CADisplayLink 与 target 的循环引用。 4.4.2 在合适的时机手动停止定时器在 target 即将被释放时，手动调用 invalidate 方法停止 CADisplayLink，打破循环引用。 1234- (void)dealloc &#123; [self.displayLink invalidate]; self.displayLink = nil;&#125; 4.5 优缺点 优点：与屏幕刷新率同步，能够实现流畅的动画效果；可以精确控制动画的帧率。 缺点：只能用于实现与屏幕刷新相关的任务，如动画；如果处理任务的时间过长，可能会导致屏幕卡顿；容易造成循环引用问题。 五、不同多线程技术的比较与选择5.1 性能比较 GCD Timer：性能较高，因为它基于 GCD 实现，不依赖于 RunLoop，能够在后台线程高效执行任务。 NSTimer：性能相对较低，因为它依赖于 RunLoop，当 RunLoop 被阻塞时，定时器的精度会受到影响。 CADisplayLink：性能与屏幕刷新率相关，如果处理任务的时间过长，会影响屏幕的流畅性。 5.2 适用场景 **原子锁 atomic**：适用于简单的属性读写操作，需要保证属性的线程安全。 GCD Timer：适用于需要高精度定时任务的场景，如后台定时数据更新、定时任务执行等。 NSTimer：适用于对精度要求不高的定时任务，如简单的倒计时、定时提醒等。 CADisplayLink：适用于实现动画效果，如 UI 动画、游戏动画等。 六、总结在Objective - C开发中，掌握多线程技术是提升应用性能和用户体验的关键。原子锁 atomic、GCD Timer、NSTimer 和 CADisplayLink 各有优缺点，适用于不同的场景。同时，NSTimer 和 CADisplayLink 容易造成循环引用问题，开发者需要采取相应的解决办法。希望本文能帮助你深入理解Objective - C底层的多线程技术，在实际开发中灵活运用。 参考资料： Apple Developer Documentation Objective - C Programming: The Big Nerd Ranch Guide","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - 线程锁","path":"/iOS/OC底层原理/探索Objective - C底层 - 线程锁/","content":"引言在iOS开发里，多线程编程能显著提升应用性能和响应能力。不过，多线程环境下对共享资源的并发访问容易引发数据竞争和不一致问题。线程锁作为保障线程安全的关键工具，能有效避免这些问题。本文会深入探讨Objective - C中各种线程锁的底层原理、使用方法和适用场景，还会介绍信号量和串行队列实现线程同步的方法，同时给出示例代码辅助理解。 一、线程安全问题概述多线程编程时，多个线程同时访问和修改共享资源，就可能出现数据竞争。例如，多个线程同时对一个变量进行自增操作，可能会导致最终结果与预期不符。下面是一个简单的示例： 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;@interface ThreadSafeExample : NSObject@property (nonatomic, assign) NSInteger counter;@end@implementation ThreadSafeExample- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; self.counter++; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; ThreadSafeExample *example = [[ThreadSafeExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 上述代码中，两个线程同时对 counter 变量进行自增操作，由于自增操作不是原子操作，可能会出现数据竞争，导致最终结果小于预期的 20000。 二、常见的线程锁2.1 @synchronized2.1.1 原理@synchronized 是一种简单易用的互斥锁，它基于对象实现。当一个线程进入 @synchronized 代码块时，会尝试获取该对象的锁，如果锁已被其他线程持有，该线程会被阻塞，直到锁被释放。 2.1.2 使用示例12345678910111213141516171819202122232425262728293031323334353637#import &lt;Foundation/Foundation.h&gt;@interface SynchronizedExample : NSObject@property (nonatomic, assign) NSInteger counter;@end@implementation SynchronizedExample- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; @synchronized(self) &#123; self.counter++; &#125; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; SynchronizedExample *example = [[SynchronizedExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 2.1.3 优缺点 优点：使用简单，无需手动管理锁的生命周期。 缺点：性能相对较低，因为每次进入和退出代码块都有额外的开销；而且只能用于Objective - C对象。 2.2 NSLock2.2.1 原理NSLock 是 NSLocking 协议的具体实现，它是一个互斥锁。通过 lock 方法获取锁，unlock 方法释放锁。 2.2.2 使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;Foundation/Foundation.h&gt;@interface NSLockExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, strong) NSLock *lock;@end@implementation NSLockExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.lock = [[NSLock alloc] init]; &#125; return self;&#125;- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; [self.lock lock]; self.counter++; [self.lock unlock]; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLockExample *example = [[NSLockExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 2.2.3 优缺点 优点：使用方便，性能比 @synchronized 略高。 缺点：需要手动管理锁的获取和释放，若忘记释放锁会导致死锁。 2.3 NSRecursiveLock2.3.1 原理NSRecursiveLock 是一种递归锁，允许同一个线程多次获取该锁而不会产生死锁。当线程第一次获取锁时，锁的计数加 1，之后该线程再次获取锁，计数继续增加，只有当计数减为 0 时，锁才会被真正释放。 2.3.2 使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243#import &lt;Foundation/Foundation.h&gt;@interface NSRecursiveLockExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, strong) NSRecursiveLock *recursiveLock;@end@implementation NSRecursiveLockExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.recursiveLock = [[NSRecursiveLock alloc] init]; &#125; return self;&#125;- (void)recursiveFunction &#123; [self.recursiveLock lock]; self.counter++; if (self.counter &lt; 10) &#123; [self recursiveFunction]; &#125; [self.recursiveLock unlock];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSRecursiveLockExample *example = [[NSRecursiveLockExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example recursiveFunction]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 2.3.3 优缺点 优点：适用于递归调用的场景，避免死锁。 缺点：同样需要手动管理锁的获取和释放，使用不当也可能导致问题。 2.4 NSCondition2.4.1 原理NSCondition 是一种条件锁，它结合了锁和条件变量的功能。线程可以在满足特定条件时等待，当条件满足时被唤醒。 2.4.2 使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#import &lt;Foundation/Foundation.h&gt;@interface NSConditionExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, strong) NSCondition *condition;@end@implementation NSConditionExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.condition = [[NSCondition alloc] init]; self.counter = 0; &#125; return self;&#125;- (void)producer &#123; for (int i = 0; i &lt; 10; i++) &#123; [self.condition lock]; while (self.counter &gt;= 5) &#123; [self.condition wait]; &#125; self.counter++; NSLog(@&quot;Produced: %ld&quot;, (long)self.counter); [self.condition signal]; [self.condition unlock]; &#125;&#125;- (void)consumer &#123; for (int i = 0; i &lt; 10; i++) &#123; [self.condition lock]; while (self.counter &lt;= 0) &#123; [self.condition wait]; &#125; self.counter--; NSLog(@&quot;Consumed: %ld&quot;, (long)self.counter); [self.condition signal]; [self.condition unlock]; &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSConditionExample *example = [[NSConditionExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example producer]; &#125;); dispatch_async(queue, ^&#123; [example consumer]; &#125;); sleep(5); &#125; return 0;&#125; 2.4.3 优缺点 优点：可以实现复杂的线程同步，如生产者 - 消费者模型。 缺点：使用相对复杂，需要仔细管理条件和锁。 2.5 NSConditionLock2.5.1 原理NSConditionLock 是基于 NSCondition 实现的条件锁，它允许线程在特定条件下获取锁。线程可以指定一个条件值，只有当锁的当前条件值与指定的条件值匹配时，线程才能获取锁。 2.5.2 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;@interface NSConditionLockExample : NSObject@property (nonatomic, strong) NSConditionLock *conditionLock;@end@implementation NSConditionLockExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.conditionLock = [[NSConditionLock alloc] initWithCondition:0]; &#125; return self;&#125;- (void)thread1 &#123; [self.conditionLock lockWhenCondition:0]; NSLog(@&quot;Thread 1: Condition 0 met&quot;); [self.conditionLock unlockWithCondition:1];&#125;- (void)thread2 &#123; [self.conditionLock lockWhenCondition:1]; NSLog(@&quot;Thread 2: Condition 1 met&quot;); [self.conditionLock unlockWithCondition:0];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSConditionLockExample *example = [[NSConditionLockExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example thread1]; &#125;); dispatch_async(queue, ^&#123; [example thread2]; &#125;); sleep(2); &#125; return 0;&#125; 2.5.3 优缺点 优点：可以根据不同的条件进行线程同步，提供更灵活的控制。 缺点：使用场景相对较窄，需要合理设计条件值。 2.6 pthread_mutex_t2.6.1 原理pthread_mutex_t 是基于 POSIX 线程库的互斥锁，是一种底层的锁机制。它的性能较高，适用于对性能要求较高的场景。 2.6.2 使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import &lt;Foundation/Foundation.h&gt;#import &lt;pthread.h&gt;@interface PthreadMutexExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, assign) pthread_mutex_t mutex;@end@implementation PthreadMutexExample- (instancetype)init &#123; self = [super init]; if (self) &#123; pthread_mutex_init(&amp;_mutex, NULL); self.counter = 0; &#125; return self;&#125;- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; pthread_mutex_lock(&amp;_mutex); self.counter++; pthread_mutex_unlock(&amp;_mutex); &#125;&#125;- (void)dealloc &#123; pthread_mutex_destroy(&amp;_mutex);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; PthreadMutexExample *example = [[PthreadMutexExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 2.6.3 优缺点 优点：性能高，可定制性强。 缺点：使用相对复杂，需要手动管理锁的初始化和销毁。 2.7 OSSpinLock（已弃用）2.7.1 原理OSSpinLock 是一种自旋锁，线程在获取锁时会不断尝试，直到获取到锁为止。自旋锁适用于锁持有时间较短的场景。 2.7.2 使用示例（仅作历史参考）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;#import &lt;libkern/OSAtomic.h&gt;@interface OSSpinLockExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, assign) OSSpinLock spinLock;@end@implementation OSSpinLockExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.spinLock = OS_SPINLOCK_INIT; self.counter = 0; &#125; return self;&#125;- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; OSSpinLockLock(&amp;_spinLock); self.counter++; OSSpinLockUnlock(&amp;_spinLock); &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; OSSpinLockExample *example = [[OSSpinLockExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 2.7.3 优缺点及弃用原因 优点：性能高，适用于锁持有时间短的场景。 缺点：存在优先级反转问题，可能导致低优先级线程长时间持有锁，影响系统性能。因此，苹果已弃用该锁。 2.8 os_unfair_lock2.8.1 原理os_unfair_lock 是苹果为替代 OSSpinLock 引入的锁机制，它是一种互斥锁，当线程无法获取锁时会进入休眠状态，避免了自旋锁的优先级反转问题。 2.8.2 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;#import &lt;os/lock.h&gt;@interface OSUnfairLockExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, assign) os_unfair_lock unfairLock;@end@implementation OSUnfairLockExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.unfairLock = OS_UNFAIR_LOCK_INIT; self.counter = 0; &#125; return self;&#125;- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; os_unfair_lock_lock(&amp;_unfairLock); self.counter++; os_unfair_lock_unlock(&amp;_unfairLock); &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; OSUnfairLockExample *example = [[OSUnfairLockExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 2.8.3 优缺点 优点：解决了优先级反转问题，性能也比较高。 缺点：使用相对底层，需要对锁的操作有一定了解。 三、信号量实现线程同步3.1 原理信号量是一种更高级的同步机制，它可以控制同时访问某个资源的线程数量。信号量有一个初始值，线程在访问资源前需要先请求信号量，如果信号量的值大于 0，则线程可以继续执行，同时信号量的值减 1；如果信号量的值为 0，则线程需要等待，直到有其他线程释放信号量。 3.2 使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &lt;Foundation/Foundation.h&gt;@interface SemaphoreExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, strong) dispatch_semaphore_t semaphore;@end@implementation SemaphoreExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.counter = 0; // 初始化信号量，初始值为 1 表示只允许一个线程同时访问 self.semaphore = dispatch_semaphore_create(1); &#125; return self;&#125;- (void)incrementCounter &#123; for (int i = 0; i &lt; 10000; i++) &#123; // 请求信号量 dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER); self.counter++; // 释放信号量 dispatch_semaphore_signal(self.semaphore); &#125;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; SemaphoreExample *example = [[SemaphoreExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 3.3 优缺点 优点：可以灵活控制并发线程的数量，适用于需要限制资源访问数量的场景。 缺点：使用相对复杂，需要对信号量的操作有一定理解。 四、串行队列实现线程同步4.1 原理串行队列一次只能执行一个任务，当多个线程将任务提交到串行队列时，这些任务会按照提交的顺序依次执行，从而避免了多个线程同时访问共享资源的问题。 4.2 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;@interface SerialQueueExample : NSObject@property (nonatomic, assign) NSInteger counter;@property (nonatomic, strong) dispatch_queue_t serialQueue;@end@implementation SerialQueueExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.counter = 0; // 创建串行队列 self.serialQueue = dispatch_queue_create(&quot;com.example.serialQueue&quot;, DISPATCH_QUEUE_SERIAL); &#125; return self;&#125;- (void)incrementCounter &#123; dispatch_async(self.serialQueue, ^&#123; for (int i = 0; i &lt; 10000; i++) &#123; self.counter++; &#125; &#125;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; SerialQueueExample *example = [[SerialQueueExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); dispatch_async(queue, ^&#123; [example incrementCounter]; &#125;); sleep(2); NSLog(@&quot;Counter value: %ld&quot;, (long)example.counter); &#125; return 0;&#125; 4.3 优缺点 优点：使用简单，不需要手动管理锁的获取和释放。 缺点：性能相对较低，因为任务是串行执行的，不能充分利用多核 CPU 的优势。 五、线程锁的性能比较不同的线程锁在性能上有所差异，一般来说，底层的锁（如 pthread_mutex_t、os_unfair_lock）性能较高，而高层的锁（如 @synchronized、NSLock）使用方便但性能相对较低。信号量和串行队列在不同场景下也有各自的性能特点，需要根据具体需求选择合适的同步方式。 六、死锁问题及避免方法6.1 死锁的概念死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 6.2 死锁的示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &lt;Foundation/Foundation.h&gt;@interface DeadlockExample : NSObject@property (nonatomic, strong) NSLock *lock1;@property (nonatomic, strong) NSLock *lock2;@end@implementation DeadlockExample- (instancetype)init &#123; self = [super init]; if (self) &#123; self.lock1 = [[NSLock alloc] init]; self.lock2 = [[NSLock alloc] init]; &#125; return self;&#125;- (void)thread1 &#123; [self.lock1 lock]; NSLog(@&quot;Thread 1: Lock 1 acquired&quot;); sleep(1); [self.lock2 lock]; NSLog(@&quot;Thread 1: Lock 2 acquired&quot;); [self.lock2 unlock]; [self.lock1 unlock];&#125;- (void)thread2 &#123; [self.lock2 lock]; NSLog(@&quot;Thread 2: Lock 2 acquired&quot;); sleep(1); [self.lock1 lock]; NSLog(@&quot;Thread 2: Lock 1 acquired&quot;); [self.lock1 unlock]; [self.lock2 unlock];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; DeadlockExample *example = [[DeadlockExample alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_async(queue, ^&#123; [example thread1]; &#125;); dispatch_async(queue, ^&#123; [example thread2]; &#125;); sleep(5); &#125; return 0;&#125; 6.3 避免死锁的方法 按顺序加锁：所有线程都按照相同的顺序获取锁，避免循环等待。 使用超时机制：在获取锁时设置超时时间，若超时则放弃获取锁，避免无限等待。 减少锁的持有时间：尽量缩短锁的持有时间，减少死锁的可能性。 七、总结线程锁、信号量和串行队列在多线程编程中起着至关重要的作用，不同的同步机制有不同的特点和适用场景。在实际开发中，需要根据具体的需求选择合适的同步方式，并注意避免死锁等问题。希望本文能帮助你深入理解Objective - C中的线程同步机制，在开发中编写出更安全、高效的多线程代码。 参考资料： Apple Developer Documentation POSIX Threads Programming","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - GCD","path":"/iOS/OC底层原理/探索Objective - C底层 - GCD/","content":"引言在iOS开发领域，多线程编程是优化应用性能与响应能力的关键技术。而Grand Central Dispatch（GCD）作为苹果推出的强大且高效的多线程解决方案，以其卓越的性能和易用性，成为开发者处理多线程任务的首选。本文将深入剖析GCD的底层原理、核心概念、常用API及其丰富多样的应用场景，并结合大量示例代码进行详细阐述。 一、GCD 基础概念1.1 什么是 GCDGCD 是基于 C 语言的多线程技术，它对线程管理进行了高度抽象和封装。开发者无需手动处理线程的创建、销毁和调度等复杂操作，只需将任务封装成 Block 并提交到合适的队列中，GCD 会自动完成后续的线程管理工作，大大简化了多线程编程的复杂度。 1.2 任务与队列 任务：指的是要执行的具体工作，在 GCD 中使用 Block 来表示。Block 是一种闭包，可以捕获上下文变量，方便进行代码的封装和传递。 队列：是用于存放任务的容器，根据任务执行的方式不同，可分为串行队列和并发队列。 1.3 同步与异步执行 同步执行：任务会在当前线程中执行，并且会阻塞当前线程，直到任务执行完成后，才会继续执行后续的代码。 异步执行：会开启新的线程（如果有必要）来执行任务，不会阻塞当前线程，当前线程会继续执行后续的代码。 二、GCD 的核心组件2.1 队列类型2.1.1 串行队列每次只能执行一个任务，只有当前一个任务执行完成后，才会开始执行下一个任务。可以通过 dispatch_queue_create 函数创建自定义的串行队列。 12345678910111213// 创建自定义串行队列dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.example.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);// 异步执行任务dispatch_async(serialQueue, ^&#123; NSLog(@&quot;Task 1 in serial queue&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_async(serialQueue, ^&#123; NSLog(@&quot;Task 2 in serial queue&quot;); sleep(1); // 模拟耗时操作&#125;); 2.1.2 并发队列可以同时执行多个任务，任务的开始时间由 GCD 调度决定，但完成顺序不确定。可以通过 dispatch_queue_create 函数创建自定义的并发队列，也可以使用系统提供的全局并发队列。 1234567891011121314151617181920// 创建自定义并发队列dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.example.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);// 异步执行任务dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;Task 1 in concurrent queue&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;Task 2 in concurrent queue&quot;); sleep(1); // 模拟耗时操作&#125;);// 获取全局并发队列dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(globalQueue, ^&#123; NSLog(@&quot;Task in global concurrent queue&quot;); sleep(1); // 模拟耗时操作&#125;); 2.1.3 主队列是一个特殊的串行队列，专门用于在主线程上执行任务，通常用于更新 UI。可以通过 dispatch_get_main_queue 函数获取主队列。 1234567// 异步执行任务到主队列dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新 UI UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 30)]; label.text = @&quot;Hello, GCD!&quot;; [self.view addSubview:label];&#125;); 2.2 任务执行方式2.2.1 同步执行（dispatch_sync）123456dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_sync(queue, ^&#123; NSLog(@&quot;Synchronous task&quot;); sleep(1); // 模拟耗时操作&#125;);NSLog(@&quot;This line will be executed after the synchronous task&quot;); 2.2.2 异步执行（dispatch_async）123456dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^&#123; NSLog(@&quot;Asynchronous task&quot;); sleep(1); // 模拟耗时操作&#125;);NSLog(@&quot;This line will be executed immediately without waiting for the asynchronous task&quot;); 2.3 延迟执行（dispatch_after）用于在指定的时间后执行任务，通常用于实现定时任务。 1234dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC));dispatch_after(delayTime, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Delayed task executed after 2 seconds&quot;);&#125;); 2.4 一次性执行（dispatch_once）确保代码块只执行一次，常用于实现单例模式，保证在多线程环境下单例对象的唯一性。 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;This code block will be executed only once&quot;);&#125;); 2.5 分组执行（dispatch_group）可以将多个任务分组，当组内所有任务完成后，执行特定的操作。 12345678910111213141516dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;Task 1 in group&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;Task 2 in group&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;All tasks in the group are completed&quot;);&#125;); 2.6 栅栏函数（dispatch_barrier_async 和 dispatch_barrier_sync）用于在并发队列中实现同步操作，确保在栅栏函数之前的任务完成后，才会执行栅栏函数及其后面的任务。 1234567891011121314151617181920212223242526dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.example.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;Task 1 before barrier&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;Task 2 before barrier&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_barrier_async(concurrentQueue, ^&#123; NSLog(@&quot;Barrier task&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;Task 1 after barrier&quot;); sleep(1); // 模拟耗时操作&#125;);dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;Task 2 after barrier&quot;); sleep(1); // 模拟耗时操作&#125;); 2.7 信号量（dispatch_semaphore）用于控制并发任务的数量，通过信号量的计数来限制同时执行的任务数。 1234567891011dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); // 允许同时执行 2 个任务dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);for (int i = 0; i &lt; 5; i++) &#123; dispatch_async(queue, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;Task %d is executing&quot;, i); sleep(1); // 模拟耗时操作 dispatch_semaphore_signal(semaphore); &#125;);&#125; 三、GCD 的底层原理3.1 线程池管理GCD 维护了一个高效的线程池，用于管理线程的创建、复用和销毁。线程池的大小会根据系统的负载和任务的需求动态调整。当有任务提交到队列时，GCD 会从线程池中获取可用的线程来执行任务。如果线程池中没有可用的线程，且当前线程数量未达到系统限制，GCD 会创建新的线程；如果达到系统限制，则任务会等待直到有线程可用。 线程池的优势在于避免了频繁创建和销毁线程带来的性能开销。线程的创建和销毁是一个相对昂贵的操作，会消耗大量的系统资源和时间。通过线程池，GCD 可以复用已有的线程，提高了线程的利用率，从而提升了系统的整体性能。 3.2 任务调度算法GCD 使用了复杂而高效的任务调度算法，根据任务的优先级、队列类型和线程池的状态等因素，决定任务的执行顺序和线程分配。 3.2.1 优先级调度GCD 中的任务可以有不同的优先级，全局并发队列提供了四个不同优先级的队列：高、默认、低和后台。高优先级的任务会优先被调度执行，但需要注意的是，过高的优先级可能会导致低优先级的任务长时间得不到执行，产生饥饿现象。 3.2.2 队列类型影响串行队列中的任务会按照提交的顺序依次执行，而并发队列中的任务会根据系统资源和调度算法并行执行。在并发队列中，GCD 会尽量充分利用多核 CPU 的优势，同时执行多个任务，提高系统的并发处理能力。 3.2.3 线程池状态线程池的状态也是任务调度的重要考虑因素。如果线程池中有空闲线程，GCD 会优先将任务分配给这些空闲线程；如果线程池已满，任务会被放入队列中等待。 3.3 锁机制在多线程环境下，为了保证线程安全，GCD 使用了多种锁机制。例如，在访问共享资源时，会使用互斥锁来避免数据竞争。互斥锁确保同一时间只有一个线程可以访问共享资源，从而防止多个线程同时修改数据导致的数据不一致问题。 另外，GCD 还使用了读写锁来优化对共享资源的读写操作。读写锁允许多个线程同时进行读操作，但在进行写操作时，会独占资源，防止其他线程进行读写操作。这种机制可以提高并发性能，尤其是在读操作频繁的场景下。 3.4 工作队列与内核GCD 的工作队列与内核紧密协作，通过内核的调度机制来实现任务的高效执行。当任务提交到队列后，GCD 会将任务封装成一个工作项，并将其添加到工作队列中。内核会根据系统的负载和调度策略，从工作队列中取出工作项并分配给合适的线程执行。 GCD 与内核的协作还体现在线程的创建和销毁上。当需要创建新线程时，GCD 会向内核请求资源，内核会分配相应的线程资源；当线程不再使用时，GCD 会通知内核释放这些资源。 四、GCD 的应用场景4.1 网络请求在开发中，网络请求通常是一个耗时的操作，如果在主线程中进行网络请求，会导致界面卡顿，影响用户体验。因此，我们通常会在子线程中进行网络请求，完成后回到主线程更新 UI。 1234567891011121314151617181920dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 网络请求 NSURL *url = [NSURL URLWithString:@&quot;https://example.com&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; NSLog(@&quot;Network request error: %@&quot;, error.localizedDescription); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新 UI NSString *responseString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 30)]; label.text = responseString; [self.view addSubview:label]; &#125;); &#125; &#125;]; [task resume];&#125;); 4.2 图片处理图片处理，如解码、缩放、裁剪等操作，通常比较耗时。我们可以在子线程中进行这些操作，完成后回到主线程显示图片，避免阻塞主线程。 12345678910111213141516dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 加载图片 UIImage *image = [UIImage imageNamed:@&quot;largeImage&quot;]; // 图片处理 UIGraphicsBeginImageContextWithOptions(CGSizeMake(100, 100), NO, 0.0); [image drawInRect:CGRectMake(0, 0, 100, 100)]; UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^&#123; // 显示图片 UIImageView *imageView = [[UIImageView alloc] initWithImage:scaledImage]; imageView.frame = CGRectMake(0, 0, 100, 100); [self.view addSubview:imageView]; &#125;);&#125;); 4.3 数据处理在处理大量数据时，如文件读写、数据库操作等，会消耗大量的时间和系统资源。我们可以将这些操作放在子线程中进行，避免阻塞主线程，提高应用的响应性能。 123456789101112131415dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 数据处理 NSString *filePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents/largeFile.txt&quot;]; NSString *fileContent = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil]; // 处理文件内容 NSArray *lines = [fileContent componentsSeparatedByString:@&quot; &quot;]; NSLog(@&quot;Number of lines: %lu&quot;, (unsigned long)lines.count); dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新 UI 或显示结果 UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 30)]; label.text = [NSString stringWithFormat:@&quot;Number of lines: %lu&quot;, (unsigned long)lines.count]; [self.view addSubview:label]; &#125;);&#125;); 4.4 后台任务在某些情况下，我们需要在应用进入后台后继续执行一些任务，如上传文件、下载数据等。GCD 可以帮助我们实现后台任务的管理。 1234567891011121314151617- (void)applicationDidEnterBackground:(UIApplication *)application &#123; __block UIBackgroundTaskIdentifier backgroundTask = [application beginBackgroundTaskWithExpirationHandler:^&#123; [application endBackgroundTask:backgroundTask]; backgroundTask = UIBackgroundTaskInvalid; &#125;]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 后台任务 for (int i = 0; i &lt; 10; i++) &#123; NSLog(@&quot;Background task: %d&quot;, i); sleep(1); &#125; [application endBackgroundTask:backgroundTask]; backgroundTask = UIBackgroundTaskInvalid; &#125;);&#125; 4.5 预加载数据为了提高应用的响应速度，我们可以在应用启动或用户操作之前，提前加载一些数据。使用 GCD 可以在后台线程中进行数据的预加载，避免阻塞主线程。 1234567891011121314151617181920212223- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 预加载数据 NSArray *data = [self loadDataFromServer]; // 将数据存储到本地或缓存中 [self cacheData:data]; &#125;); return YES;&#125;- (NSArray *)loadDataFromServer &#123; // 模拟从服务器加载数据 sleep(3); return @[@&quot;Data 1&quot;, @&quot;Data 2&quot;, @&quot;Data 3&quot;];&#125;- (void)cacheData:(NSArray *)data &#123; // 缓存数据 NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:data forKey:@&quot;preloadedData&quot;]; [defaults synchronize];&#125; 4.6 并发计算在进行复杂的计算任务时，如数学计算、图像处理算法等，可以利用 GCD 的并发队列将任务分解为多个子任务并行执行，提高计算效率。 123456789101112131415161718192021222324dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.example.concurrentCalculation&quot;, DISPATCH_QUEUE_CONCURRENT);__block int result = 0;dispatch_group_t group = dispatch_group_create();// 分解任务for (int i = 0; i &lt; 10; i++) &#123; dispatch_group_async(group, concurrentQueue, ^&#123; int partialResult = [self calculatePartialResult:i]; @synchronized(self) &#123; result += partialResult; &#125; &#125;);&#125;dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Final result: %d&quot;, result);&#125;);- (int)calculatePartialResult:(int)index &#123; // 模拟复杂计算 sleep(1); return index * 2;&#125; 五、GCD 的注意事项5.1 死锁问题在使用 dispatch_sync 时要特别注意死锁问题。例如，在主队列中同步执行主队列的任务会导致死锁，因为主线程会等待同步任务执行完成，而同步任务又在等待主线程空闲，从而形成死锁。 1234// 以下代码会导致死锁dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;This code will cause a deadlock&quot;);&#125;); 5.2 线程安全在多线程环境下访问共享资源时，要确保线程安全。可以使用信号量、锁等机制来避免数据竞争和不一致问题。例如，在多个线程同时访问和修改一个数组时，需要使用锁来保证同一时间只有一个线程可以进行操作。 5.3 内存管理在使用 GCD 时，要注意 Block 的内存管理，避免循环引用。Block 会捕获其上下文中的变量，如果不小心，可能会导致对象之间的循环引用，从而造成内存泄漏。可以使用弱引用（如 __weak）来避免循环引用。 六、总结GCD 是 iOS 开发中强大且高效的多线程技术，通过合理运用 GCD 的队列、任务执行方式和各种高级特性，开发者可以轻松实现多线程编程，提升应用的性能和响应能力。同时，在使用 GCD 时要注意死锁、线程安全和内存管理等问题，以确保代码的健壮性。希望本文能帮助你深入理解 GCD 的底层原理和应用场景，在实际开发中更好地运用 GCD 技术。 参考资料： Apple Developer Documentation - Grand Central Dispatch (GCD) Objective - C Programming: The Big Nerd Ranch Guide","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - 多线程介绍","path":"/iOS/OC底层原理/探索Objective - C底层 - 多线程介绍/","content":"引言在当今的软件开发领域，多线程编程已经成为提升应用性能和响应能力的关键技术。在iOS开发中，合理运用多线程能够显著优化用户体验，避免主线程阻塞，实现高效的数据处理和界面交互。本文将深入探讨Objective - C中的多线程编程，涵盖进程与线程的基本概念、CPU与多线程的关系、常见多线程方案以及线程的生命周期等内容，并通过实际例子进行详细说明。 一、进程与线程1.1 进程进程是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间、系统资源和执行上下文。例如，当我们打开一个iOS应用时，操作系统会为该应用创建一个进程，这个进程包含了应用运行所需的所有资源，如代码段、数据段、堆、栈等。 1.2 线程线程是进程中的一个执行单元，是CPU调度和分派的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源，但每个线程都有自己独立的栈空间和执行上下文。线程可以并行执行，从而提高程序的执行效率。例如，在一个音乐播放应用中，主线程负责处理用户界面的交互，而一个子线程可以负责从网络下载音乐文件，另一个子线程可以负责解码和播放音乐。 1.3 进程与线程的关系 一个进程可以包含多个线程，但至少有一个主线程。 线程是进程的一部分，依赖于进程而存在。 进程之间相互独立，拥有各自的资源；而线程之间共享进程的资源，但有自己独立的栈空间。 二、CPU与多线程2.1 CPU核心数与线程CPU的核心数决定了它能够同时执行的线程数量。例如，一个双核CPU可以同时执行两个线程，而一个四核CPU可以同时执行四个线程。当线程数量超过CPU核心数时，CPU会通过时间片轮转的方式在不同线程之间进行切换，从而实现多线程的并发执行。 2.2 并行与并发 并行：指多个线程在同一时刻同时执行，需要多核CPU的支持。例如，一个四核CPU可以同时并行执行四个线程。 并发：指多个线程在一段时间内交替执行，通过CPU的时间片轮转实现。即使在单核CPU上，也可以实现多线程的并发执行。 2.3 多线程的优势 提高程序性能：通过并行或并发执行多个线程，可以充分利用CPU的资源，提高程序的执行效率。 增强用户体验：避免主线程阻塞，确保界面的流畅性和响应性。例如，在进行网络请求或文件处理时，可以将这些耗时操作放在子线程中执行，避免影响主线程的界面绘制和用户交互。 三、常见的多线程方案3.1 NSThreadNSThread 是Objective - C中最基础的多线程方案，它代表一个线程对象。我们可以通过创建 NSThread 对象并启动它来开启一个新的线程。 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;// 线程执行的方法- (void)threadMethod &#123; NSLog(@&quot;Current thread: %@&quot;, [NSThread currentThread]); // 模拟耗时操作 for (int i = 0; i &lt; 1000000; i++) &#123; // 执行一些任务 &#125; NSLog(@&quot;Thread task finished&quot;);&#125;// 创建并启动线程- (void)startNSThread &#123; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadMethod) object:nil]; [thread start];&#125; 3.2 NSOperationQueueNSOperationQueue 是基于 NSOperation 的高级多线程方案，它提供了更强大的任务管理和调度功能。NSOperation 是一个抽象类，我们可以使用它的子类 NSInvocationOperation 或 NSBlockOperation 来封装任务，然后将任务添加到 NSOperationQueue 中执行。 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;- (void)startOperationQueue &#123; // 创建操作队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 创建操作 NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;Current thread: %@&quot;, [NSThread currentThread]); // 模拟耗时操作 for (int i = 0; i &lt; 1000000; i++) &#123; // 执行一些任务 &#125; NSLog(@&quot;Operation task finished&quot;); &#125;]; // 将操作添加到队列中 [queue addOperation:operation];&#125; 3.3 GCD（Grand Central Dispatch）GCD 是苹果公司提供的一种基于C语言的多线程技术，它是一种高效的任务调度机制，能够自动管理线程的生命周期和资源。GCD 提供了全局队列和自定义队列，我们可以将任务以块（block）的形式提交到队列中执行。 123456789101112131415161718192021#import &lt;Foundation/Foundation.h&gt;- (void)startGCD &#123; // 获取全局队列 dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 提交任务到全局队列 dispatch_async(globalQueue, ^&#123; NSLog(@&quot;Current thread: %@&quot;, [NSThread currentThread]); // 模拟耗时操作 for (int i = 0; i &lt; 1000000; i++) &#123; // 执行一些任务 &#125; NSLog(@&quot;GCD task finished&quot;); // 回到主线程更新UI dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Back to main thread: %@&quot;, [NSThread currentThread]); &#125;); &#125;);&#125; 四、线程的生命周期4.1 创建线程的生命周期从创建开始。在上述的多线程方案中，我们可以通过不同的方式创建线程。例如，使用 NSThread 的 initWithTarget:selector:object: 方法创建一个新的线程对象，使用 NSOperationQueue 或 GCD 时，任务会被封装在操作或块中，由系统自动创建和管理线程。 4.2 就绪线程创建后，会进入就绪状态，等待CPU的调度。在这个状态下，线程已经准备好执行，但还没有获得CPU的执行权。 4.3 运行当CPU调度到该线程时，线程进入运行状态，开始执行任务。在运行过程中，线程会占用CPU的资源，执行相应的代码逻辑。 4.4 阻塞线程在执行过程中可能会因为某些原因进入阻塞状态，例如等待I&#x2F;O操作完成、等待锁的释放等。在阻塞状态下，线程会暂停执行，释放CPU资源，直到满足特定条件后再进入就绪状态。 4.5 终止线程执行完任务后，会进入终止状态，释放占用的资源。线程也可以因为异常或被强制终止而提前结束生命周期。 以下是一个简单的示例，展示线程的生命周期： 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;- (void)threadLifecycleExample &#123; // 创建线程 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTask) object:nil]; // 启动线程，进入就绪状态 [thread start]; // 等待线程执行完成 [thread join]; NSLog(@&quot;Thread terminated&quot;);&#125;- (void)threadTask &#123; NSLog(@&quot;Thread started&quot;); // 模拟耗时操作 for (int i = 0; i &lt; 1000000; i++) &#123; // 执行一些任务 &#125; NSLog(@&quot;Thread task completed&quot;);&#125; 五、总结多线程编程是iOS开发中不可或缺的一部分，通过合理运用多线程技术，可以提高应用的性能和用户体验。本文介绍了进程与线程的基本概念、CPU与多线程的关系、常见的多线程方案以及线程的生命周期，并通过实际例子进行了详细说明。在实际开发中，我们需要根据具体的需求和场景选择合适的多线程方案，并注意线程安全和资源管理等问题。 希望本文能帮助你更好地理解Objective - C中的多线程编程，如果你有任何疑问或建议，欢迎在评论区留言。 参考资料： Apple Developer Documentation - Concurrency Programming Guide Objective - C Programming: The Big Nerd Ranch Guide","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runloop的应用","path":"/iOS/OC底层原理/探索Objective - C底层 - Runloop的应用/","content":"引言在iOS开发中，Runloop是一个强大且基础的机制，它为应用程序提供了事件处理、线程管理和任务调度等功能。理解Runloop的应用场景不仅能让我们更好地优化代码性能，还能解决许多实际开发中遇到的难题。本文将深入探讨Runloop在不同场景下的应用，并结合具体例子进行详细说明。 一、Runloop 基础回顾Runloop 本质上是一个事件循环机制，它会使线程在没有任务时进入休眠状态，有任务时被唤醒并处理任务。每个线程都有一个与之关联的 Runloop，主线程的 Runloop 会在应用启动时自动创建并启动，而子线程的 Runloop 需要手动启动。Runloop 有多种运行模式，不同模式下可以处理不同类型的事件，常见的模式有 kCFRunLoopDefaultMode、UITrackingRunLoopMode 和 kCFRunLoopCommonModes。 二、Runloop 的应用场景2.1 定时器的使用2.1.1 基本定时器NSTimer 是 iOS 中常用的定时器类，它依赖于 Runloop 来触发事件。当我们创建一个 NSTimer 并将其添加到 Runloop 中时，Runloop 会在指定的时间间隔触发定时器的回调。 1234567891011121314151617181920212223242526#import &lt;Foundation/Foundation.h&gt;@interface TimerExample : NSObject@end@implementation TimerExample- (void)startTimer &#123; NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&#125;- (void)timerFired:(NSTimer *)timer &#123; NSLog(@&quot;Timer fired at %@&quot;, [NSDate date]);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TimerExample *example = [[TimerExample alloc] init]; [example startTimer]; [[NSRunLoop currentRunLoop] run]; &#125; return 0;&#125; 在上述代码中，我们创建了一个每隔 1 秒触发一次的定时器，并将其添加到当前 Runloop 的 NSRunLoopCommonModes 中。然后启动 Runloop，这样定时器就会按照设定的时间间隔触发回调。 2.1.2 解决定时器在滚动时失效问题当我们在 UITableView 或 UIScrollView 滚动时，默认模式下的定时器会暂停触发，因为滚动时 Runloop 会切换到 UITrackingRunLoopMode。为了解决这个问题，我们可以将定时器添加到 NSRunLoopCommonModes 中，这样定时器在滚动时也能正常触发。 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&#125;- (void)timerFired:(NSTimer *)timer &#123; NSLog(@&quot;Timer fired during scrolling&quot;);&#125; 2.2 线程保活在某些情况下，我们需要让子线程一直存活，以便随时处理一些异步任务。这时可以利用 Runloop 来实现线程保活。 1234567891011121314151617181920212223242526272829303132333435363738394041#import &lt;Foundation/Foundation.h&gt;@interface ThreadKeepAliveExample : NSObject@property (nonatomic, strong) NSThread *thread;@end@implementation ThreadKeepAliveExample- (void)startThread &#123; self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadEntryPoint) object:nil]; [self.thread start];&#125;- (void)threadEntryPoint &#123; @autoreleasepool &#123; // 注册一个端口，防止 Runloop 因没有源而退出 [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; // 启动 Runloop [[NSRunLoop currentRunLoop] run]; &#125;&#125;- (void)performTaskOnThread &#123; [self performSelector:@selector(taskOnThread) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;- (void)taskOnThread &#123; NSLog(@&quot;Task is being performed on the kept-alive thread&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; ThreadKeepAliveExample *example = [[ThreadKeepAliveExample alloc] init]; [example startThread]; [example performTaskOnThread]; sleep(5); &#125; return 0;&#125; 在上述代码中，我们创建了一个子线程，并在子线程的入口方法中启动了 Runloop。为了防止 Runloop 因没有源而退出，我们注册了一个 NSMachPort。这样，子线程就会一直存活，我们可以随时在该线程上执行任务。 2.3 异步绘制在 iOS 开发中，UI 绘制通常是在主线程上进行的，如果绘制任务比较复杂，可能会导致界面卡顿。我们可以利用 Runloop 的特性，将一些耗时的绘制任务放到子线程中异步执行，然后在合适的时机将绘制结果更新到 UI 上。 1234567891011121314151617181920212223242526#import &lt;UIKit/UIKit.h&gt;@interface AsyncDrawingView : UIView@end@implementation AsyncDrawingView- (void)drawRect:(CGRect)rect &#123; // 模拟耗时的绘制任务 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, [UIScreen mainScreen].scale); CGContextRef context = UIGraphicsGetCurrentContext(); // 绘制操作 CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor); CGContextFillRect(context, self.bounds); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); // 在主线程更新 UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.layer.contents = (__bridge id)image.CGImage; &#125;); &#125;);&#125;@end 在上述代码中，我们在 drawRect: 方法中开启一个异步任务进行绘制，绘制完成后将结果更新到 UI 上。这样可以避免在主线程上进行耗时的绘制操作，提高界面的流畅度。 2.4 网络请求的优化在进行网络请求时，我们可以利用 Runloop 来管理网络请求的生命周期。例如，当网络请求完成后，我们可以在 Runloop 的合适时机处理响应数据，避免在网络请求回调中进行复杂的操作导致主线程卡顿。 1234567891011121314151617181920212223242526272829303132333435363738#import &lt;Foundation/Foundation.h&gt;@interface NetworkRequestExample : NSObject@end@implementation NetworkRequestExample- (void)startNetworkRequest &#123; NSURL *url = [NSURL URLWithString:@&quot;https://example.com&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (error) &#123; NSLog(@&quot;Network request error: %@&quot;, error.localizedDescription); &#125; else &#123; // 在 Runloop 的空闲时间处理响应数据 [[NSRunLoop currentRunLoop] performSelector:@selector(handleResponseData:) withObject:data afterDelay:0 inModes:@[NSRunLoopCommonModes]]; &#125; &#125;]; [task resume];&#125;- (void)handleResponseData:(NSData *)data &#123; // 处理响应数据 NSString *responseString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;Response: %@&quot;, responseString);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NetworkRequestExample *example = [[NetworkRequestExample alloc] init]; [example startNetworkRequest]; [[NSRunLoop currentRunLoop] run]; &#125; return 0;&#125; 在上述代码中，我们在网络请求的回调中使用 performSelector:afterDelay:inModes: 方法将处理响应数据的任务安排到 Runloop 的空闲时间执行，这样可以避免在网络请求回调中进行复杂操作导致主线程卡顿。 2.5 检测卡顿我们可以利用 Runloop 的状态变化来检测应用是否卡顿。通过监听 Runloop 的 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 状态，计算这两个状态之间的时间间隔，如果时间间隔超过一定阈值，则认为应用出现了卡顿。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreFoundation/CoreFoundation.h&gt;@interface LagDetectionExample : NSObject@property (nonatomic, assign) CFRunLoopObserverRef observer;@property (nonatomic, assign) CFRunLoopActivity activity;@end@implementation LagDetectionExample- (void)startLagDetection &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; CFRunLoopObserverContext context = &#123;0, (__bridge void *)self, NULL, NULL, NULL&#125;; self.observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;(void(^)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; LagDetectionExample *example = (__bridge LagDetectionExample *)info; example.activity = activity; &#125;), &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), self.observer, kCFRunLoopCommonModes); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (YES) &#123; CFRunLoopActivity currentActivity = self.activity; if (currentActivity == kCFRunLoopBeforeSources || currentActivity == kCFRunLoopAfterWaiting) &#123; if (CACurrentMediaTime() - self.lastCheckTime &gt; 1.0) &#123; NSLog(@&quot;App is lagging!&quot;); &#125; self.lastCheckTime = CACurrentMediaTime(); &#125; usleep(50 * 1000); // 每 50 毫秒检查一次 &#125; &#125;); &#125;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; LagDetectionExample *example = [[LagDetectionExample alloc] init]; [example startLagDetection]; [[NSRunLoop currentRunLoop] run]; &#125; return 0;&#125; 在上述代码中，我们创建了一个 CFRunLoopObserver 来监听主线程 Runloop 的状态变化。在一个异步线程中，每隔 50 毫秒检查一次 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 状态之间的时间间隔，如果超过 1 秒，则认为应用出现了卡顿。 2.6 延迟加载有时候我们希望某些任务在应用空闲时再执行，这时可以利用 Runloop 的空闲时间来实现延迟加载。 1234567- (void)performDelayedTask &#123; [[NSRunLoop currentRunLoop] performSelector:@selector(delayedTask) target:self argument:nil order:0 modes:@[NSRunLoopCommonModes]];&#125;- (void)delayedTask &#123; NSLog(@&quot;Delayed task is being performed&quot;);&#125; 在上述代码中，我们使用 performSelector:target:argument:order:modes: 方法将任务安排到 Runloop 的空闲时间执行，这样可以避免在应用繁忙时执行该任务，提高应用的响应性能。 2.7 自动释放池管理在主线程中，Runloop 会自动管理自动释放池。每次 Runloop 循环开始时，会创建一个新的自动释放池，循环结束时，会释放这个自动释放池。在子线程中，我们可以手动管理自动释放池，结合 Runloop 来确保自动释放对象及时释放。 123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @autoreleasepool &#123; // 子线程任务 [[NSRunLoop currentRunLoop] run]; &#125;&#125;); 在上述代码中，我们在子线程中手动创建了一个自动释放池，并启动了 Runloop。这样可以确保在子线程中创建的自动释放对象在 Runloop 循环结束时被释放，避免内存泄漏。 2.8 处理异步回调在处理异步操作时，我们可以利用 Runloop 来确保回调在合适的线程和时机执行。例如，在使用 GCD 进行异步操作时，我们可以在回调中使用 performSelectorOnMainThread: 方法将任务切换到主线程执行。 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 异步任务 [NSThread sleepForTimeInterval:2.0]; [self performSelectorOnMainThread:@selector(callbackMethod) withObject:nil waitUntilDone:NO];&#125;);- (void)callbackMethod &#123; NSLog(@&quot;Callback method is called on the main thread&quot;);&#125; 在上述代码中，我们在异步任务完成后，使用 performSelectorOnMainThread: 方法将回调方法切换到主线程执行，确保 UI 操作在主线程上进行。 2.9 动画优化在进行动画操作时，我们可以利用 Runloop 的特性来优化动画的性能。例如，将动画的更新操作安排到 Runloop 的合适时机执行，避免在动画过程中进行不必要的计算。 1234567891011121314151617- (void)startAnimation &#123; [UIView animateWithDuration:2.0 animations:^&#123; // 动画操作 self.view.alpha = 0.0; &#125; completion:^(BOOL finished) &#123; // 动画完成回调 NSLog(@&quot;Animation finished&quot;); &#125;]; // 在 Runloop 的空闲时间更新动画状态 [[NSRunLoop currentRunLoop] performSelector:@selector(updateAnimationState) withObject:nil afterDelay:0 inModes:@[NSRunLoopCommonModes]];&#125;- (void)updateAnimationState &#123; // 更新动画状态 NSLog(@&quot;Updating animation state&quot;);&#125; 在上述代码中，我们在动画开始后，将更新动画状态的任务安排到 Runloop 的空闲时间执行，这样可以避免在动画过程中进行不必要的计算，提高动画的流畅度。 2.10 事件处理优化当应用需要处理大量的事件时，我们可以利用 Runloop 来优化事件处理的性能。例如，将一些耗时的事件处理任务放到子线程中执行，然后在主线程上更新 UI。 12345678910- (void)handleEvent &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的事件处理任务 [NSThread sleepForTimeInterval:2.0]; dispatch_async(dispatch_get_main_queue(), ^&#123; // 在主线程更新 UI self.label.text = @&quot;Event handled&quot;; &#125;); &#125;);&#125; 在上述代码中，我们将事件处理任务放到子线程中执行，避免在主线程上进行耗时操作，然后在任务完成后，将更新 UI 的操作切换到主线程上执行。 三、总结Runloop 在 iOS 开发中有着广泛的应用，通过合理利用 Runloop 的特性，我们可以优化应用的性能，解决卡顿问题，实现线程保活等功能。在实际开发中，我们需要根据具体的需求和场景，灵活运用 Runloop 的各种应用技巧，以提高应用的质量和用户体验。 希望本文能帮助你更好地理解 Runloop 的应用，如果你在开发过程中遇到相关问题，欢迎在评论区留言讨论。 参考资料： Apple Developer Documentation - Run Loops 深入理解Runloop","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runloop的底层原理","path":"/iOS/OC底层原理/探索Objective - C底层 - Runloop的底层原理/","content":"引言在iOS和macOS开发中，Runloop（运行循环）是一个非常重要的概念，它是程序运行的核心机制之一。理解Runloop的底层原理，对于解决诸如界面卡顿、定时器失效、线程保活等问题具有重要意义。本文将深入剖析Runloop的底层实现，带你了解其背后的奥秘。 一、Runloop的基本概念1.1 定义Runloop是一种事件处理循环机制，它可以让线程在没有任务时进入休眠状态，有任务时被唤醒并处理任务，从而避免线程不断地空转消耗CPU资源。在Objective - C中，Runloop由Core Foundation框架提供，对应的核心类是CFRunLoopRef。 1.2 作用 保持程序的持续运行：主线程的Runloop会一直运行，保证程序不会在启动后立即退出。 处理事件和消息：包括用户的触摸事件、网络请求的响应、定时器的触发等。 节省CPU资源：在没有任务时，线程进入休眠状态，降低CPU的使用率。 1.3 与线程的关系 一一对应：每个线程都有与之对应的唯一的Runloop对象。 按需创建：主线程的Runloop在程序启动时自动创建并启动，而子线程的Runloop默认是没有创建的，只有在第一次调用[NSRunLoop currentRunLoop]时才会创建。 生命周期：线程结束时，其对应的Runloop也会被销毁。 二、Runloop的底层数据结构2.1 CFRunLoop结构体123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; _lock：用于保护对模式列表的访问，确保线程安全。 _wakeUpPort：用于唤醒Runloop的端口。 _commonModes：存储通用模式的集合。 _commonModeItems：存储通用模式下的事件源、定时器和观察者。 _currentMode：当前正在运行的模式。 _modes：存储所有的运行模式。 2.2 CFRunLoopMode结构体123456789101112131415161718192021222324252627282930struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; _name：模式的名称，如kCFRunLoopDefaultMode、UITrackingRunLoopMode等。 _sources0：存储Source0类型的事件源。 _sources1：存储Source1类型的事件源。 _observers：存储观察者对象，用于监听Runloop的状态变化。 _timers：存储定时器对象。 2.3 事件源（Source）事件源分为两种类型： Source0：非基于端口的事件源，需要手动唤醒Runloop。例如，UIEvent、performSelector:onThread:等。 Source1：基于端口的事件源，能主动唤醒Runloop。例如，系统事件、Mach port等。 2.4 定时器（Timer）定时器用于在指定的时间或时间间隔后触发事件。常见的定时器有NSTimer和CADisplayLink。 2.5 观察者（Observer）观察者用于监听Runloop的状态变化，如进入Runloop、即将处理定时器、即将进入休眠等。可以通过CFRunLoopAddObserver函数添加观察者。 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Runloop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理定时器 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理事件源 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Runloop kCFRunLoopAllActivities = 0x0FFFFFFFU // 所有状态&#125;; 三、Runloop的运行流程3.1 启动Runloop在主线程中，Runloop会在程序启动时自动启动。而在子线程中，需要手动启动Runloop。启动Runloop的核心函数是CFRunLoopRunSpecific。 1SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled); rl：要运行的Runloop对象。 modeName：运行的模式名称。 seconds：Runloop运行的最长时间。 returnAfterSourceHandled：处理完一个事件源后是否立即返回。 3.2 完整的运行流程Runloop的运行流程可以分为以下几个主要步骤： 通知观察者进入Runloop：调用所有注册的观察者的回调函数，通知它们Runloop即将进入。 处理即将到期的定时器：检查所有的定时器，找出即将到期的定时器并触发它们的回调函数。 处理非延迟的performSelector调用：执行所有非延迟的performSelector方法。 处理Source0事件源：检查所有的Source0事件源，如果有准备好的事件，则处理这些事件。 检查Source1事件源：如果没有Source0事件需要处理，则检查是否有Source1事件。如果有Source1事件，则处理该事件并唤醒Runloop。 进入休眠状态：如果没有任何事件需要处理，Runloop会进入休眠状态，等待被唤醒。 被唤醒并处理事件：当有事件发生（如定时器到期、Source1事件触发等）时，Runloop会被唤醒，并处理相应的事件。 通知观察者即将退出Runloop：调用所有注册的观察者的回调函数，通知它们Runloop即将退出。 以下是一个简化的伪代码表示： 123456789101112131415161718192021222324252627282930313233// 启动Runloopwhile (true) &#123; // 通知观察者进入Runloop notifyObservers(kCFRunLoopEntry); // 处理即将到期的定时器 handleTimers(); // 处理非延迟的performSelector调用 handleNonDelayedPerformSelectors(); // 处理Source0事件源 if (hasReadySource0()) &#123; handleSource0(); &#125; else &#123; // 检查Source1事件源 if (hasSource1()) &#123; handleSource1(); continue; &#125; // 进入休眠状态 notifyObservers(kCFRunLoopBeforeWaiting); sleep(); notifyObservers(kCFRunLoopAfterWaiting); &#125; // 检查是否需要退出Runloop if (shouldExit()) &#123; notifyObservers(kCFRunLoopExit); break; &#125;&#125; 四、Runloop的模式（Mode）4.1 模式的概念Runloop的模式是一种隔离机制，不同的模式下可以有不同的事件源、定时器和观察者。Runloop在同一时间只能运行在一种模式下，只有在该模式下注册的事件源、定时器和观察者才会被处理。 4.2 常见的模式 kCFRunLoopDefaultMode：默认模式，大多数情况下Runloop运行在这个模式下。 UITrackingRunLoopMode：用于处理UI跟踪事件，如滚动视图的滚动。当用户拖动滚动视图时，Runloop会切换到这个模式。 kCFRunLoopCommonModes：这不是一个实际的模式，而是一个标记。可以将事件源、定时器和观察者注册到这个标记下，这样它们就可以在多个模式下都能被处理。 4.3 模式切换Runloop在不同的情况下会切换运行模式。例如，当用户开始拖动滚动视图时，Runloop会从kCFRunLoopDefaultMode切换到UITrackingRunLoopMode，以确保滚动事件能够得到及时处理。当滚动结束后，Runloop又会切换回原来的模式。 五、Runloop与线程的唤醒和休眠5.1 休眠机制Runloop在没有任务需要处理时会进入休眠状态，以节省CPU资源。在休眠状态下，线程会释放CPU资源，等待被唤醒。Runloop进入休眠状态的关键是调用mach_msg函数，该函数会使线程进入内核态，等待消息的到来。 5.2 唤醒机制当有事件发生时，Runloop会被唤醒。唤醒Runloop的方式有多种： Source1事件：基于端口的事件源（Source1）可以主动唤醒Runloop。 定时器到期：当定时器到期时，会触发相应的回调函数，从而唤醒Runloop。 手动唤醒：可以通过调用CFRunLoopWakeUp函数手动唤醒Runloop。 六、Runloop与AutoreleasePool6.1 主线程的AutoreleasePool在主线程中，Runloop会自动管理AutoreleasePool。每次Runloop循环开始时，会创建一个新的AutoreleasePool，在循环结束时，会释放这个AutoreleasePool。这样可以确保在一次Runloop循环中创建的自动释放对象在循环结束时被释放。 6.2 子线程的AutoreleasePool在子线程中，需要手动管理AutoreleasePool。如果在子线程中创建了大量的自动释放对象，而没有及时释放，可能会导致内存泄漏。因此，在子线程中启动Runloop时，通常需要手动创建和释放AutoreleasePool。 123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @autoreleasepool &#123; // 子线程任务 [[NSRunLoop currentRunLoop] run]; &#125;&#125;); 七、总结Runloop是Objective - C中一个非常重要的机制，它通过事件循环的方式，让线程在有任务时处理任务，没有任务时进入休眠状态，从而提高了程序的性能和响应能力。深入理解Runloop的底层原理，包括其数据结构、运行流程、模式机制、唤醒和休眠机制以及与AutoreleasePool的关系，对于优化代码性能、解决各种开发中的问题具有重要意义。希望本文能帮助你更好地理解Runloop的底层原理。 参考资料： Apple Developer Documentation - Run Loops Core Foundation Source Code","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runtime的相关应用","path":"/iOS/OC底层原理/探索Objective - C底层 - Runtime的相关应用/","content":"引言Objective - C 的 Runtime 是一个强大且灵活的运行时系统，它为开发者提供了许多在编译时无法实现的动态特性。在之前的文章中，我们已经深入探讨了 Runtime 的底层原理，包括 isa 指针、class 结构、objc_msgSend 机制等。本文将重点介绍 Runtime 在实际开发中的一些常见应用，并通过具体的例子详细说明。 一、核心Runtime API详解1. 类与对象操作1234567891011// 获取类的父类Class class_getSuperclass(Class cls);// 获取类的实例方法Method class_getInstanceMethod(Class cls, SEL name);// 获取类的所有方法Method *class_copyMethodList(Class cls, unsigned int *outCount);// 创建类的实例id class_createInstance(Class cls, size_t extraBytes); 2. 方法操作12345678// 交换两个方法的实现void method_exchangeImplementations(Method m1, Method m2);// 添加新方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types);// 获取方法实现IMP class_getMethodImplementation(Class cls, SEL name); 3. 关联对象12345// 设置关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 获取关联对象id objc_getAssociatedObject(id object, const void *key); 4. 属性与协议12345// 获取属性列表objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount);// 获取协议列表Protocol *class_copyProtocolList(Class cls, unsigned int *outCount); 二、15种典型应用场景1. 方法交换（Method Swizzling）应用场景：统一日志记录、埋点统计 123456789101112131415@implementation UIViewController (Logging)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method original = class_getInstanceMethod(self, @selector(viewDidLoad)); Method swizzled = class_getInstanceMethod(self, @selector(swizzled_viewDidLoad)); method_exchangeImplementations(original, swizzled); &#125;);&#125;- (void)swizzled_viewDidLoad &#123; [self swizzled_viewDidLoad]; NSLog(@&quot;ViewController %@ loaded&quot;, NSStringFromClass([self class]));&#125;@end 2. 动态添加方法应用场景：懒加载功能模块 12345678910111213141516@interface DynamicLoader : NSObject@end@implementation DynamicLoadervoid dynamicMethod(id self, SEL _cmd) &#123; NSLog(@&quot;Dynamic method called&quot;);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(lazyMethod)) &#123; class_addMethod(self, sel, (IMP)dynamicMethod, &quot;v@:&quot;); return YES; &#125; return NO;&#125;@end 3. 关联对象扩展类应用场景：为系统类添加属性 123456789101112131415@interface UIImage (Watermark)@property (nonatomic, strong) UIImage *watermarkedImage;@end@implementation UIImage (Watermark)static char kWatermarkKey;- (void)setWatermarkedImage:(UIImage *)image &#123; objc_setAssociatedObject(self, &amp;kWatermarkKey, image, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (UIImage *)watermarkedImage &#123; return objc_getAssociatedObject(self, &amp;kWatermarkKey);&#125;@end 4. 字典转模型应用场景：JSON数据解析 1234567891011121314151617181920@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@implementation Person- (instancetype)initWithDictionary:(NSDictionary *)dict &#123; self = [super init]; unsigned int count; objc_property_t *props = class_copyPropertyList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSString *key = [NSString stringWithUTF8String:property_getName(props[i])]; if (dict[key]) &#123; [self setValue:dict[key] forKey:key]; &#125; &#125; free(props); return self;&#125;@end 5. AOP编程（面向切面编程）应用场景：统一异常处理 123456789101112131415@implementation NSObject (ExceptionHandler)+ (void)load &#123; Method original = class_getInstanceMethod(self, @selector(forwardInvocation:)); Method swizzled = class_getInstanceMethod(self, @selector(swizzled_forwardInvocation:)); method_exchangeImplementations(original, swizzled);&#125;- (void)swizzled_forwardInvocation:(NSInvocation *)invocation &#123; @try &#123; [self swizzled_forwardInvocation:invocation]; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;Caught exception: %@&quot;, exception); &#125;&#125;@end 6. KVO实现应用场景：属性变更监听 1234567891011@interface Observable : NSObject@property (nonatomic, strong) NSString *value;@end@implementation Observable- (void)setValue:(NSString *)value &#123; [self willChangeValueForKey:@&quot;value&quot;]; _value = value; [self didChangeValueForKey:@&quot;value&quot;];&#125;@end 7. 动态代理应用场景：实现轻量级代理模式 123456789@interface DynamicProxy : NSObject@property (nonatomic, weak) id target;@end@implementation DynamicProxy- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return self.target;&#125;@end 8. 方法拦截应用场景：实现方法调用监控 123456789101112@implementation NSObject (MethodInterceptor)+ (void)load &#123; Method original = class_getInstanceMethod(self, @selector(performSelector:)); Method swizzled = class_getInstanceMethod(self, @selector(intercepted_performSelector:)); method_exchangeImplementations(original, swizzled);&#125;- (id)intercepted_performSelector:(SEL)aSelector &#123; NSLog(@&quot;Intercepted selector: %@&quot;, NSStringFromSelector(aSelector)); return [self intercepted_performSelector:aSelector];&#125;@end 9. 实现单例应用场景：线程安全的单例模式 12345678910111213141516171819@interface Singleton : NSObject+ (instancetype)sharedInstance;@end@implementation Singletonstatic id _instance;+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [super allocWithZone:zone]; &#125;); return _instance;&#125;+ (instancetype)sharedInstance &#123; return [[self alloc] init];&#125;@end 10. 热修复应用场景：紧急修复线上bug 1234567891011121314@interface BuggyClass : NSObject- (void)buggyMethod;@end@implementation BuggyClassvoid fixedMethod(id self, SEL _cmd) &#123; NSLog(@&quot;Fixed implementation&quot;);&#125;+ (void)load &#123; Method buggy = class_getInstanceMethod(self, @selector(buggyMethod)); class_replaceMethod(self, buggy, (IMP)fixedMethod, &quot;v@:&quot;);&#125;@end 11. 统计方法调用次数应用场景：性能分析 12345678910111213141516171819@implementation NSObject (MethodCounter)static char kInvocationCountKey;- (void)incrementInvocationCount &#123; NSNumber *count = objc_getAssociatedObject(self, &amp;kInvocationCountKey); objc_setAssociatedObject(self, &amp;kInvocationCountKey, @(count.integerValue + 1), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;+ (void)load &#123; Method original = class_getInstanceMethod(self, @selector(performSelector:)); Method swizzled = class_getInstanceMethod(self, @selector(counted_performSelector:)); method_exchangeImplementations(original, swizzled);&#125;- (id)counted_performSelector:(SEL)aSelector &#123; [self incrementInvocationCount]; return [self counted_performSelector:aSelector];&#125;@end 12. 实现协议应用场景：动态遵循协议 123456789101112131415@interface DynamicAdopter : NSObject@end@implementation DynamicAdopter+ (BOOL)conformsToProtocol:(Protocol *)aProtocol &#123; return YES;&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (Protocol_getMethodDescription(aProtocol, aSelector, YES, YES)) &#123; return self; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 13. 实现链式调用应用场景：构建DSL 123456789101112@interface Chainable : NSObject- (Chainable *(^)(NSString *))setName;@end@implementation Chainable- (Chainable *(^)(NSString *))setName &#123; return ^(NSString *name) &#123; [self setValue:name forKey:@&quot;name&quot;]; return self; &#125;;&#125;@end 14. 实现动态容器应用场景：动态存储键值对 1234567891011121314@interface DynamicContainer : NSObject- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKey:(NSString *)key;@end@implementation DynamicContainer- (void)setValue:(id)value forKey:(NSString *)key &#123; objc_setAssociatedObject(self, (__bridge const void *)(key), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)valueForKey:(NSString *)key &#123; return objc_getAssociatedObject(self, (__bridge const void *)(key));&#125;@end 15. 实现自定义KVC应用场景：扩展KVC功能 12345678910111213141516171819@interface CustomKVC : NSObject- (void)customSetValue:(id)value forKey:(NSString *)key;@end@implementation CustomKVC- (void)customSetValue:(id)value forKey:(NSString *)key &#123; unsigned int count; objc_property_t *props = class_copyPropertyList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; if ([NSStringFromCString(property_getName(props[i])) isEqualToString:key]) &#123; [self setValue:value forKey:key]; free(props); return; &#125; &#125; free(props); [self doesNotRecognizeSelector:_cmd];&#125;@end 三、注意事项 性能开销：频繁使用Runtime API可能影响性能 线程安全：方法交换等操作需加锁保护 版本兼容：不同iOS版本的Runtime实现可能有差异 内存管理：关联对象需合理选择内存策略 方法冲突：避免方法名冲突导致不可预期行为 四、总结Objective - C Runtime通过开放底层API，赋予开发者强大的动态编程能力。掌握这些API的使用方法和应用场景，能够显著提升代码的灵活性和扩展性。建议在实际开发中结合具体需求，合理运用Runtime技术，并注意性能与维护性的平衡。 参考资料： Apple Runtime Programming Guide objc4开源代码","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runtime（二）","path":"/iOS/OC底层原理/探索Objective - C底层 - Runtime（二）/","content":"引言在Objective - C的开发中，Runtime 系统是其核心的动态特性支撑。在之前的文章里，我们已经对 isa 指针、class 结构和方法缓存等基础概念有了深入了解。这篇文章将继续深入探究 Runtime 里的几个关键部分，像 objc_msgSend 的三个阶段、super 的本质以及 isKindOf 和 isMemberOf 的底层实现等。 一、objc_msgSend 的三个阶段1.1 消息机制概述在Objective - C里，方法调用本质上是消息发送的过程。当代码里出现 [object method] 这样的方法调用时，编译器会把它转化为 objc_msgSend(object, @selector(method)) 函数调用。objc_msgSend 函数承担着在运行时找到并执行对应方法的重要任务，其执行过程分为三个阶段：消息发送、动态方法解析和消息转发。 1.2 消息发送阶段消息发送阶段是 objc_msgSend 的首要步骤，它的主要任务是查找方法的实现。具体流程如下： **检查接收者是否为 nil**：要是接收者为 nil，消息发送会直接返回，不会有任何操作。这也是Objective - C中给 nil 对象发送消息不会引发崩溃的原因。 查找方法缓存：先在接收者对象所属类的方法缓存里查找目标方法。由于方法缓存运用了哈希表结构，查找速度非常快。若在缓存中找到该方法，就直接调用其实现。 查找方法列表：若缓存中未找到目标方法，就会在接收者对象所属类的方法列表中查找。如果找到了，就将该方法添加到缓存中，再调用其实现。 查找父类：要是在当前类的方法列表中没找到目标方法，会沿着继承链向上，在父类的方法缓存和方法列表中继续查找，直至找到或者到达根类。 1.3 动态方法解析阶段若在消息发送阶段没有找到目标方法，就会进入动态方法解析阶段。在这个阶段，Runtime 会调用 resolveInstanceMethod:（针对实例方法）或者 resolveClassMethod:（针对类方法）方法，让开发者有机会动态添加方法的实现。示例代码如下： 123456789101112131415@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(dynamicMethod)) &#123; class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void dynamicMethodIMP(id self, SEL _cmd) &#123; NSLog(@&quot;Dynamic method called.&quot;);&#125;@end 在上述代码中，当调用 dynamicMethod 方法且该方法未找到时，resolveInstanceMethod: 会被调用，在这个方法里动态添加了 dynamicMethod 的实现。 1.4 消息转发阶段若动态方法解析阶段也未能解决问题，就会进入消息转发阶段。消息转发分为两个步骤： 备用接收者：Runtime 会调用 forwardingTargetForSelector: 方法，询问是否有其他对象可以处理这个消息。若返回一个非 nil 的对象，就会把消息转发给这个对象处理。示例代码如下：123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(anotherMethod)) &#123; return anotherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 完整消息转发：若备用接收者阶段没有处理消息，Runtime 会调用 methodSignatureForSelector: 方法获取方法签名，接着调用 forwardInvocation: 方法，开发者可以在这个方法里自定义消息的处理逻辑。示例代码如下：123456789101112131415- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector == @selector(yetAnotherMethod)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL selector = [anInvocation selector]; if ([anotherObject respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:anotherObject]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 二、super 的本质2.1 super 的基本概念在Objective - C里，super 关键字常被用于调用父类的方法。不过，super 并非一个对象，而是一个编译器指示符。当使用 super 调用方法时，实际上是告诉编译器从父类开始查找方法的实现。 2.2 super 的底层实现super 的底层是通过 objc_msgSendSuper 函数实现的。objc_msgSendSuper 函数接收一个 objc_super 结构体作为参数，这个结构体定义如下： 1234struct objc_super &#123; __unsafe_unretained _Nonnull id receiver; __unsafe_unretained _Nonnull Class super_class;&#125;; receiver：消息的接收者，也就是当前对象。 super_class：开始查找方法实现的父类。 当使用 super 调用方法时，编译器会生成如下代码： 1234struct objc_super superReceiver;superReceiver.receiver = self;superReceiver.super_class = [self superclass];objc_msgSendSuper(&amp;superReceiver, @selector(method)); 这表明 super 调用方法时，接收者依然是当前对象 self，只是从父类开始查找方法的实现。 2.3 super 使用示例下面通过一个具体的例子来理解 super 的使用： 123456789101112131415161718192021222324252627282930#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject- (void)eat;@end@implementation Animal- (void)eat &#123; NSLog(@&quot;Animal is eating.&quot;);&#125;@end@interface Dog : Animal- (void)eat;@end@implementation Dog- (void)eat &#123; [super eat]; NSLog(@&quot;Dog is eating.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog *dog = [[Dog alloc] init]; [dog eat]; &#125; return 0;&#125; 在上述代码中，Dog 类继承自 Animal 类，并重写了 eat 方法。在 Dog 类的 eat 方法中，使用 [super eat] 调用了父类 Animal 的 eat 方法，然后再执行自身的逻辑。运行这段代码，输出结果如下： 12Animal is eating.Dog is eating. 这说明 super 成功调用了父类的方法，并且当前对象依然是 Dog 实例。 三、isKindOf 和 isMemberOf 的底层实现3.1 isKindOfClass 方法isKindOfClass 方法用于判断一个对象是否是某个类或者其子类的实例。其底层实现逻辑如下： 12345678910111213+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 从上述代码可以看出，isKindOfClass 方法会沿着继承链向上查找，逐个比较对象所属类及其父类是否与传入的类相等，只要有一个相等就返回 YES，否则返回 NO。 3.2 isKindOfClass 示例1234567891011121314151617181920212223242526#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject@end@implementation Animal@end@interface Dog : Animal@end@implementation Dog@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog *dog = [[Dog alloc] init]; BOOL result1 = [dog isKindOfClass:[Dog class]]; BOOL result2 = [dog isKindOfClass:[Animal class]]; BOOL result3 = [dog isKindOfClass:[NSObject class]]; NSLog(@&quot;Is dog an instance of Dog: %d&quot;, result1); NSLog(@&quot;Is dog an instance of Animal: %d&quot;, result2); NSLog(@&quot;Is dog an instance of NSObject: %d&quot;, result3); &#125; return 0;&#125; 在这个例子中，Dog 类继承自 Animal 类，Animal 类继承自 NSObject 类。dog 实例调用 isKindOfClass 方法分别判断是否为 Dog、Animal 和 NSObject 类的实例。运行结果如下： 123Is dog an instance of Dog: 1Is dog an instance of Animal: 1Is dog an instance of NSObject: 1 这表明 dog 既是 Dog 类的实例，也是 Animal 类和 NSObject 类的实例，因为 isKindOfClass 会考虑继承关系。 3.3 isMemberOfClass 方法isMemberOfClass 方法用于判断一个对象是否是某个类的直接实例，不包括子类。其底层实现逻辑如下： 1234567+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 从代码可知，isMemberOfClass 方法直接比较对象所属类是否与传入的类相等，只有相等时才返回 YES，否则返回 NO。 3.4 isMemberOfClass 示例123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject@end@implementation Animal@end@interface Dog : Animal@end@implementation Dog@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog *dog = [[Dog alloc] init]; BOOL result1 = [dog isMemberOfClass:[Dog class]]; BOOL result2 = [dog isMemberOfClass:[Animal class]]; NSLog(@&quot;Is dog a direct instance of Dog: %d&quot;, result1); NSLog(@&quot;Is dog a direct instance of Animal: %d&quot;, result2); &#125; return 0;&#125; 在这个例子中，dog 实例调用 isMemberOfClass 方法分别判断是否为 Dog 类和 Animal 类的直接实例。运行结果如下： 12Is dog a direct instance of Dog: 1Is dog a direct instance of Animal: 0 这表明 dog 是 Dog 类的直接实例，但不是 Animal 类的直接实例，因为 isMemberOfClass 不考虑继承关系。 四、总结深入理解 objc_msgSend 的三个阶段、super 的本质以及 isKindOf 和 isMemberOf 的底层实现，能让我们更清晰地把握Objective - C的消息机制和继承体系。objc_msgSend 的三个阶段为方法调用提供了极大的灵活性，让我们可以在运行时动态添加和转发方法；super 的本质让我们明白它是如何调用父类方法的；isKindOf 和 isMemberOf 的底层实现则帮助我们准确判断对象与类之间的关系。这些知识对于优化代码性能、解决复杂问题以及实现高级功能都有着重要的意义。希望通过本文的介绍，你能对Objective - C Runtime有更深入的认识。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runtime（一）","path":"/iOS/OC底层原理/探索Objective - C底层 - Runtime（一）/","content":"引言在Objective - C的世界里，Runtime（运行时系统）犹如幕后的神秘操控者，它赋予了这门语言动态特性，使得很多在编译时无法确定的操作能够在运行时灵活处理。了解Runtime的底层原理，对于深入掌握Objective - C编程、优化代码性能以及解决复杂问题都有着至关重要的意义。本文将深入剖析Runtime中的几个核心概念，包括isa指针、class的结构以及方法缓存。 一、isa指针详解1.1 isa指针的基本概念在Objective - C里，几乎所有的对象都是objc_object结构体的实例，而objc_object结构体中最重要的成员就是isa指针。isa指针的主要作用是指向对象所属的类，通过这个指针，对象能够知道自己应该调用哪个类的方法。 下面是objc_object结构体的简化定义： 123struct objc_object &#123; Class isa;&#125;; 这里的Class实际上是一个指向objc_class结构体的指针，也就是说isa指针指向的是一个objc_class类型的实例，这个实例代表了对象所属的类。 1.2 isa的本质在早期的Objective - C版本中，isa 确实只是一个简单的指针，直接指向对象所属的类。但从64位系统开始，isa 不再仅仅是一个单纯的指针，而是被设计成了一个 isa_t 类型的共用体（union）。共用体的特点是所有成员共享同一块内存空间，这使得 isa 可以在有限的内存空间里存储更多的信息。 isa_t 共用体的简化定义如下： 123456789101112131415union isa_t &#123; Class cls; uintptr_t bits; struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; &#125;;&#125;; 1.3 isa中存储的内容 nonpointer：这是一个标志位，占1位。当它的值为 0 时，表示 isa 是一个普通的指针，仅存储类的地址；当值为 1 时，意味着 isa 是一个非指针类型，除了存储类的地址外，还会存储其他额外信息。 has_assoc：同样是一个标志位，占1位。用于标记对象是否有关联对象。如果对象使用了 objc_setAssociatedObject 方法关联了其他对象，这个标志位会被置为 1。 has_cxx_dtor：1位的标志位，用于判断对象是否有 C++ 析构函数。若对象有 C++ 析构函数，该标志位为 1，在对象销毁时需要调用相应的析构函数。 shiftcls：占据 33 位，这部分存储的是类的指针值。由于内存对齐的原因，类的地址会有一定的偏移，通过右移操作可以得到真正的类地址。 magic：占 6 位，用于调试时判断对象是否已经完成初始化。 weakly_referenced：1位标志位，用来标记对象是否被弱引用指向。如果对象被弱引用引用，该标志位为 1。 deallocating：1位标志位，指示对象是否正在进行析构操作。 has_sidetable_rc：1位标志位，判断对象的引用计数是否存储在 sidetable 中。当对象的引用计数过大，extra_rc 无法存储时，会将部分引用计数存储在 sidetable 中，此时该标志位为 1。 extra_rc：占据 19 位，存储对象的引用计数。当对象的引用计数增加时，extra_rc 的值会相应增加。 1.4 isa指针的指向规则实例对象的isa指针实例对象的isa指针指向其所属的类。例如，当我们创建一个Person类的实例person时，person对象的isa指针就指向Person类。 类对象的isa指针类对象的isa指针指向元类（meta - class）。元类是一种特殊的类，它存储了类方法的信息。当我们调用一个类方法时，实际上是通过类对象的isa指针找到对应的元类，然后在元类中查找并调用相应的方法。 元类的isa指针元类的isa指针指向根元类（root meta - class）。根元类是所有元类的基类，它的isa指针指向自己，形成一个闭环。 1.5 isa指针的走位图通过一个简单的示例和对应的走位图能更直观地理解isa指针的指向关系。假设我们有一个继承自NSObject的Person类： 12345@interface Person : NSObject@end@implementation Person@end 对应的isa指针走位图如下： 二、class的结构2.1 class的基本结构在Runtime中，类是通过objc_class结构体来表示的。下面是objc_class结构体的简化定义： 123456struct objc_class &#123; Class isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; isa指针前面已经详细介绍过，它指向类的元类，用于确定类方法的查找路径。 superclass指针superclass指针指向父类，通过这个指针可以实现类的继承关系。当在当前类中找不到某个方法时，Runtime会沿着superclass指针的路径到父类中继续查找。 cache（方法缓存）cache是一个cache_t类型的结构体，用于缓存已经调用过的方法，以提高方法查找的效率。后续会详细介绍方法缓存的相关内容。 bits（类的数据信息）bits是一个class_data_bits_t类型的结构体，它存储了类的具体数据信息，包括方法列表、属性列表、协议列表等。 2.2 从bits中获取类的信息通过bits可以获取类的各种信息，例如方法列表、属性列表等。以下是一个简单的示例代码，展示如何获取类的方法列表： 1234567891011121314151617181920212223242526#import &lt;objc/runtime.h&gt;@interface Person : NSObject- (void)sayHello;@end@implementation Person- (void)sayHello &#123; NSLog(@&quot;Hello!&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; unsigned int methodCount = 0; Method *methods = class_copyMethodList([Person class], &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i++) &#123; Method method = methods[i]; SEL selector = method_getName(method); NSString *methodName = NSStringFromSelector(selector); NSLog(@&quot;Method name: %@&quot;, methodName); &#125; free(methods); &#125; return 0;&#125; 在这个示例中，我们使用class_copyMethodList函数从Person类的bits中获取方法列表，并遍历打印出每个方法的名称。 三、方法缓存（cache_t）3.1 方法缓存的作用在Objective - C中，方法调用是一个相对复杂的过程，需要在类及其父类的方法列表中查找对应的方法。为了提高方法调用的效率，Runtime引入了方法缓存机制。当一个方法被调用时，Runtime会将该方法的信息（包括方法名和方法实现）缓存到类的cache中。下次再调用相同方法时，会直接从缓存中查找，避免了重复的方法查找过程，从而显著提高了方法调用的速度。 3.2 cache_t结构体的结构cache_t结构体的简化定义如下： 12345struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;; _buckets_buckets是一个指向bucket_t结构体数组的指针，bucket_t结构体存储了方法的具体信息，包括方法名（SEL）和方法实现（IMP）。以下是bucket_t结构体的简化定义： 1234struct bucket_t &#123; SEL _sel; IMP _imp;&#125;; _mask_mask是一个掩码，用于确定_buckets数组的大小。_mask的值通常是2^n - 1的形式，这样在进行哈希计算时可以更高效。 _occupied_occupied表示当前_buckets数组中已经占用的桶（bucket）的数量。 3.3 cache_t是如何缓存的缓存插入当一个方法被调用时，首先会计算该方法选择器（SEL）的哈希值。通常使用 SEL 的值与 _mask 进行按位与运算（hash = _sel &amp; _mask），以此来确定该方法在 _buckets 数组中的初始位置。 如果计算得到的位置为空，那么直接将该方法的信息（SEL 和 IMP）存储到这个 bucket 中。但如果该位置已经被占用，就会采用开放寻址法（通常是线性探测）来寻找下一个可用的位置。线性探测就是依次检查下一个位置，直到找到一个空的 bucket 为止。 以下是简化的插入逻辑伪代码： 12345678hash = _sel &amp; _mask;index = hash;while (_buckets[index] is not empty) &#123; index = (index + 1) &amp; _mask; // 线性探测，寻找下一个位置&#125;_buckets[index]._sel = _sel;_buckets[index]._imp = _imp;_occupied++; 缓存查找当再次调用相同方法时，同样会先计算该方法选择器（SEL）的哈希值，使用相同的哈希计算方式（hash = _sel &amp; _mask）得到在 _buckets 数组中的初始位置。 然后从这个位置开始检查 bucket 中的 SEL 是否与要查找的 SEL 相等。如果相等，就表示找到了对应的方法，直接调用该 bucket 中的 IMP。如果不相等，就按照线性探测的方式继续检查下一个位置，直到找到匹配的 SEL 或者遍历完整个 _buckets 数组。 以下是简化的查找逻辑伪代码： 123456789hash = _sel &amp; _mask;index = hash;while (_buckets[index] is not empty) &#123; if (_buckets[index]._sel == _sel) &#123; return _buckets[index]._imp; // 找到方法实现，返回 &#125; index = (index + 1) &amp; _mask; // 线性探测，检查下一个位置&#125;return nil; // 未找到方法实现 缓存扩容当 _occupied 的值达到一定阈值（通常是 _mask 的 3/4）时，cache_t 会进行扩容操作。扩容时会创建一个更大的 _buckets 数组，新数组的大小一般是原来的两倍。 然后将原数组中的所有 bucket 重新哈希到新数组中。重新哈希的过程就是对原数组中的每个 bucket 重新计算哈希值，然后根据新的 _mask 确定在新数组中的位置，并将其存储到新位置。 以下是简化的扩容逻辑伪代码： 12345678910111213oldBuckets = _buckets;oldMask = _mask;// 创建新的 _buckets 数组，大小为原来的两倍_newBuckets = createNewBuckets(oldMask * 2 + 1); _mask = oldMask * 2 + 1;_occupied = 0;// 遍历原数组，将每个 bucket 重新哈希到新数组中for (i = 0; i &lt;= oldMask; i++) &#123; if (oldBuckets[i] is not empty) &#123; insertIntoNewBuckets(oldBuckets[i]._sel, oldBuckets[i]._imp); &#125;&#125;free(oldBuckets); 四、总结Objective - C的Runtime系统是一个复杂而强大的机制，其中isa指针、class的结构以及方法缓存是Runtime的核心组成部分。isa指针确定了对象、类和元类之间的关系，其本质是一个 isa_t 共用体，存储了丰富的信息，是方法调用的基础；class的结构存储了类的各种信息，包括方法、属性和协议等；方法缓存则提高了方法调用的效率，减少了不必要的方法查找开销。深入理解这些概念，有助于我们更好地掌握Objective - C的动态特性，优化代码性能，解决开发中遇到的各种问题。 希望通过本文的介绍，你能对Objective - C Runtime有更深入的认识，在实际开发中能够更加灵活地运用这些知识。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Block的底层原理","path":"/iOS/OC底层原理/探索Objective-C底层 - Block的底层原理/","content":"引言在Objective - C开发中，Block是一个强大且灵活的特性，它允许开发者将代码块作为对象进行传递和存储。无论是在异步操作、回调机制还是数据处理中，Block都发挥着重要作用。然而，要真正掌握Block的使用，理解其底层原理是必不可少的。本文将深入探讨Block的底层结构、内存管理以及循环引用问题的解决方法。 一、Block的底层结构1.1 Block的本质Block本质上是一个结构体，它封装了一段代码以及该代码执行时所需的上下文信息。在底层，Block结构体包含以下几个关键部分： 1.1.1 isa指针类似于Objective - C对象，Block也有一个isa指针，它指向Block所属的类。根据isa指针的不同，Block可以分为三种类型： NSGlobalBlock：存储在全局数据区，当Block不捕获任何外部变量时，会被创建为全局Block。例如：123void (^globalBlock)(void) = ^&#123; NSLog(@&quot;This is a global block.&quot;);&#125;; NSStackBlock：存储在栈区，当Block捕获了外部变量，但没有进行复制操作时，会被创建为栈Block。栈Block的生命周期与所在的栈帧相同，当栈帧销毁时，栈Block也会失效。例如：1234int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;Captured number: %d&quot;, num);&#125;; NSMallocBlock：存储在堆区，当对栈Block进行复制操作时，会将其复制到堆区，成为堆Block。堆Block的生命周期由开发者管理，需要手动释放。例如：12345int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;Captured number: %d&quot;, num);&#125;;void (^heapBlock)(void) = [stackBlock copy]; 1.1.2 函数指针Block结构体中包含一个函数指针，指向Block实际执行的代码块。当调用Block时，实际上是通过这个函数指针来执行代码。 1.1.3 捕获的变量如果Block捕获了外部变量，这些变量会被存储在Block结构体中。捕获的方式根据变量的类型有所不同： 值捕获：对于基本数据类型的局部变量，Block会捕获其值。在Block定义时，会将变量的值复制到Block结构体中，后续变量值的改变不会影响Block内部的值。123456int num = 10;void (^block)(void) = ^&#123; NSLog(@&quot;Captured num: %d&quot;, num);&#125;;num = 20;block(); // 输出: Captured num: 10 引用捕获：对于__block修饰的变量和对象类型的变量，Block会捕获其引用。在Block内部可以修改__block修饰的变量的值，并且对象的引用计数会相应增加。123456__block int num = 10;void (^block)(void) = ^&#123; num++; NSLog(@&quot;Modified num: %d&quot;, num);&#125;;block(); // 输出: Modified num: 11 1.2 Block的结构体定义以下是简化后的Block结构体定义： 123456789101112131415struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; // 捕获的变量&#125;;struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;; isa：指向Block所属的类。 flags：包含一些标志位，用于描述Block的特性。 invoke：指向Block实际执行的函数。 descriptor：指向Block的描述信息结构体，包含Block的大小、复制和释放函数等。 二、Block的内存管理2.1 复制操作对不同类型的Block进行复制操作会有不同的效果： NSGlobalBlock：复制操作不会产生新的Block，仍然返回原来的Block。因为全局Block存储在全局数据区，其生命周期与程序的生命周期相同，不需要额外的内存管理。 NSStackBlock：复制操作会将栈Block复制到堆区，生成一个NSMallocBlock。这是因为栈Block存储在栈区，其生命周期受栈帧的限制，复制到堆区可以延长其生命周期。 NSMallocBlock：复制操作会增加引用计数。堆Block的内存管理遵循引用计数原则，当引用计数为0时，会自动释放内存。 2.2 释放操作当Block的引用计数为0时，会自动调用其dispose函数进行释放操作。对于捕获了对象的Block，dispose函数会对捕获的对象进行释放，减少对象的引用计数。 2.3 示例代码1234567891011121314151617181920212223242526272829303132@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; __block int num = 10; self.myBlock = ^&#123; num++; NSLog(@&quot;Modified num: %d&quot;, num); &#125;; &#125; return self;&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); // 输出: Modified num: 11 obj = nil; // 触发dealloc &#125; return 0;&#125; 在上述示例中，MyClass的myBlock属性使用了copy修饰符，这会将栈Block复制到堆区。当obj被置为nil时，MyClass的dealloc方法会被调用，同时myBlock的引用计数减为0，会自动释放内存。 三、Block的循环引用问题及解决方法3.1 循环引用的产生循环引用是指两个或多个对象之间相互持有对方的强引用，导致引用计数无法降为0，从而造成内存泄漏。在使用Block时，循环引用通常发生在Block捕获了包含它的对象，并且该对象又持有该Block的情况下。例如： 12345678910111213141516171819202122232425262728293031323334@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; self.myBlock = ^&#123; [self doSomething]; &#125;; &#125; return self;&#125;- (void)doSomething &#123; NSLog(@&quot;Doing something.&quot;);&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); obj = nil; // 不会触发dealloc &#125; return 0;&#125; 在上述示例中，MyClass的myBlock属性持有了一个Block，而该Block又捕获了self（即MyClass对象），形成了循环引用。当obj被置为nil时，由于循环引用的存在，MyClass对象的引用计数无法降为0，dealloc方法不会被调用，导致内存泄漏。 3.2 解决循环引用的方法3.2.1 使用__weak修饰符使用__weak修饰符可以创建一个弱引用，不会增加对象的引用计数。在Block内部使用弱引用可以避免循环引用。例如： 1234567891011121314151617181920212223242526272829303132333435@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; __weak typeof(self) weakSelf = self; self.myBlock = ^&#123; [weakSelf doSomething]; &#125;; &#125; return self;&#125;- (void)doSomething &#123; NSLog(@&quot;Doing something.&quot;);&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); obj = nil; // 触发dealloc &#125; return 0;&#125; 在上述示例中，使用__weak typeof(self) weakSelf = self;创建了一个弱引用weakSelf，并在Block内部使用weakSelf代替self，从而避免了循环引用。当obj被置为nil时，MyClass对象的引用计数降为0，dealloc方法会被调用。 3.2.2 使用__strong修饰符在某些情况下，使用__weak修饰符可能会导致在Block执行过程中对象被提前释放。可以在Block内部使用__strong修饰符创建一个强引用，确保在Block执行期间对象不会被释放。例如： 1234567891011121314151617181920212223242526272829303132333435363738@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; __weak typeof(self) weakSelf = self; self.myBlock = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomething]; &#125; &#125;; &#125; return self;&#125;- (void)doSomething &#123; NSLog(@&quot;Doing something.&quot;);&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); obj = nil; // 触发dealloc &#125; return 0;&#125; 在上述示例中，在Block内部使用__strong typeof(weakSelf) strongSelf = weakSelf;创建了一个强引用strongSelf，并在使用self之前先判断strongSelf是否为nil，确保在Block执行期间对象不会被释放。 四、总结Block是Objective - C中一个强大而灵活的特性，其底层原理涉及到结构体、内存管理和循环引用等多个方面。通过深入理解Block的底层结构和内存管理机制，开发者可以更好地使用Block，避免内存泄漏和循环引用问题。同时，掌握解决循环引用的方法可以确保代码的健壮性和稳定性。希望本文能帮助开发者更深入地探索Objective - C中Block的奥秘。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Block的基本使用","path":"/iOS/OC底层原理/探索Objective-C底层 - Block的基本使用/","content":"引言在Objective - C的世界里，Block是一项强大且独特的特性。它本质上是一种自包含的代码块，能够像对象一样被传递、存储和执行，这极大地增强了代码的灵活性和可复用性。Block在iOS和macOS开发中有着广泛的应用，比如在回调、排序、动画等场景中都能看到它的身影。本文将详细介绍Block的基本使用，帮助开发者更好地掌握这一重要特性。 一、Block的定义与基本语法1.1 什么是BlockBlock，也被称为闭包，它是一段可以在将来某个时间点执行的代码。Block可以捕获其所在上下文的变量，并且能够作为参数传递给其他函数或方法，也能作为返回值返回。 1.2 基本语法无参数无返回值的Block1234567// 定义一个无参数无返回值的Blockvoid (^simpleBlock)(void) = ^&#123; NSLog(@&quot;This is a simple block.&quot;);&#125;;// 调用BlocksimpleBlock(); 在上述代码中，void (^simpleBlock)(void) 定义了一个名为 simpleBlock 的Block，它没有参数，也没有返回值。^&#123; ... &#125; 是Block的实现部分，最后通过 simpleBlock(); 来调用这个Block。 有参数有返回值的Block12345678// 定义一个有两个整数参数并返回整数的Blockint (^addBlock)(int, int) = ^(int a, int b) &#123; return a + b;&#125;;// 调用Block并获取返回值int result = addBlock(3, 5);NSLog(@&quot;The result of addition is: %d&quot;, result); 这里，int (^addBlock)(int, int) 定义了一个名为 addBlock 的Block，它接受两个 int 类型的参数，并返回一个 int 类型的值。^(int a, int b) &#123; ... &#125; 是Block的实现，其中 (int a, int b) 是参数列表，return a + b; 是返回值。 二、Block捕获外部变量2.1 捕获局部变量Block可以捕获其所在上下文的局部变量，但需要注意的是，Block捕获的是局部变量的值，而不是变量本身。 12345678910int num = 10;void (^captureBlock)(void) = ^&#123; NSLog(@&quot;The captured number is: %d&quot;, num);&#125;;// 修改外部变量的值num = 20;// 调用BlockcaptureBlock(); // 输出: The captured number is: 10 在这个例子中，captureBlock 捕获了局部变量 num 的值，即使在Block定义之后修改了 num 的值，Block内部使用的仍然是捕获时的值。 2.2 捕获静态变量和全局变量捕获静态变量静态变量会被Block捕获其地址，因此在Block内部可以修改静态变量的值，并且修改会影响到外部的静态变量。 12345678static int staticNum = 10;void (^modifyStaticBlock)(void) = ^&#123; staticNum++; NSLog(@&quot;The modified static number is: %d&quot;, staticNum);&#125;;// 调用BlockmodifyStaticBlock(); // 输出: The modified static number is: 11 捕获全局变量全局变量不会被Block捕获，Block会直接使用全局变量。因此在Block内部修改全局变量的值会影响到外部。 12345678int globalNum = 10;void (^modifyGlobalBlock)(void) = ^&#123; globalNum++; NSLog(@&quot;The modified global number is: %d&quot;, globalNum);&#125;;// 调用BlockmodifyGlobalBlock(); // 输出: The modified global number is: 11 2.3 __block 修饰符如果想要在Block内部修改外部局部变量的值，可以使用 __block 修饰符。使用 __block 修饰的变量会被封装成一个结构体，Block捕获的是该结构体的地址。 12345678__block int blockNum = 10;void (^modifyBlockNum)(void) = ^&#123; blockNum++; NSLog(@&quot;The modified block number is: %d&quot;, blockNum);&#125;;// 调用BlockmodifyBlockNum(); // 输出: The modified block number is: 11 三、Block作为参数传递3.1 自定义函数中使用Block参数12345678910111213// 定义一个接受Block作为参数的函数void performOperation(int a, int b, int (^operation)(int, int)) &#123; int result = operation(a, b); NSLog(@&quot;The result of the operation is: %d&quot;, result);&#125;// 定义一个加法Blockint (^add)(int, int) = ^(int a, int b) &#123; return a + b;&#125;;// 调用函数并传递BlockperformOperation(3, 5, add); 在这个例子中，performOperation 函数接受两个整数和一个Block作为参数，在函数内部调用这个Block并输出结果。 3.2 在系统API中使用Block参数在iOS开发中，很多系统API都使用了Block作为参数，比如数组排序。 12345NSArray *numbers = @[@3, @1, @4, @2];NSArray *sortedNumbers = [numbers sortedArrayUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) &#123; return [obj1 compare:obj2];&#125;];NSLog(@&quot;The sorted numbers are: %@&quot;, sortedNumbers); 这里，sortedArrayUsingComparator: 方法接受一个Block作为参数，这个Block定义了排序的规则。 四、Block作为返回值12345678910111213// 定义一个返回Block的函数int (^returnBlock())(int, int) &#123; return ^(int a, int b) &#123; return a * b; &#125;;&#125;// 调用函数获取Blockint (^multiplyBlock)(int, int) = returnBlock();// 调用Blockint product = multiplyBlock(3, 5);NSLog(@&quot;The product is: %d&quot;, product); 在这个例子中，returnBlock 函数返回一个Block，这个Block实现了两个整数相乘的功能。 五、Block的内存管理5.1 Block的类型根据存储位置的不同，Block可以分为以下三种类型： NSGlobalBlock：当Block不捕获任何外部变量时，会被创建为全局Block，存储在全局数据区。1234void (^globalBlock)(void) = ^&#123; NSLog(@&quot;This is a global block.&quot;);&#125;;NSLog(@&quot;The class of globalBlock is: %@&quot;, [globalBlock class]); // 输出: __NSGlobalBlock__ NSStackBlock：当Block捕获了外部变量，但没有进行复制操作时，会被创建为栈Block，存储在栈区。栈Block在其所在的栈帧销毁后就会失效。12345int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;The number is: %d&quot;, num);&#125;;NSLog(@&quot;The class of stackBlock is: %@&quot;, [stackBlock class]); // 输出: __NSStackBlock__ NSMallocBlock：当对栈Block进行复制操作时，会将其复制到堆区，成为堆Block。堆Block的生命周期由开发者管理。123456int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;The number is: %d&quot;, num);&#125;;void (^heapBlock)(void) = [stackBlock copy];NSLog(@&quot;The class of heapBlock is: %@&quot;, [heapBlock class]); // 输出: __NSMallocBlock__ 5.2 复制和释放操作对不同类型的Block进行复制操作会有不同的效果： NSGlobalBlock：复制操作不会产生新的Block，仍然返回原来的Block。 NSStackBlock：复制操作会将栈Block复制到堆区，生成一个NSMallocBlock。 NSMallocBlock：复制操作会增加引用计数。 当Block的引用计数为0时，会自动调用其 dispose 函数进行释放操作。对于捕获了对象的Block，dispose 函数会对捕获的对象进行释放。 六、Block使用中的注意事项6.1 循环引用问题如果Block捕获了包含它的对象，并且该对象又持有该Block，就会产生循环引用。可以使用 __weak 修饰符来避免循环引用。 1234__weak typeof(self) weakSelf = self;self.block = ^&#123; [weakSelf doSomething];&#125;; 6.2 线程安全问题在多线程环境下使用Block时，需要注意线程安全问题。特别是在修改共享数据时，需要进行适当的同步操作。 七、总结Block是Objective - C中一个非常强大的特性，它为开发者提供了一种简洁、高效的方式来处理代码块。通过本文的介绍，我们了解了Block的基本定义、语法、变量捕获、作为参数和返回值的使用、内存管理以及使用中的注意事项。掌握这些基本使用方法，将有助于开发者在实际开发中更加灵活地运用Block，提高代码的质量和可维护性。希望本文能对开发者们有所帮助。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - KVC","path":"/iOS/OC底层原理/探索Objective-C底层 - KVC/","content":"引言在Objective - C开发中，Key - Value Coding（KVC）是一项强大且基础的特性。它提供了一种通过属性名（键）间接访问和修改对象属性的方式，而不是直接调用对象的存取方法。这种机制使得代码更加灵活和动态，在许多框架和库中被广泛使用。本文将深入探讨KVC的底层原理、使用方法、应用场景以及可能遇到的问题。 一、KVC基础概念与基本用法1.1 什么是KVCKVC是一种使用字符串（键）来间接访问和修改对象属性的机制。它允许开发者在运行时通过键来获取和设置对象的属性值，而不需要直接调用对象的存取方法。KVC的核心在于NSKeyValueCoding协议，该协议定义了一系列方法，如valueForKey:、setValue:forKey:等，任何遵循该协议的类都可以使用KVC。 1.2 基本用法示例12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; // 使用KVC设置属性值 [person setValue:@&quot;John&quot; forKey:@&quot;name&quot;]; [person setValue:@25 forKey:@&quot;age&quot;]; // 使用KVC获取属性值 NSString *name = [person valueForKey:@&quot;name&quot;]; NSNumber *age = [person valueForKey:@&quot;age&quot;]; NSLog(@&quot;Name: %@, Age: %@&quot;, name, age); &#125; return 0;&#125; 在上述示例中，我们创建了一个Person类，通过setValue:forKey:方法设置属性值，通过valueForKey:方法获取属性值。 二、KVC的底层实现原理2.1 setValue:forKey:方法的查找与赋值过程当调用setValue:forKey:方法时，Objective - C运行时会按照以下步骤进行查找和赋值： 查找设置方法：首先会查找以set&lt;Key&gt;:命名的方法，如果找到则调用该方法进行赋值，如果没找到，则查找以_set&lt;Key&gt;:命名的方法。例如，对于键name，会查找setName:方法。 查找实例变量：如果没有找到设置方法，会查找名为_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的实例变量，直接对其进行赋值。 **调用setValue:forUndefinedKey:**：如果以上步骤都没有找到合适的方法或实例变量，会调用setValue:forUndefinedKey:方法，默认情况下该方法会抛出异常。 2.2 valueForKey:方法的查找与取值过程当调用valueForKey:方法时，运行时会按照以下步骤进行查找和取值： 查找获取方法：首先会查找以&lt;key&gt;、get&lt;Key&gt;、is&lt;Key&gt;、_&lt;Key&gt;命名的方法，如果找到则调用该方法获取值。 查找实例变量：如果没有找到获取方法，会查找名为_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的实例变量，直接获取其值。 **调用valueForUndefinedKey:**：如果以上步骤都没有找到合适的方法或实例变量，会调用valueForUndefinedKey:方法，默认情况下该方法会抛出异常。 三、KVC的高级用法3.1 访问嵌套对象属性KVC支持通过点语法访问嵌套对象的属性。例如： 1234567891011121314151617181920212223242526@interface Address : NSObject@property (nonatomic, copy) NSString *city;@end@implementation Address@end@interface Person : NSObject@property (nonatomic, strong) Address *address;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; Address *address = [[Address alloc] init]; address.city = @&quot;New York&quot;; person.address = address; NSString *city = [person valueForKeyPath:@&quot;address.city&quot;]; NSLog(@&quot;City: %@&quot;, city); &#125; return 0;&#125; 在上述示例中，我们通过valueForKeyPath:方法访问了Person对象中address属性的city属性。 3.2 集合操作KVC还支持对集合对象进行操作，如求和、平均值、最大值、最小值等。例如： 1234567NSArray *numbers = @[@1, @2, @3, @4, @5];NSNumber *sum = [numbers valueForKeyPath:@&quot;@sum.self&quot;];NSNumber *average = [numbers valueForKeyPath:@&quot;@avg.self&quot;];NSNumber *max = [numbers valueForKeyPath:@&quot;@max.self&quot;];NSNumber *min = [numbers valueForKeyPath:@&quot;@min.self&quot;];NSLog(@&quot;Sum: %@, Average: %@, Max: %@, Min: %@&quot;, sum, average, max, min); 在上述示例中，我们使用了@sum、@avg、@max、@min等集合操作符对数组进行操作。 四、KVC的应用场景4.1 数据模型与视图的绑定在iOS开发中，KVC可以用于将数据模型的属性与视图的属性进行绑定。例如，将一个User对象的name属性绑定到一个UILabel的text属性： 1234567891011121314@interface User : NSObject@property (nonatomic, copy) NSString *name;@end@implementation User@end- (void)bindDataToView &#123; User *user = [[User alloc] init]; user.name = @&quot;Alice&quot;; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 30)]; [label setValue:user.name forKey:@&quot;text&quot;]; [self.view addSubview:label];&#125; 4.2 字典与模型的转换KVC可以方便地将字典中的数据映射到对象的属性上，实现字典与模型的转换。例如： 1234567891011@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@implementation Person@endNSDictionary *personDict = @&#123;@&quot;name&quot;: @&quot;Bob&quot;, @&quot;age&quot;: @30&#125;;Person *person = [[Person alloc] init];[person setValuesForKeysWithDictionary:personDict]; 五、KVC可能遇到的问题及解决方案5.1 键不存在的问题当使用setValue:forKey:或valueForKey:方法时，如果键不存在，默认会抛出异常。可以通过重写setValue:forUndefinedKey:和valueForUndefinedKey:方法来避免异常的抛出： 123456789101112@implementation Person- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; // 处理键不存在的情况 NSLog(@&quot;Undefined key: %@&quot;, key);&#125;- (id)valueForUndefinedKey:(NSString *)key &#123; // 处理键不存在的情况 NSLog(@&quot;Undefined key: %@&quot;, key); return nil;&#125;@end 5.2 类型不匹配的问题当使用KVC设置属性值时，如果值的类型与属性的类型不匹配，可能会导致运行时错误。可以在设置值之前进行类型检查和转换： 1234567- (void)setAgeValue:(id)value &#123; if ([value isKindOfClass:[NSNumber class]]) &#123; self.age = [value integerValue]; &#125; else if ([value isKindOfClass:[NSString class]]) &#123; self.age = [value integerValue]; &#125;&#125; 六、总结KVC是Objective - C中一项非常重要的特性，它提供了一种灵活、动态的方式来访问和修改对象的属性。通过深入了解KVC的底层原理、高级用法和应用场景，开发者可以更好地利用这一特性来提高代码的可维护性和灵活性。同时，在使用KVC时，也需要注意可能遇到的问题，并采取相应的解决方案。 希望本文能够帮助你更深入地理解Objective - C中的KVC机制，在实际开发中更加得心应手地使用它。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - KVO","path":"/iOS/OC底层原理/探索Objective-C底层 - KVO/","content":"引言Key-Value Observing（KVO）是Objective-C语言中实现数据变化监听的核心机制。其底层通过动态生成子类、修改isa指针、重写setter方法等技术实现。本文将从以下维度深入剖析KVO的运行机制： 一、KVO的基础认知1.1 基本用法12345678910111213// 注册观察者[self addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];// 实现观察方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; // 处理属性变化&#125;// 移除观察者[self removeObserver:self forKeyPath:@&quot;name&quot;]; 1.2 核心特性 自动通知：属性变化时自动触发回调 支持嵌套观察：可监听对象的属性链 两种触发方式：自动触发（默认）和手动触发 性能优化：基于isa指针的动态子类实现 二、KVO的底层实现原理2.1 isa指针的动态修改123456789101112131415// 原始对象@interface Person : NSObject@property (nonatomic, copy) NSString *name;@end// 被KVO监听后生成的子类@implementation NSKVONotifying_Person- (void)setName:(NSString *)name &#123; // 调用父类setter [super setName:name]; // 触发观察通知 [self willChangeValueForKey:@&quot;name&quot;]; [self didChangeValueForKey:@&quot;name&quot;];&#125;@end 2.2 动态子类生成流程 注册观察者时生成子类 子类继承自原始类 子类重写所有被观察属性的setter方法 子类isa指针指向该动态子类 2.3 关键结构体12345678// NSKeyValueObserver结构体struct NSKeyValueObserver &#123; Class _cls; struct NSKeyValueObserver *next; NSString *keyPath; SEL callbackSEL; // 其他字段...&#125;; 三、KVO的触发机制3.1 自动触发流程 调用属性setter方法 子类setter方法调用willChangeValueForKey: 调用父类setter方法更新属性 调用didChangeValueForKey:触发通知 3.2 手动触发方式123[self willChangeValueForKey:@&quot;age&quot;];self-&gt;_age = newValue;[self didChangeValueForKey:@&quot;age&quot;]; 3.3 通知传递路径1setter方法 → NSKVONotifying子类 → Foundation → 观察者回调 四、KVO的内存管理4.1 观察者注册与移除1234// 正确移除方式- (void)dealloc &#123; [self removeObserver:self forKeyPath:@&quot;name&quot;];&#125; 4.2 循环引用问题123// 错误示例：导致循环引用self.observer = [[Observer alloc] init];[self.observer addObserver:self forKeyPath:@&quot;value&quot; ...]; 4.3 弱引用管理12345// 使用弱引用来避免循环__weak typeof(self) weakSelf = self;self.observer = [[Observer alloc] initWithBlock:^(id value) &#123; [weakSelf handleValue:value];&#125;]; 五、KVO与KVC的关系5.1 依赖关系 KVO基于KVC实现属性访问 KVC提供valueForKey:和setValue:forKey:方法 KVO通过KVC修改属性值 5.2 核心方法1234567// KVC设置属性[self setValue:@&quot;newName&quot; forKey:@&quot;name&quot;];// KVO自动触发通知[self willChangeValueForKey:@&quot;name&quot;];[self setPrimitiveValue:@&quot;newName&quot; forKey:@&quot;name&quot;];[self didChangeValueForKey:@&quot;name&quot;]; 六、KVO的高级应用6.1 监听集合属性1234567891011// 监听数组变化[self addObserver:self forKeyPath:@&quot;friends&quot; options:NSKeyValueObservingOptionNew context:nil];// 处理数组变化- (void)observeValueForKeyPath:(NSString *)keyPath ... &#123; if ([keyPath isEqualToString:@&quot;friends&quot;]) &#123; NSArray *oldFriends = change[NSKeyValueChangeOldKey]; NSArray *newFriends = change[NSKeyValueChangeNewKey]; // 处理数组变更 &#125;&#125; 6.2 深度监听12// 监听嵌套对象属性[self addObserver:self forKeyPath:@&quot;user.name&quot; options:NSKeyValueObservingOptionNew context:nil]; 6.3 自定义通知行为1234// 自定义通知选项[self addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; 七、KVO的常见问题7.1 通知未触发 未正确调用setter方法 使用setValue:forKey:时未遵循KVC规范 未注册观察者或错误移除观察者 7.2 性能问题 过度使用KVO导致大量通知回调 监听深层嵌套对象引发性能开销 动态子类生成带来的内存消耗 7.3 线程安全问题 跨线程修改属性导致通知顺序混乱 观察者回调在非主线程执行 八、KVO与其他技术的对比8.1 与Delegate的对比 特性 KVO Delegate 耦合度 低 高 扩展性 支持多个观察者 一对一关系 灵活性 自动触发 需手动调用 调试难度 较高 较低 8.2 与Notification的对比 特性 KVO Notification 监听范围 特定属性 全局事件 性能 较高 较低 内存管理 需手动移除观察者 自动释放 数据传递 直接获取变更值 通过字典传递 九、总结KVO的本质是： 基于运行时的动态子类机制 isa指针的动态修改 属性变更的自动通知系统 掌握KVO底层原理能帮助开发者： 正确使用KVO避免内存泄漏 优化属性监听逻辑 解决复杂数据同步问题 理解iOS框架的数据绑定机制 建议通过以下方式深入学习： 分析objc源码中的NSKeyValueObserver结构体 使用LLDB调试动态子类生成过程 研究NSKeyValueChange枚举的使用场景 实现自定义KVO框架 附录：关键技术点 isa-swizzling：修改对象的isa指针指向动态子类 NSKVONotifying：自动生成的子类前缀 willChangeValueForKey:&#x2F;**didChangeValueForKey:**：触发通知的核心方法 NSKeyValueObservingOption：通知选项枚举 KVO调试命令：po [object class]查看动态子类 通过对KVO底层原理的深入探索，我们能更高效地利用这一强大机制，构建出响应式强、可维护性高的iOS应用。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Category","path":"/iOS/OC底层原理/探索Objective-C底层 - Category/","content":"引言Category（类别）是Objective-C语言的重要特性之一，允许在不修改原有类的情况下为其添加方法。理解Category的底层实现原理，对于掌握OC动态特性、优化代码结构至关重要。本文将从以下维度展开深入分析： 一、Category的基础认知1.1 基本用法1234567891011// NSString+Additions.h@interface NSString (Additions)- (NSString *)reverseString;@end// NSString+Additions.m@implementation NSString (Additions)- (NSString *)reverseString &#123; // 实现字符串反转&#125;@end 1.2 核心特性 动态扩展：无需修改原类即可添加方法 模块化设计：将类的功能拆分成多个文件 方法覆盖：Category的方法会覆盖原类方法 无实例变量：不能直接添加实例变量 二、Category的底层结构2.1 objc_category结构体123456789// objc-runtime-new.h中的定义struct category_t &#123; const char *name; // 类名 classref_t cls; // 类引用 struct method_list_t *instanceMethods; // 实例方法 struct method_list_t *classMethods; // 类方法 struct protocol_list_t *protocols; // 协议 struct property_list_t *instanceProperties; // 实例属性&#125;; 2.2 编译产物分析通过clang -rewrite-objc生成C++代码： 12345678910111213141516171819202122// 原始OC代码@interface NSString (Additions)@property (nonatomic, copy) NSString *desc;- (void)print;@end// 转换后的C++代码static struct /*_category_t*/ &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties;&#125; _OBJC_$_CATEGORY_NSString_$_Additions __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123; &quot;NSString&quot;, 0, // &amp;OBJC_CLASS_$_NSString, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_NSString_$_Additions, 0, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_NSString_$_Additions&#125;; 三、Category的加载与合并过程3.1 加载流程 编译阶段生成category_t结构体 链接阶段合并到Mach-O文件的__objc_const段 运行时通过_read_images函数处理所有category 3.2 方法合并机制123456789101112131415161718// objc-runtime-new.mm中的核心逻辑void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses) &#123; // 处理所有category for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 合并方法、协议、属性 if (cat-&gt;instanceMethods) &#123; addUnattachedCategoryForClass(cls, cat); &#125; &#125; &#125; // 最终合并到类结构中 attachCategories(..., cats_list, cats_count);&#125; 3.3 方法覆盖优先级 当前类方法 Category方法（后编译的Category优先） 父类方法 四、Category的动态行为4.1 方法决议1234567+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(dynamicMethod)) &#123; class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 4.2 消息转发123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if ([self respondsToSelector:aSelector]) &#123; return self; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 五、Category的内存管理5.1 关联对象（Associated Object）12345// 添加关联对象objc_setAssociatedObject(self, &amp;AssociatedKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);// 获取关联对象id value = objc_getAssociatedObject(self, &amp;AssociatedKey); 5.2 内存泄漏场景12// 错误用法：导致循环引用objc_setAssociatedObject(self, &amp;kAssociatedKey, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 六、Category与其他技术的对比6.1 与继承的对比 特性 Category 继承 代码修改 无需修改原类 需要创建子类 方法覆盖 可覆盖原类方法 需重写父类方法 实例变量 不可添加 可添加新实例变量 编译依赖 动态加载 静态依赖 6.2 与Extension的对比 特性 Category Extension 声明位置 .h文件 .m文件 方法实现 必须在.m文件 可隐式实现 访问控制 公开方法 通常为私有方法 作用域 全局可见 仅限当前类 七、Category的应用场景7.1 模块化开发将类的不同功能拆分到多个Category： 1234567@interface UIViewController (Network)- (void)fetchData;@end@interface UIViewController (UI)- (void)updateUI;@end 7.2 修复系统类缺陷为NSString添加安全处理方法： 123@interface NSString (Safety)- (NSString *)safeStringByTrimmingWhitespace;@end 7.3 实现AOP通过Category进行方法交换： 123456789101112@implementation UIViewController (AOP)+ (void)load &#123; Method originalMethod = class_getInstanceMethod(self, @selector(viewDidLoad)); Method swizzledMethod = class_getInstanceMethod(self, @selector(aop_viewDidLoad)); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;- (void)aop_viewDidLoad &#123; [self aop_viewDidLoad]; NSLog(@&quot;View did load&quot;);&#125;@end 八、Category的常见问题8.1 方法覆盖导致的问题12345678// 两个Category声明同名方法@interface NSString (A)- (void)log;@end@interface NSString (B)- (void)log;@end 8.2 内存泄漏12// 未正确释放关联对象objc_setAssociatedObject(self, &amp;key, [NSObject new], OBJC_ASSOCIATION_RETAIN_NONATOMIC); 8.3 二进制兼容性问题123// 跨版本添加方法导致崩溃NSString *str = @&quot;test&quot;;[str newMethod]; // 旧版本不存在该方法 九、总结Category的本质是： 运行时动态扩展机制 方法集合的动态合并 OC语言动态特性的重要体现 掌握Category底层原理能帮助开发者： 合理设计代码结构 避免方法冲突 正确使用关联对象 实现高级编程技巧（如AOP） 建议通过以下方式深入学习： 分析objc源码中的_read_images函数 使用class-dump查看Category结构 通过LLDB调试方法合并过程 研究关联对象的内存管理策略 附录：关键技术点 objc_category结构体：存储Category元数据 方法合并流程：_read_images -&gt; attachCategories 关联对象API：objc_setAssociatedObject&#x2F;objc_getAssociatedObject 编译命令：clang -rewrite-objc -fobjc-arc YourFile.m 调试工具：class-dump, LLDB, Dyld 通过对Category底层原理的深入探索，我们能更高效地利用这一强大特性，写出结构清晰、扩展性强的iOS代码。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - OC对象的本质","path":"/iOS/OC底层原理/探索Objective-C底层 - OC对象的本质/","content":"引言Objective-C（OC）对象是iOS开发的核心抽象单元。理解OC对象的本质需要深入剖析其底层结构、内存布局以及运行时行为。本文将从以下维度展开详细分析： 一、OC对象的底层结构1.1 objc_object结构体OC对象在底层由objc_object结构体表示： 1234// objc.h中的定义struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; isa指针：指向对象的类（Class） 内存布局：对象实例变量存储在isa指针之后的内存区域 1.2 类对象的结构类对象由objc_class结构体构成： 12345struct objc_class : objc_object &#123; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 类数据存储&#125;; 1.3 实例变量的存储123456789101112@interface Person : NSObject &#123; NSString *_name; // 实例变量 int _age;&#125;@end// 底层内存布局struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; // 继承自NSObject NSString *_name; int _age;&#125;; 二、isa指针的深度解析2.1 isa指针的作用 指向对象的类（Class） 决定对象的行为和属性 运行时消息传递的核心依据 2.2 isa指针的优化 non-pointer isa（64位系统）： 存储类指针 包含对象的引用计数 标记对象是否被释放 标记是否为弱引用对象 2.3 isa指针的调试通过LLDB可以查看isa指针的值： 12345(lldb) po [person class]Person(lldb) p/x person-&gt;isa(unsigned long) $0 = 0x00000001000025d8 三、类与元类的层级关系3.1 类对象的构成 实例对象：通过alloc创建的对象 类对象：存储实例方法、属性、协议 元类对象：存储类方法 3.2 类的继承体系1NSObject ← Person ← Student 3.3 根元类 NSObject的元类称为根元类 根元类的isa指针指向自身 形成类层级的闭环结构 四、对象的创建与销毁4.1 对象创建流程 调用alloc分配内存 初始化isa指针 调用init方法 关联对象处理 4.2 内存分配机制 zone：早期用于管理对象内存 tls：线程本地存储 散列表：快速查找可用内存块 4.3 对象销毁流程 调用dealloc方法 释放实例变量 调用super dealloc 内存回收 五、对象的内存管理5.1 引用计数机制12345678- (void)retain &#123; _Nonnull self; return ((id)self)-&gt;rootRetain();&#125;- (oneway void)release &#123; ((id)self)-&gt;rootRelease();&#125; 5.2 ARC的底层实现 __strong：强引用 __weak：弱引用 __unsafe_unretained：不安全的非保留引用 5.3 自动释放池123@autoreleasepool &#123; // 自动释放对象&#125; 六、OC对象的高级特性6.1 关联对象（Associated Object）12objc_setAssociatedObject(self, &amp;key, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(self, &amp;key); 6.2 动态类型检查123if ([object isKindOfClass:[NSString class]]) &#123; // 类型检查&#125; 6.3 方法替换123Method originalMethod = class_getInstanceMethod([self class], @selector(originalMethod));Method swizzledMethod = class_getInstanceMethod([self class], @selector(swizzledMethod));method_exchangeImplementations(originalMethod, swizzledMethod); 七、OC对象的调试技巧7.1 使用class-dump分析类结构1class-dump -H YourApp -o Headers 7.2 查看对象内存布局1po malloc_size((__bridge const void *)(object)) 7.3 分析isa指针12(lldb) p/x object-&gt;isa(lldb) p (Class)object-&gt;isa 八、总结OC对象的本质是： 结构体实例：由isa指针和实例变量构成 动态实体：行为由运行时决定 内存管理单元：遵循引用计数规则 掌握对象的底层原理可以帮助我们： 优化内存使用 解决野指针问题 实现高级编程技巧（如AOP） 深入理解iOS框架设计 建议通过以下方式深入学习： 阅读Apple开源objc4源码 使用Clang进行代码转换 通过LLDB调试对象生命周期 分析内存分配工具（如Heapshot） 附录：关键术语对照表 术语 说明 objc_object 对象的底层结构体 isa指针 指向类的指针 元类 存储类方法的类 方法缓存 提升消息传递效率 关联对象 为类添加动态属性 自动释放池 管理临时对象的内存 引用计数 内存管理的核心机制 通过对OC对象本质的深入探究，我们能够更好地理解iOS系统的运行机制，写出更高效、健壮的代码。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层","path":"/iOS/OC底层原理/探索 Objective - C 底层 - 系列博客前言/","content":"系列博客结构与核心内容本系列博客将系统梳理 Objective - C 底层核心知识体系，涵盖语言特性、运行机制到工程实践的全维度探索。以下是内容框架： 一、语言本质与对象系统 易忘图 动态语言特性与消息传递机制 Objective - C 与 C&#x2F;C++ 的关联与差异 OC 对象的本质 isa 指针与类结构 对象内存布局与对齐规则 Category 与 Extension 分类加载机制与方法覆盖原理 扩展（Extension）与分类的本质区别 二、高级特性解析 KVO 与 KVC KVO 的实现原理与 isa - swizzling KVC 的底层查找逻辑与异常处理 Block 的深度探索 Block 的三种类型与内存管理 闭包捕获变量的底层实现机制 三、Runtime 核心机制 Runtime（一） 类与元类的关系图谱 方法调用的消息转发流程 Runtime（二） 动态方法解析与消息转发 关联对象的实现原理 Runtime 应用实践 方法交换（Method Swizzling） 字典转模型的底层实现 四、运行时与多线程 Runloop 底层原理 Runloop 与线程的绑定关系 Runloop 的五种模式与状态切换 Runloop 应用场景 性能监控与卡顿优化 常驻线程的实现方案 多线程技术栈 GCD 核心概念与队列管理 线程锁的实现与选择策略 常见多线程模式（如生产者 - 消费者） 五、内存与性能优化 内存管理机制 引用计数与 Side Tables AutoreleasePool 的底层实现 Tagged Pointer 的内存优化策略 性能优化方案 卡顿监测与 FPS 优化 启动优化与瘦身方案 网络与渲染性能优化实践 六、架构设计与开发统计 架构设计模式 MVC&#x2F;MVVM&#x2F;MVP&#x2F;VIPER 对比与实践 组件化与模块化设计方案 开发统计方案 崩溃分析（Bugly 原理与符号表上传） 用户行为统计（友盟埋点与操作步骤分析）","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - OC的本质","path":"/iOS/OC底层原理/探索Objective-C底层 - OC的本质/","content":"引言Objective-C（简称OC）作为iOS开发的核心语言，其底层实现机制一直是开发者进阶的必经之路。理解OC的本质不仅能帮助我们写出更高效的代码，还能深入掌握iOS运行时机制、内存管理等底层逻辑。本文将从以下几个维度展开分析： 一、OC的运行时机制（Objective-C Runtime）OC是一门动态语言，其核心特性依赖于objc库实现。运行时机制在程序运行时动态处理类、对象、方法调用等操作，主要包含以下核心组件： 1.1 objc库的核心结构123456789// objc.h中定义的核心结构体struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; // 其他字段...&#125;;struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 1.2 动态语言特性 动态类型（Dynamic Typing）：对象类型检查在运行时完成 动态绑定（Dynamic Binding）：方法调用与实现的绑定在运行时确定 动态加载（Dynamic Loading）：程序运行时可加载新代码 二、对象与类的底层结构2.1 对象的本质OC对象在底层由objc_object结构体表示： 123struct objc_object &#123; Class isa;&#125;; isa指针：指向对象的类（Class） 类对象：存储方法列表、属性列表等元数据 2.2 类的结构类对象由objc_class结构体构成： 123456struct objc_class : objc_object &#123; // Class ISA; 继承自objc_object Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 类数据&#125;; 2.3 元类（Meta Class） 每个类都有对应的元类 元类存储类方法（Class Method） 根元类（Root Meta Class）的isa指针指向自身 三、消息传递与转发机制3.1 消息传递（Message Passing）OC的方法调用本质是消息传递： 12345// OC代码[person run];// 底层实现objc_msgSend(person, @selector(run)); 3.2 SEL与IMP SEL（Selector）：方法选择器，唯一标识一个方法 IMP（Implementation）：方法的具体实现，指向函数指针 3.3 动态方法决议1234567+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(run)) &#123; class_addMethod(self, sel, (IMP)runFunction, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 3.4 消息转发 快速转发（Fast Forwarding） 标准转发（Standard Forwarding） 完整转发流程示例：1234567891011- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return otherObject;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; // 返回方法签名&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // 处理未识别的消息&#125; 四、内存管理机制4.1 引用计数（Reference Counting） retainCount：对象当前的引用计数 retain&#x2F;release&#x2F;autorelease：手动管理内存 autoreleasepool：自动释放池实现原理 4.2 ARC的底层实现 LLVM编译器自动插入内存管理代码 __strong&#x2F;__weak&#x2F;__unsafe_unretained修饰符 弱引用表（Side Table）的实现机制 4.3 僵尸对象（Zombie Object） 调试工具：NSZombieEnabled 原理：对象释放后变为僵尸对象，防止野指针 五、OC与C++的关联5.1 OC的动态特性与C++的对比 特性 OC C++ 多态 动态绑定 静态绑定 内存管理 ARC&#x2F;MRC 手动管理 类型检查 运行时 编译时 5.2 OC类的C++实现通过clang -rewrite-objc命令可以将OC代码转换为C++： 12345678910// OC代码@interface Person : NSObject@property (nonatomic, copy) NSString *name;@end// 转换后的C++代码struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;; 六、总结OC的本质是基于C语言的动态语言扩展，其底层实现涉及： 对象与类的结构设计 消息传递与转发机制 内存管理策略 动态语言特性 掌握这些底层原理能帮助开发者： 写出更高效、健壮的代码 深入理解iOS框架设计思想 解决复杂的内存问题 实现高级特性（如AOP、热更新） 建议开发者通过以下方式深入学习： 阅读Apple官方文档《Objective-C Runtime Programming Guide》 分析objc源码（Apple开源代码） 使用class-dump分析二进制文件 通过LLDB调试运行时行为 附录：常用工具与命令 clang -rewrite-objc：将OC代码转换为C++ class-dump：解析二进制文件的类结构 malloc_history：追踪内存分配 NSZombieEnabled：调试僵尸对象 objc_msgsend：手动发送消息 通过深入理解OC的底层原理，我们能真正掌握iOS开发的核心逻辑，写出更优秀的应用程序。","categories":["iOS","Objective-C底层原理"]}]