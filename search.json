[{"title":"12种Flutter开发工具推荐","path":"/2024/03/10/12种Flutter开发工具推荐/","content":"Panache：Flutter material 主题编辑器 Panache 是Flutter 的开源、基于浏览器的 material 主题编辑器，可让你为 Flutter 应用创建美观且可高度自定义的主题。使用这个 Flutter 开发工具，你可以自定义组件和小部件的颜色，并将主题导出为 theme.dart 文件。 项目地址 https://rxlabz.github.io/panache Supernova：Flutter 设计到代码工具 Supernova 是一款功能强大的设计到代码工具，可将你的 Sketch 和 Adobe XD 移动设计转换为适用于 iOS、Android、ReactNative，当然还有 Flutter 的原生前端代码。导入应用设计时，Supernova 还可以处理资产创建和重复数据删除工作，并允许你编辑设计并实时查看代码更改。Supernova 目前仅提供了 macOS 应用，但很快就会发布云端版本。 项目地址 https://supernova.io/ Codemagic：FlutterCI&#x2F;CD 工具 Codemagic 是 Nevercode 创建的第一个专注于 Flutter 的 CI&#x2F;CD 工具。它可以轻松识别你的 Flutter 应用，并与所有你喜欢的工具集成，以自动化你的整个构建、测试和发布流程。Codemagic 还相当实惠，每月提供 500 个免费的 Mac mini 构建分钟，以及按需付费的额外分钟计费方案。 项目地址 https://codemagic.io/ Sylph：Flutter 设备农场测试工具 Sylph 是由 Maurice McCabe 创建的开源命令行工具，本质上是 AWS 设备农场的包装器。借助 Sylph，你可以在 AWS 设备农场中一次在数百个真实的 iOS 和 Android 设备上运行 Flutter 集成和端到端测试。 项目地址 https://pub.dev/packages/sylph Amplitude：Flutter 应用内分析工具 Amplitude 是一种著名的应用内分析工具，可帮助你了解用户如何与你的应用交互。现在，它也是一种流行的 Flutter 开发工具，可以帮助你跟踪和监视各种数据，并与所有流行的移动应用开发流程集成，从而使你能够根据数据采取行动。 项目地址 https://github.com/mmcc007 Count.ly：Flutter 应用内分析工具 Count.ly 是一个开源分析工具，专注于数据的安全性和隐私性。Count.ly 的免费版本允许你跟踪显示应用性能的基本指标和 KPI。但它们还提供付费版本，其中包含一组更广泛的指标以及其他许多功能。Count.ly 的付费版本可以在内部或云中托管，并提供额外的特性标志、A&#x2F;B 测试和推送通知功能。 项目地址 https://count.ly/ AppsFlyer：Flutter 归因工具 AppsFlyer 是一种移动归因工具，可帮助你了解用户的来源并了解应用安装量和特定营销活动之间的联系。它提供了一个仪表板，可以帮助你了解营销渠道和广告系列在各种设备和应用上的效果如何，并与 6000 多家媒体合作伙伴集成。 项目地址 https://www.appsflyer.com/ Instabug：Flutter 应用内错误报告、崩溃报告和调查工具 Instabug 是一个用于移动应用实时上下文洞察的平台，可用于应用内错误报告、崩溃报告、调查和功能请求。将 Instabug 的 Flutter SDK 集成到你的应用中后，你就可以允许用户在不离开应用的情况下报告他们遇到的错误。Instabug 可以捕获截图，支持用户注释和模糊，并能捕获全面的日志和设备详细信息，以帮助你更快地发现和解决问题。崩溃报告也会与你定位确切问题所需的所有日志和设备详细信息一起发送。你还可以向你的用户发送定向调查，以更好地了解用户操作背后的原因，并允许用户请求功能，对请求进行投票。 项目地址 https://instabug.com/?src=InstabugBlog&amp;mdm=internal&amp;term=flutter_tools Airship：Flutter 应用内消息工具 Airship 是一个客户参与平台，允许你向用户发送推送通知和应用内消息，以吸引他们并改善他们的转化率。它还允许你创建一个应用内消息中心，该中心创建一个应用内收件箱，你可以在其中向用户发送持久消息。 项目地址 https://www.airship.com/ WonderPush：Fluttet 推送通知工具 WonderPush 是另一个通知推送和应用内消息传递工具，你可以在 Flutter 应用中使用该工具来提高用户的参与度。它以低廉的价格提供了许多强大的功能，包括细分和定位、地理位置定位以及 A&#x2F;B 测试。 项目地址 https://www.wonderpush.com/ Revenue Cat：Flutter 应用内购买工具 RevenueCat 是一款应用内购买和订阅管理工具，支持 iOS、Android 和 Stripe。使用这一工具，你可以轻松创建和管理应用内购买和订阅模块，它可以完成所有繁重的工作并处理计费基础架构。它还支持开箱即用的 LTV、MRR、客户流失率等指标测量，来跟踪你的应用成绩。 项目地址 https://www.revenuecat.com/ Square：Flutter 应用内支付工具 Square 是一个应用内支付管理平台，可为你处理支付操作带来的所有复杂性。借助其 Flutter SDK，你可以通过易于定制的 UI 接收应用内付款，该 UI 支持数字钱包和存储卡以进行快速结帐。 项目地址 https://www.revenuecat.com/","categories":["Resource","Flutter"]},{"title":"iOS面试题","path":"/2024/03/06/iOS面试题/","content":"1、一个NSObject对象占用多少内存？回答：系统分配了16个字节给NSObject对象（通过malloc_size函数获得）（因为内存对齐，必须是16的倍数）但NSObject对象内部只有一个isa指针，只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 2、对象的isa指针指向哪里？回答：instance对象的isa指针指向class对象class对象的isa指针指向meta-class对象meta-class对象的isa指针指向基类的meta-class对象 3、OC的类信息存放在哪里？回答：对象方法、属性、成员变量、协议信息，存放在class对象中类方法，存放在meta-class对象中成员变量的具体值，存放在instance对象中 4、iOS用什么方式实现对一个对象的KVO？（KVO的本质是什么？）回答：利用RuntimeAPI生成一个子类NSKVOXXXNotifying，并且让instance对象的isa指针指向这个全新的子类当修改instance对象的属性时，会调用Foundation框架中的_NSSetXXXValueAndNotify函数（重写了setter方法）：willChangeValueForKey:父类原来的setter方法didChangeValueForKey:内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context） 5、如何手动触发KVO？回答：手动去调用willChangeValueForKey:和didChangeValueForKey:的方法 6、直接修改成员变量会触发KVO吗？回答：不会，因为修改成员变量并不会调用setter方法 7、通过KVC修改属性会触发KVO吗？回答：会触发KVO，通过KVC修改相当于手动调用了willChangeValueForKey:和didChangeValueForKey: 8、KVC的赋值和取值的过程是怎样的？原理是什么？回答：赋值：取值： 9、Category的使用场合是什么？回答：类包含了很多个方法实现，而这些方法需要不同团队的成员来实现当你在使用基础类库中的类时，你不想继承这些类，而只是想添加一些方法的时候 10、Category的实现原理回答：Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中） 11、Category和Class Extension的区别是什么？回答：Class Extension是在程序编译的时候，它的数据就已经包含在类信息中了Category在底层是以结构体的形式存在，在程序运行的时候，才会将数据合并到类信息中 12、Category中有load方法吗？load方法是什么时候调用的？load方法能继承吗？回答：有load方法load方法在runtime加载类、分类的时候调用，而且只调用一次load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用 13、load、initialize方法的区别是什么？它们在category中的调用顺序？以及出现继承时它们之间的调用过程？回答：load方法load方法会在Runtime加载类、分类的时候调用每个类、分类的load，在程序运行的过程中只调用一次调用顺序：先调用类的load按照编译的先后顺序调用（先编译，先调用）调用子类的load之前会先调用父类的load再调用分类的load按照编译先后顺序调用（先编译，先调用）load方法系统调用和主动调用的区别系统调用load是直接找到类或分类中的方法的内存地址直接调用主动调用load是通过消息机制来发送消息的，会在对应的消息列表里按顺序遍历一层层查找，找到就调用initialize方法initialize方法会在类第一次接收到消息时调用调用顺序：先调用父类的initialize，再调用子类的initialize，每个类只会初始化1次（如果子类没有实现initialize方法，会调用父类的initialize方法，所以父类的initialize方法可能会调用多次）initialize的调用是通过消息机制来发送消息的 14、Category能否添加成员变量？如果可以，如何给Category添加成员变量？回答：不能直接给Category添加成员变量，但是可以简介实现Category有成员变量的效果——关联对象"},{"title":"iOS易忘图","path":"/2024/03/05/易忘图/","content":"isa和superclass指针 KVCsetValue:forKey:的原理 KVCvalueForKey:的原理 @encode&#96;字符串编码 类的底层结构 常见的深浅拷贝 同步异步&#x2F;串行并发 动态方法解析 消息转发 排序算法时间复杂度","categories":["iOS"]},{"title":"Mac常用代码","path":"/2024/03/04/Mac常用代码/","content":"一、Git创建新分支1git checkout -b dev 相当于以下两条命令： 12git branch devgit checkout dev 提交的时候执行： 1git push --set-upstream origin dev 二、文件夹的显示和隐藏1、Mac显示隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder 2、Mac隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 三、给安卓手机安装软件1adb install -r（然后拖入apk文件） 四、OC代码转为C++代码1xcrun -sdk iphoneos clang arm64 -rewrite-objc main.m 如果代码里有weak的话使用以下代码： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m"},{"title":"Hello World","path":"/2024/03/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]