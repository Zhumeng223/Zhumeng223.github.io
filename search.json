[{"title":"12种Flutter开发工具推荐","path":"/2024/03/10/12种Flutter开发工具推荐/","content":"Panache：Flutter material 主题编辑器 Panache 是Flutter 的开源、基于浏览器的 material 主题编辑器，可让你为 Flutter 应用创建美观且可高度自定义的主题。使用这个 Flutter 开发工具，你可以自定义组件和小部件的颜色，并将主题导出为 theme.dart 文件。 项目地址 https://rxlabz.github.io/panache Supernova：Flutter 设计到代码工具 Supernova 是一款功能强大的设计到代码工具，可将你的 Sketch 和 Adobe XD 移动设计转换为适用于 iOS、Android、ReactNative，当然还有 Flutter 的原生前端代码。导入应用设计时，Supernova 还可以处理资产创建和重复数据删除工作，并允许你编辑设计并实时查看代码更改。Supernova 目前仅提供了 macOS 应用，但很快就会发布云端版本。 项目地址 https://supernova.io/ Codemagic：FlutterCI&#x2F;CD 工具 Codemagic 是 Nevercode 创建的第一个专注于 Flutter 的 CI&#x2F;CD 工具。它可以轻松识别你的 Flutter 应用，并与所有你喜欢的工具集成，以自动化你的整个构建、测试和发布流程。Codemagic 还相当实惠，每月提供 500 个免费的 Mac mini 构建分钟，以及按需付费的额外分钟计费方案。 项目地址 https://codemagic.io/ Sylph：Flutter 设备农场测试工具 Sylph 是由 Maurice McCabe 创建的开源命令行工具，本质上是 AWS 设备农场的包装器。借助 Sylph，你可以在 AWS 设备农场中一次在数百个真实的 iOS 和 Android 设备上运行 Flutter 集成和端到端测试。 项目地址 https://pub.dev/packages/sylph Amplitude：Flutter 应用内分析工具 Amplitude 是一种著名的应用内分析工具，可帮助你了解用户如何与你的应用交互。现在，它也是一种流行的 Flutter 开发工具，可以帮助你跟踪和监视各种数据，并与所有流行的移动应用开发流程集成，从而使你能够根据数据采取行动。 项目地址 https://github.com/mmcc007 Count.ly：Flutter 应用内分析工具 Count.ly 是一个开源分析工具，专注于数据的安全性和隐私性。Count.ly 的免费版本允许你跟踪显示应用性能的基本指标和 KPI。但它们还提供付费版本，其中包含一组更广泛的指标以及其他许多功能。Count.ly 的付费版本可以在内部或云中托管，并提供额外的特性标志、A&#x2F;B 测试和推送通知功能。 项目地址 https://count.ly/ AppsFlyer：Flutter 归因工具 AppsFlyer 是一种移动归因工具，可帮助你了解用户的来源并了解应用安装量和特定营销活动之间的联系。它提供了一个仪表板，可以帮助你了解营销渠道和广告系列在各种设备和应用上的效果如何，并与 6000 多家媒体合作伙伴集成。 项目地址 https://www.appsflyer.com/ Instabug：Flutter 应用内错误报告、崩溃报告和调查工具 Instabug 是一个用于移动应用实时上下文洞察的平台，可用于应用内错误报告、崩溃报告、调查和功能请求。将 Instabug 的 Flutter SDK 集成到你的应用中后，你就可以允许用户在不离开应用的情况下报告他们遇到的错误。Instabug 可以捕获截图，支持用户注释和模糊，并能捕获全面的日志和设备详细信息，以帮助你更快地发现和解决问题。崩溃报告也会与你定位确切问题所需的所有日志和设备详细信息一起发送。你还可以向你的用户发送定向调查，以更好地了解用户操作背后的原因，并允许用户请求功能，对请求进行投票。 项目地址 https://instabug.com/?src=InstabugBlog&amp;mdm=internal&amp;term=flutter_tools Airship：Flutter 应用内消息工具 Airship 是一个客户参与平台，允许你向用户发送推送通知和应用内消息，以吸引他们并改善他们的转化率。它还允许你创建一个应用内消息中心，该中心创建一个应用内收件箱，你可以在其中向用户发送持久消息。 项目地址 https://www.airship.com/ WonderPush：Fluttet 推送通知工具 WonderPush 是另一个通知推送和应用内消息传递工具，你可以在 Flutter 应用中使用该工具来提高用户的参与度。它以低廉的价格提供了许多强大的功能，包括细分和定位、地理位置定位以及 A&#x2F;B 测试。 项目地址 https://www.wonderpush.com/ Revenue Cat：Flutter 应用内购买工具 RevenueCat 是一款应用内购买和订阅管理工具，支持 iOS、Android 和 Stripe。使用这一工具，你可以轻松创建和管理应用内购买和订阅模块，它可以完成所有繁重的工作并处理计费基础架构。它还支持开箱即用的 LTV、MRR、客户流失率等指标测量，来跟踪你的应用成绩。 项目地址 https://www.revenuecat.com/ Square：Flutter 应用内支付工具 Square 是一个应用内支付管理平台，可为你处理支付操作带来的所有复杂性。借助其 Flutter SDK，你可以通过易于定制的 UI 接收应用内付款，该 UI 支持数字钱包和存储卡以进行快速结帐。 项目地址 https://www.revenuecat.com/","categories":["Flutter","资源库"]},{"title":"iOS资源整理","path":"/2024/03/09/iOS资源整理/","content":"RunTimeRuntime 10种用法（没有比这更全的了 开源项目成为iOS顶尖高手，你必须来这里(这里有最好的开源项目和文章) MVVMTableView之MVVM与MVC之对比 使用MVVM减少控制器代码实战(减少56%) 面向协议的 MVVM 架构介绍 网络iOS 升级HTTPS通过ATS你所要知道的 iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求 iOS开发之AFNetworking 3.0.4使用 iOS开发 AFNetworking 3.0使用遇到的问题补充 正确使用AFNetworking的SSL保证网络安全 iOS开发中WiFi相关功能总结 iOS应用支持IPV6，就那点事儿 基于iOS 10、realm封装的下载器（支持存储读取、断点续传、后台下载、杀死APP重启后的断点续传等功能） 网络层的搭建需要解决哪些问题 YTKNetwork集成教程以及相关问题思考 关于iOS工程中网络请求管理的头脑风暴 计算机网络中的TCP&#x2F;UDP协议到底是怎么回事（一） 计算机网络中的TCP&#x2F;UDP协议到底是怎么回事（二）","categories":["iOS","资源库"]},{"title":"iOS开发兵器进阶","path":"/2024/03/08/iOS开发兵器进阶/","content":"开篇 悟空道：“我自生身之后，出家修行，得一个无生无灭之体。近因教演儿孙，守护山洞，奈何没件兵器。久闻贤邻享乐瑶宫贝阙，必有多余神器，特来告求一件。” – 《西游记》第三回 四海千山皆拱伏 九幽十类尽除名 常言道：“工欲善其事，必先利其器。”各位看官，今天咱们就介绍几件在 iOS 开发中几件趁手的兵器。 开发Reveal 教程：iOS开发中集成Reveal 破解版用于学习途径，请自行搜索。 Charles 教程：Charles 从入门到精通 下载：Charles 官网 破解版用于学习途径，请自行搜索。 SimPholdersSimPholders 是一款Mac上的iOS开发辅助工具，能够在菜单栏上快速的访问iPhone Simulator中的应用的文件夹，从而帮助我们进行应用开发。 下载：Simpholders PaintCode 教程：PaintCode 教程 (1) | PaintCode 教程 (2) 下载：PaintCode 官网 Conerstone 教程：用CornerStone配置SVN，HTTP及svn简单使用说明 破解版用于学习途径，请自行搜索。 iFunBoxiFunBox是一款小巧的iPhone文件管理软件，界面类似于windows资源管理器，以简练时尚的窗口方式浏览和管理iPhone、iPad、iPod touch上的文件和目录。既可以在手机与电脑之间同步传递数据，使你轻松上传电影、音乐、电子书、桌面、照片以及应用程序。 下载：iFunBox 官网 iTerm 你应该知道的 iTerm2 使用方法–MAC终端工具 iTerm2 - macOS Terminal Replacement 官网 zsh zsh 全程指南 zsh 官网 VisualDifferVisualDiffer比较文件夹和文件并排侧使用颜色直观地显示差异。 防火墙 Little Snitch主要用途，阻止 Mac 内具体哪个应用联网，实时查看电脑流量是否有异常。 介绍：你的隐私看门人：Mac 双向防火墙 Little Snitch flux长期看电脑屏幕，护眼软件。 flux 官网 效率有道词典不多说，阅读英文文档和翻译的辅助。全球 Mac Appstore 均有销售。 Dash全栈工程师开发文档大全。全球 Mac Appstore 均有销售。 MindNode Pro思维导图，帮助梳理逻辑。 StarUML画UML，类图的工具。StarUML 官网 OmniGraffle画UML，类图的工具，与StarUML比较看个人爱好了。 知识输入印象笔记印象笔记，有道笔记，为知笔记，笔记是一定要有的，那么多东西谁天天记在脑子了，关键的东西记笔记里，如果实在忘了，Google一下。 Reeder常看的blog记得订阅。 知识输出Markdown + Quiver + 坚果云 程序员专用笔记软件Quiver 坚果云怎么样？ - 网盘 - 知乎 U图床 + 七牛云 U 图床：MacAppStore 下载 U 图床：Github 开源 搭配 Markdown 书写，够了。 LicecapLicecap 是一款屏幕录制工具，支持导出 GIF 动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围。 官方主页 GitHub最好的开源项目集散地(没有“之一”)。同样是你的作品得到认可的地方。 Blog技术blog非常棒，好的技术或方案应该记录下并传播出去，坚持做下去。Hexo+gitpage 搭建个人技术博客 简书大牛都在简书上写博客，你不跟着节奏么？ 开发者头条技术自媒体发散渠道，同时也是好的知识输入渠道。 掘金技术自媒体发散渠道，同时也是好的知识输入渠道。 科学上网科学上网用于学习途径，关于 ShadowsockesX 的内容，来自 使用ShadowSocks科学上网及突破公司内网这篇文章。 ShadowsockesXShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由@clowwindy开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。 ShadowsocksX-NG:Github Proxifier该工具的作用就是接管运行中的所有应用发出的所有请求，然后通过代理进行转发，这样就可以让不支持代理的应用也可以走代理了。 Proxifier 官网 破解和使用教程看这篇：proxifier注册码以及配合shadowsocks上网 - 科学上网 其他姿势科学上网，有需要请私信我。Chrome 插件翻墙后，全球 Chrome 商店均有销售。 Proxy SwitchyOmegaChrome 浏览器 配合 Proxy SwitchyOmega 插件 + 代理服务器，轻松登陆Google。 FireShot截取整个网页的截屏工具 有道词典不多说，网页浏览英文随时翻译。 开发者头条第一时间掌握技术圈最新自媒体动态。 掘金第一时间掌握技术圈最新自媒体动态，和github每日更新仓库。 Copy as Markdown配合 Markdown 图片、链接跳转方便粘贴。 AdBlock去除广告，专注网页内容。 印象笔记·剪藏配合印象笔记，知识输入重要来源，点击一下，直接将网页正文存入印象笔记。 新浪微博图床免费开源的微博图床。 新浪微博图床：Github 结尾 悟空笑道：“古人云：‘愁海龙王没宝哩！’你再去寻寻看。若有可意的，一一奉价。” 这是小生工作中常用的几件工具介绍给大家，也欢迎有好的工具咱们奔走相告，提高工作效率的同时，也学习工具开发者的设计思想。","categories":["iOS","资源库"]},{"title":"几个超棒的iOS学习网站","path":"/2024/03/07/几个超棒的iOS学习网站/","content":"我相信，要想从一个“还不错”的人编程一个卓越的人，我们需要不停地向他人学习，同时还要尽早地适应最新的技术和工具。除了苹果官方文档网站之外，我列举了一些能获取有价值的文章和资源的网站，这些网站能够帮助我们更上一个台阶！ 让我们先看一些原创的内容博客： objc.io这个网站由世界级的iOS工程师每月进行更新。上面可以看到关于某些话题的高质量文章和深度讨论，同时他们还提供了基于订阅的杂志iPad应用。该网站由Chris Eidhof、Daniel Eggert和Florian Kugler发现并提供。 Subjective-C该网站以解析和重构创新模式和著名应用的UI而闻名。该网站为他们的实验提供程序性文章和代码库。由Sam Page主笔。有点遗憾的是，作者决定暂停更新网站，不过好在那些旧的教程仍然很值得一看。 NSHipster以类为基础进行逐步讲解并附有示例代码的网站。其文章探讨了编程风格，以及最前沿的类的使用和实现。由AFNetworking的作者Mattt Thompson创建，目前由Nate Cook进行管理。 Peter Steinberger本站为个人博客，其作者是著名的iOS商业PDF库的创始人，该产品曾被Dropbox和Evernote这样著名的应用使用过。网站内容包括一些令人惊叹的黑客资源和debug资源，以帮助开发者学习和实践。 Ole Begemann本博客重点分享个人经历,同时讨论代码样式和API设计,有时还会透露一些苹果所使用的私密而有趣的类。 Florian KuglerObjC.IO的合著者所写的个人博客。你可以在上面找到很多关于性能检测的文章和讨论，包括应用于多核心数据的UI绘制。 NSBlog用有趣的问答形式创作，包含了关于Objective-C和其他主题的深度问题。如果你对于重建像NSObject这样的基本类持有疑问，可以向Mike Ash提出。 Cocoa从iOS开发者的Tumblr上摘取的iOS开发源码和深度观察，有点随机但是还是很有用。 下面有一些博客，可以帮我们获取最新讯息。 iOS Dev Weekly自2011年起每周更新，订阅者已经超过20,000。它可以帮我们从网络上获取有用的iOS文章。还提供了Safari的推送通知功能。由Dave Verwer发现并提供。 iOS Developer Tips2008年以来最早的几个每天更新的iOS推送资源之一。包括很多领域的文章，例如开发小技巧、UX、流言、个人经历和故事等。由John Muchow策划。 iOS Goodies较新的iOS资讯站。内容包括论文、控件&#x2F;工具、商务、UI以及各种媒体类型等等。由Rui Peres和Tiago Almeida每周更新。 AppCoda由我在香港的一个开发者朋友创建，他最近辞掉了工作来专心维护这个网站。包括在线的文章和支付后可下载的文章，重点在用于执行的最新的API和结构上。由Simon Ng创建，值得一看。 两个有价值的原创内容博客。 Krzysztof Zab?ocki提供关于代码结构、工具和Xcode的技巧，当然，在我第一次发表这篇博客的时候我把它给遗漏了。我们从这些高阶的文章中学到了很多。 iOS Development tips相对较新的博客，有一些关于使用Xcode和API的细致的提示，即使你再匆忙也值得去看一眼。作者是Rounak Jain。 时间很宝贵，所以我们必须聪明地选择新闻来源。 读的越好,做的越好。 读的越多，做的越少。","categories":["iOS","资源库"]},{"title":"iOS面试题","path":"/2024/03/06/iOS面试题/","content":"1、一个NSObject对象占用多少内存？回答：系统分配了16个字节给NSObject对象（通过malloc_size函数获得）（因为内存对齐，必须是16的倍数）但NSObject对象内部只有一个isa指针，只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 2、对象的isa指针指向哪里？回答：instance对象的isa指针指向class对象class对象的isa指针指向meta-class对象meta-class对象的isa指针指向基类的meta-class对象 3、OC的类信息存放在哪里？回答：对象方法、属性、成员变量、协议信息，存放在class对象中类方法，存放在meta-class对象中成员变量的具体值，存放在instance对象中 4、iOS用什么方式实现对一个对象的KVO？（KVO的本质是什么？）回答：利用RuntimeAPI生成一个子类NSKVOXXXNotifying，并且让instance对象的isa指针指向这个全新的子类当修改instance对象的属性时，会调用Foundation框架中的_NSSetXXXValueAndNotify函数（重写了setter方法）：willChangeValueForKey:父类原来的setter方法didChangeValueForKey:内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context） 5、如何手动触发KVO？回答：手动去调用willChangeValueForKey:和didChangeValueForKey:的方法 6、直接修改成员变量会触发KVO吗？回答：不会，因为修改成员变量并不会调用setter方法 7、通过KVC修改属性会触发KVO吗？回答：会触发KVO，通过KVC修改相当于手动调用了willChangeValueForKey:和didChangeValueForKey: 8、KVC的赋值和取值的过程是怎样的？原理是什么？回答：赋值：取值： 9、Category的使用场合是什么？回答：类包含了很多个方法实现，而这些方法需要不同团队的成员来实现当你在使用基础类库中的类时，你不想继承这些类，而只是想添加一些方法的时候 10、Category的实现原理回答：Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中） 11、Category和Class Extension的区别是什么？回答：Class Extension是在程序编译的时候，它的数据就已经包含在类信息中了Category在底层是以结构体的形式存在，在程序运行的时候，才会将数据合并到类信息中 12、Category中有load方法吗？load方法是什么时候调用的？load方法能继承吗？回答：有load方法load方法在runtime加载类、分类的时候调用，而且只调用一次load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用 13、load、initialize方法的区别是什么？它们在category中的调用顺序？以及出现继承时它们之间的调用过程？回答：load方法load方法会在Runtime加载类、分类的时候调用每个类、分类的load，在程序运行的过程中只调用一次调用顺序：先调用类的load按照编译的先后顺序调用（先编译，先调用）调用子类的load之前会先调用父类的load再调用分类的load按照编译先后顺序调用（先编译，先调用）load方法系统调用和主动调用的区别系统调用load是直接找到类或分类中的方法的内存地址直接调用主动调用load是通过消息机制来发送消息的，会在对应的消息列表里按顺序遍历一层层查找，找到就调用initialize方法initialize方法会在类第一次接收到消息时调用调用顺序：先调用父类的initialize，再调用子类的initialize，每个类只会初始化1次（如果子类没有实现initialize方法，会调用父类的initialize方法，所以父类的initialize方法可能会调用多次）initialize的调用是通过消息机制来发送消息的 14、Category能否添加成员变量？如果可以，如何给Category添加成员变量？回答：不能直接给Category添加成员变量，但是可以简介实现Category有成员变量的效果——关联对象 15、Block的原理是怎样的？Block的本质是什么？回答：其本质就是封装了函数调用以及调用环境的OC对象 16、__block的作用是什么？有什么使用注意点？回答：可以将修饰的对象包装成一个对象，解决在block内部无法修改外部变量的问题。__block内部会进行内存管理，在MRC环境下不会对对象进行强引用。 17、看下面代码，分别输出的值是什么？1234567891011121314151617181920212223int a = 10;static int b = 10;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; auto int age = 10; static int height = 10; void (^block)(void) = ^&#123; NSLog(@&quot;age is %d, height is %d&quot;, age, height); NSLog(@&quot;a is %d, b is %d&quot;, a, b); &#125;; age = 20; height = 20; a = 20; b = 20; block();\t&#125; return 0;&#125; 回答：输出结果为：age&#x3D;10，height&#x3D;20，a&#x3D;20，b&#x3D;20 age是自动变量，是值传递height表示的是指针传递，block获取的是该变量的地址而a/b都是全局变量，block不会捕获，需要时直接拿取当前最新的值就可以了12345678910111213141516171819202122232425262728293031323334int a = 10;static int b = 10;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; int *height; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; auto int age = 10; static int height = 10; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height)); age = 20; height = 20; a = 20; b = 20; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); &#125; return 0;&#125; 18、看下面代码，block内部会不会捕获self？123456789101112131415161718192021222324252627@interface Person : NSObject@property (copy, nonatomic) NSString *name;- (instancetype)initWithName:(NSString *)name;@end@implementation Person- (void)test&#123; void (^block)(void) = ^&#123; NSLog(@&quot;-------%d&quot;, [self name]); &#125;; block();&#125; - (instancetype)initWithName:(NSString *)name&#123; if (self = [super init]) &#123; self.name = name; &#125; return self;&#125;@end 回答：会捕获，因为self本质上也是一个局部变量，block内部会生成一个变量来保存Person对象的地址123456789101112131415161718struct __Person__test_block_impl_0 &#123; struct __block_impl impl; struct __Person__test_block_desc_0* Desc; Person *self; __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// 函数都会生成隐式参数self和_cmdstatic void _I_Person_test(Person * self, SEL _cmd) &#123; void (*block)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);&#125; 19、Block的属性词为什么是Copy？使用Block有哪些注意事项？回答：block如果没有进行copy操作，就不会放在堆上。放到堆上的主要目的是方便我们来控制它的生命周期，可以更有效的进行内存管理。注意事项：注意不要产生循环引用"},{"title":"iOS易忘图","path":"/2024/03/05/易忘图/","content":"isa和superclass指针 KVCsetValue:forKey:的原理 KVCvalueForKey:的原理 关联对象的本质 @encode&#96;字符串编码 类的底层结构 常见的深浅拷贝 同步异步&#x2F;串行并发 动态方法解析 消息转发 排序算法时间复杂度","categories":["iOS"]},{"title":"Mac常用代码","path":"/2024/03/04/Mac常用代码/","content":"一、Git创建新分支1git checkout -b dev 相当于以下两条命令： 12git branch devgit checkout dev 提交的时候执行： 1git push --set-upstream origin dev 二、文件夹的显示和隐藏1、Mac显示隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder 2、Mac隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 三、给安卓手机安装软件1adb install -r（然后拖入apk文件） 四、OC代码转为C++代码1xcrun -sdk iphoneos clang arm64 -rewrite-objc main.m 如果代码里有weak的话使用以下代码： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m"},{"title":"Hello World","path":"/2024/03/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"探索Objective-C底层 - Runtime的相关应用","path":"/2022/02/15/探索Objective - C底层 - Runloop的底层原理/","content":"引言在iOS和macOS开发中，Runloop（运行循环）是一个非常重要的概念，它是程序运行的核心机制之一。理解Runloop的底层原理，对于解决诸如界面卡顿、定时器失效、线程保活等问题具有重要意义。本文将深入剖析Runloop的底层实现，带你了解其背后的奥秘。 一、Runloop的基本概念1.1 定义Runloop是一种事件处理循环机制，它可以让线程在没有任务时进入休眠状态，有任务时被唤醒并处理任务，从而避免线程不断地空转消耗CPU资源。在Objective - C中，Runloop由Core Foundation框架提供，对应的核心类是CFRunLoopRef。 1.2 作用 保持程序的持续运行：主线程的Runloop会一直运行，保证程序不会在启动后立即退出。 处理事件和消息：包括用户的触摸事件、网络请求的响应、定时器的触发等。 节省CPU资源：在没有任务时，线程进入休眠状态，降低CPU的使用率。 1.3 与线程的关系 一一对应：每个线程都有与之对应的唯一的Runloop对象。 按需创建：主线程的Runloop在程序启动时自动创建并启动，而子线程的Runloop默认是没有创建的，只有在第一次调用[NSRunLoop currentRunLoop]时才会创建。 生命周期：线程结束时，其对应的Runloop也会被销毁。 二、Runloop的底层数据结构2.1 CFRunLoop结构体123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; _lock：用于保护对模式列表的访问，确保线程安全。 _wakeUpPort：用于唤醒Runloop的端口。 _commonModes：存储通用模式的集合。 _commonModeItems：存储通用模式下的事件源、定时器和观察者。 _currentMode：当前正在运行的模式。 _modes：存储所有的运行模式。 2.2 CFRunLoopMode结构体123456789101112131415161718192021222324252627282930struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; _name：模式的名称，如kCFRunLoopDefaultMode、UITrackingRunLoopMode等。 _sources0：存储Source0类型的事件源。 _sources1：存储Source1类型的事件源。 _observers：存储观察者对象，用于监听Runloop的状态变化。 _timers：存储定时器对象。 2.3 事件源（Source）事件源分为两种类型： Source0：非基于端口的事件源，需要手动唤醒Runloop。例如，UIEvent、performSelector:onThread:等。 Source1：基于端口的事件源，能主动唤醒Runloop。例如，系统事件、Mach port等。 2.4 定时器（Timer）定时器用于在指定的时间或时间间隔后触发事件。常见的定时器有NSTimer和CADisplayLink。 2.5 观察者（Observer）观察者用于监听Runloop的状态变化，如进入Runloop、即将处理定时器、即将进入休眠等。可以通过CFRunLoopAddObserver函数添加观察者。 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Runloop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理定时器 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理事件源 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Runloop kCFRunLoopAllActivities = 0x0FFFFFFFU // 所有状态&#125;; 三、Runloop的运行流程3.1 启动Runloop在主线程中，Runloop会在程序启动时自动启动。而在子线程中，需要手动启动Runloop。启动Runloop的核心函数是CFRunLoopRunSpecific。 1SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled); rl：要运行的Runloop对象。 modeName：运行的模式名称。 seconds：Runloop运行的最长时间。 returnAfterSourceHandled：处理完一个事件源后是否立即返回。 3.2 完整的运行流程Runloop的运行流程可以分为以下几个主要步骤： 通知观察者进入Runloop：调用所有注册的观察者的回调函数，通知它们Runloop即将进入。 处理即将到期的定时器：检查所有的定时器，找出即将到期的定时器并触发它们的回调函数。 处理非延迟的performSelector调用：执行所有非延迟的performSelector方法。 处理Source0事件源：检查所有的Source0事件源，如果有准备好的事件，则处理这些事件。 检查Source1事件源：如果没有Source0事件需要处理，则检查是否有Source1事件。如果有Source1事件，则处理该事件并唤醒Runloop。 进入休眠状态：如果没有任何事件需要处理，Runloop会进入休眠状态，等待被唤醒。 被唤醒并处理事件：当有事件发生（如定时器到期、Source1事件触发等）时，Runloop会被唤醒，并处理相应的事件。 通知观察者即将退出Runloop：调用所有注册的观察者的回调函数，通知它们Runloop即将退出。 以下是一个简化的伪代码表示： 123456789101112131415161718192021222324252627282930313233// 启动Runloopwhile (true) &#123; // 通知观察者进入Runloop notifyObservers(kCFRunLoopEntry); // 处理即将到期的定时器 handleTimers(); // 处理非延迟的performSelector调用 handleNonDelayedPerformSelectors(); // 处理Source0事件源 if (hasReadySource0()) &#123; handleSource0(); &#125; else &#123; // 检查Source1事件源 if (hasSource1()) &#123; handleSource1(); continue; &#125; // 进入休眠状态 notifyObservers(kCFRunLoopBeforeWaiting); sleep(); notifyObservers(kCFRunLoopAfterWaiting); &#125; // 检查是否需要退出Runloop if (shouldExit()) &#123; notifyObservers(kCFRunLoopExit); break; &#125;&#125; 四、Runloop的模式（Mode）4.1 模式的概念Runloop的模式是一种隔离机制，不同的模式下可以有不同的事件源、定时器和观察者。Runloop在同一时间只能运行在一种模式下，只有在该模式下注册的事件源、定时器和观察者才会被处理。 4.2 常见的模式 kCFRunLoopDefaultMode：默认模式，大多数情况下Runloop运行在这个模式下。 UITrackingRunLoopMode：用于处理UI跟踪事件，如滚动视图的滚动。当用户拖动滚动视图时，Runloop会切换到这个模式。 kCFRunLoopCommonModes：这不是一个实际的模式，而是一个标记。可以将事件源、定时器和观察者注册到这个标记下，这样它们就可以在多个模式下都能被处理。 4.3 模式切换Runloop在不同的情况下会切换运行模式。例如，当用户开始拖动滚动视图时，Runloop会从kCFRunLoopDefaultMode切换到UITrackingRunLoopMode，以确保滚动事件能够得到及时处理。当滚动结束后，Runloop又会切换回原来的模式。 五、Runloop与线程的唤醒和休眠5.1 休眠机制Runloop在没有任务需要处理时会进入休眠状态，以节省CPU资源。在休眠状态下，线程会释放CPU资源，等待被唤醒。Runloop进入休眠状态的关键是调用mach_msg函数，该函数会使线程进入内核态，等待消息的到来。 5.2 唤醒机制当有事件发生时，Runloop会被唤醒。唤醒Runloop的方式有多种： Source1事件：基于端口的事件源（Source1）可以主动唤醒Runloop。 定时器到期：当定时器到期时，会触发相应的回调函数，从而唤醒Runloop。 手动唤醒：可以通过调用CFRunLoopWakeUp函数手动唤醒Runloop。 六、Runloop与AutoreleasePool6.1 主线程的AutoreleasePool在主线程中，Runloop会自动管理AutoreleasePool。每次Runloop循环开始时，会创建一个新的AutoreleasePool，在循环结束时，会释放这个AutoreleasePool。这样可以确保在一次Runloop循环中创建的自动释放对象在循环结束时被释放。 6.2 子线程的AutoreleasePool在子线程中，需要手动管理AutoreleasePool。如果在子线程中创建了大量的自动释放对象，而没有及时释放，可能会导致内存泄漏。因此，在子线程中启动Runloop时，通常需要手动创建和释放AutoreleasePool。 123456dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @autoreleasepool &#123; // 子线程任务 [[NSRunLoop currentRunLoop] run]; &#125;&#125;); 七、总结Runloop是Objective - C中一个非常重要的机制，它通过事件循环的方式，让线程在有任务时处理任务，没有任务时进入休眠状态，从而提高了程序的性能和响应能力。深入理解Runloop的底层原理，包括其数据结构、运行流程、模式机制、唤醒和休眠机制以及与AutoreleasePool的关系，对于优化代码性能、解决各种开发中的问题具有重要意义。希望本文能帮助你更好地理解Runloop的底层原理。 参考资料： Apple Developer Documentation - Run Loops Core Foundation Source Code","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runtime的相关应用","path":"/2022/02/10/探索Objective - C底层 - Runtime的相关应用/","content":"引言Objective - C 的 Runtime 是一个强大且灵活的运行时系统，它为开发者提供了许多在编译时无法实现的动态特性。在之前的文章中，我们已经深入探讨了 Runtime 的底层原理，包括 isa 指针、class 结构、objc_msgSend 机制等。本文将重点介绍 Runtime 在实际开发中的一些常见应用，并通过具体的例子详细说明。 一、核心Runtime API详解1. 类与对象操作1234567891011// 获取类的父类Class class_getSuperclass(Class cls);// 获取类的实例方法Method class_getInstanceMethod(Class cls, SEL name);// 获取类的所有方法Method *class_copyMethodList(Class cls, unsigned int *outCount);// 创建类的实例id class_createInstance(Class cls, size_t extraBytes); 2. 方法操作12345678// 交换两个方法的实现void method_exchangeImplementations(Method m1, Method m2);// 添加新方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types);// 获取方法实现IMP class_getMethodImplementation(Class cls, SEL name); 3. 关联对象12345// 设置关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 获取关联对象id objc_getAssociatedObject(id object, const void *key); 4. 属性与协议12345// 获取属性列表objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount);// 获取协议列表Protocol *class_copyProtocolList(Class cls, unsigned int *outCount); 二、15种典型应用场景1. 方法交换（Method Swizzling）应用场景：统一日志记录、埋点统计 123456789101112131415@implementation UIViewController (Logging)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method original = class_getInstanceMethod(self, @selector(viewDidLoad)); Method swizzled = class_getInstanceMethod(self, @selector(swizzled_viewDidLoad)); method_exchangeImplementations(original, swizzled); &#125;);&#125;- (void)swizzled_viewDidLoad &#123; [self swizzled_viewDidLoad]; NSLog(@&quot;ViewController %@ loaded&quot;, NSStringFromClass([self class]));&#125;@end 2. 动态添加方法应用场景：懒加载功能模块 12345678910111213141516@interface DynamicLoader : NSObject@end@implementation DynamicLoadervoid dynamicMethod(id self, SEL _cmd) &#123; NSLog(@&quot;Dynamic method called&quot;);&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(lazyMethod)) &#123; class_addMethod(self, sel, (IMP)dynamicMethod, &quot;v@:&quot;); return YES; &#125; return NO;&#125;@end 3. 关联对象扩展类应用场景：为系统类添加属性 123456789101112131415@interface UIImage (Watermark)@property (nonatomic, strong) UIImage *watermarkedImage;@end@implementation UIImage (Watermark)static char kWatermarkKey;- (void)setWatermarkedImage:(UIImage *)image &#123; objc_setAssociatedObject(self, &amp;kWatermarkKey, image, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (UIImage *)watermarkedImage &#123; return objc_getAssociatedObject(self, &amp;kWatermarkKey);&#125;@end 4. 字典转模型应用场景：JSON数据解析 1234567891011121314151617181920@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@implementation Person- (instancetype)initWithDictionary:(NSDictionary *)dict &#123; self = [super init]; unsigned int count; objc_property_t *props = class_copyPropertyList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSString *key = [NSString stringWithUTF8String:property_getName(props[i])]; if (dict[key]) &#123; [self setValue:dict[key] forKey:key]; &#125; &#125; free(props); return self;&#125;@end 5. AOP编程（面向切面编程）应用场景：统一异常处理 123456789101112131415@implementation NSObject (ExceptionHandler)+ (void)load &#123; Method original = class_getInstanceMethod(self, @selector(forwardInvocation:)); Method swizzled = class_getInstanceMethod(self, @selector(swizzled_forwardInvocation:)); method_exchangeImplementations(original, swizzled);&#125;- (void)swizzled_forwardInvocation:(NSInvocation *)invocation &#123; @try &#123; [self swizzled_forwardInvocation:invocation]; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;Caught exception: %@&quot;, exception); &#125;&#125;@end 6. KVO实现应用场景：属性变更监听 1234567891011@interface Observable : NSObject@property (nonatomic, strong) NSString *value;@end@implementation Observable- (void)setValue:(NSString *)value &#123; [self willChangeValueForKey:@&quot;value&quot;]; _value = value; [self didChangeValueForKey:@&quot;value&quot;];&#125;@end 7. 动态代理应用场景：实现轻量级代理模式 123456789@interface DynamicProxy : NSObject@property (nonatomic, weak) id target;@end@implementation DynamicProxy- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return self.target;&#125;@end 8. 方法拦截应用场景：实现方法调用监控 123456789101112@implementation NSObject (MethodInterceptor)+ (void)load &#123; Method original = class_getInstanceMethod(self, @selector(performSelector:)); Method swizzled = class_getInstanceMethod(self, @selector(intercepted_performSelector:)); method_exchangeImplementations(original, swizzled);&#125;- (id)intercepted_performSelector:(SEL)aSelector &#123; NSLog(@&quot;Intercepted selector: %@&quot;, NSStringFromSelector(aSelector)); return [self intercepted_performSelector:aSelector];&#125;@end 9. 实现单例应用场景：线程安全的单例模式 12345678910111213141516171819@interface Singleton : NSObject+ (instancetype)sharedInstance;@end@implementation Singletonstatic id _instance;+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [super allocWithZone:zone]; &#125;); return _instance;&#125;+ (instancetype)sharedInstance &#123; return [[self alloc] init];&#125;@end 10. 热修复应用场景：紧急修复线上bug 1234567891011121314@interface BuggyClass : NSObject- (void)buggyMethod;@end@implementation BuggyClassvoid fixedMethod(id self, SEL _cmd) &#123; NSLog(@&quot;Fixed implementation&quot;);&#125;+ (void)load &#123; Method buggy = class_getInstanceMethod(self, @selector(buggyMethod)); class_replaceMethod(self, buggy, (IMP)fixedMethod, &quot;v@:&quot;);&#125;@end 11. 统计方法调用次数应用场景：性能分析 12345678910111213141516171819@implementation NSObject (MethodCounter)static char kInvocationCountKey;- (void)incrementInvocationCount &#123; NSNumber *count = objc_getAssociatedObject(self, &amp;kInvocationCountKey); objc_setAssociatedObject(self, &amp;kInvocationCountKey, @(count.integerValue + 1), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;+ (void)load &#123; Method original = class_getInstanceMethod(self, @selector(performSelector:)); Method swizzled = class_getInstanceMethod(self, @selector(counted_performSelector:)); method_exchangeImplementations(original, swizzled);&#125;- (id)counted_performSelector:(SEL)aSelector &#123; [self incrementInvocationCount]; return [self counted_performSelector:aSelector];&#125;@end 12. 实现协议应用场景：动态遵循协议 123456789101112131415@interface DynamicAdopter : NSObject@end@implementation DynamicAdopter+ (BOOL)conformsToProtocol:(Protocol *)aProtocol &#123; return YES;&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (Protocol_getMethodDescription(aProtocol, aSelector, YES, YES)) &#123; return self; &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 13. 实现链式调用应用场景：构建DSL 123456789101112@interface Chainable : NSObject- (Chainable *(^)(NSString *))setName;@end@implementation Chainable- (Chainable *(^)(NSString *))setName &#123; return ^(NSString *name) &#123; [self setValue:name forKey:@&quot;name&quot;]; return self; &#125;;&#125;@end 14. 实现动态容器应用场景：动态存储键值对 1234567891011121314@interface DynamicContainer : NSObject- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKey:(NSString *)key;@end@implementation DynamicContainer- (void)setValue:(id)value forKey:(NSString *)key &#123; objc_setAssociatedObject(self, (__bridge const void *)(key), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)valueForKey:(NSString *)key &#123; return objc_getAssociatedObject(self, (__bridge const void *)(key));&#125;@end 15. 实现自定义KVC应用场景：扩展KVC功能 12345678910111213141516171819@interface CustomKVC : NSObject- (void)customSetValue:(id)value forKey:(NSString *)key;@end@implementation CustomKVC- (void)customSetValue:(id)value forKey:(NSString *)key &#123; unsigned int count; objc_property_t *props = class_copyPropertyList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; if ([NSStringFromCString(property_getName(props[i])) isEqualToString:key]) &#123; [self setValue:value forKey:key]; free(props); return; &#125; &#125; free(props); [self doesNotRecognizeSelector:_cmd];&#125;@end 三、注意事项 性能开销：频繁使用Runtime API可能影响性能 线程安全：方法交换等操作需加锁保护 版本兼容：不同iOS版本的Runtime实现可能有差异 内存管理：关联对象需合理选择内存策略 方法冲突：避免方法名冲突导致不可预期行为 四、总结Objective - C Runtime通过开放底层API，赋予开发者强大的动态编程能力。掌握这些API的使用方法和应用场景，能够显著提升代码的灵活性和扩展性。建议在实际开发中结合具体需求，合理运用Runtime技术，并注意性能与维护性的平衡。 参考资料： Apple Runtime Programming Guide objc4开源代码","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runtime（二）","path":"/2022/02/06/探索Objective - C底层 - Runtime（二）/","content":"引言在Objective - C的开发中，Runtime 系统是其核心的动态特性支撑。在之前的文章里，我们已经对 isa 指针、class 结构和方法缓存等基础概念有了深入了解。这篇文章将继续深入探究 Runtime 里的几个关键部分，像 objc_msgSend 的三个阶段、super 的本质以及 isKindOf 和 isMemberOf 的底层实现等。 一、objc_msgSend 的三个阶段1.1 消息机制概述在Objective - C里，方法调用本质上是消息发送的过程。当代码里出现 [object method] 这样的方法调用时，编译器会把它转化为 objc_msgSend(object, @selector(method)) 函数调用。objc_msgSend 函数承担着在运行时找到并执行对应方法的重要任务，其执行过程分为三个阶段：消息发送、动态方法解析和消息转发。 1.2 消息发送阶段消息发送阶段是 objc_msgSend 的首要步骤，它的主要任务是查找方法的实现。具体流程如下： **检查接收者是否为 nil**：要是接收者为 nil，消息发送会直接返回，不会有任何操作。这也是Objective - C中给 nil 对象发送消息不会引发崩溃的原因。 查找方法缓存：先在接收者对象所属类的方法缓存里查找目标方法。由于方法缓存运用了哈希表结构，查找速度非常快。若在缓存中找到该方法，就直接调用其实现。 查找方法列表：若缓存中未找到目标方法，就会在接收者对象所属类的方法列表中查找。如果找到了，就将该方法添加到缓存中，再调用其实现。 查找父类：要是在当前类的方法列表中没找到目标方法，会沿着继承链向上，在父类的方法缓存和方法列表中继续查找，直至找到或者到达根类。 1.3 动态方法解析阶段若在消息发送阶段没有找到目标方法，就会进入动态方法解析阶段。在这个阶段，Runtime 会调用 resolveInstanceMethod:（针对实例方法）或者 resolveClassMethod:（针对类方法）方法，让开发者有机会动态添加方法的实现。示例代码如下： 123456789101112131415@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(dynamicMethod)) &#123; class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void dynamicMethodIMP(id self, SEL _cmd) &#123; NSLog(@&quot;Dynamic method called.&quot;);&#125;@end 在上述代码中，当调用 dynamicMethod 方法且该方法未找到时，resolveInstanceMethod: 会被调用，在这个方法里动态添加了 dynamicMethod 的实现。 1.4 消息转发阶段若动态方法解析阶段也未能解决问题，就会进入消息转发阶段。消息转发分为两个步骤： 备用接收者：Runtime 会调用 forwardingTargetForSelector: 方法，询问是否有其他对象可以处理这个消息。若返回一个非 nil 的对象，就会把消息转发给这个对象处理。示例代码如下：123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(anotherMethod)) &#123; return anotherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 完整消息转发：若备用接收者阶段没有处理消息，Runtime 会调用 methodSignatureForSelector: 方法获取方法签名，接着调用 forwardInvocation: 方法，开发者可以在这个方法里自定义消息的处理逻辑。示例代码如下：123456789101112131415- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if (aSelector == @selector(yetAnotherMethod)) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL selector = [anInvocation selector]; if ([anotherObject respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:anotherObject]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 二、super 的本质2.1 super 的基本概念在Objective - C里，super 关键字常被用于调用父类的方法。不过，super 并非一个对象，而是一个编译器指示符。当使用 super 调用方法时，实际上是告诉编译器从父类开始查找方法的实现。 2.2 super 的底层实现super 的底层是通过 objc_msgSendSuper 函数实现的。objc_msgSendSuper 函数接收一个 objc_super 结构体作为参数，这个结构体定义如下： 1234struct objc_super &#123; __unsafe_unretained _Nonnull id receiver; __unsafe_unretained _Nonnull Class super_class;&#125;; receiver：消息的接收者，也就是当前对象。 super_class：开始查找方法实现的父类。 当使用 super 调用方法时，编译器会生成如下代码： 1234struct objc_super superReceiver;superReceiver.receiver = self;superReceiver.super_class = [self superclass];objc_msgSendSuper(&amp;superReceiver, @selector(method)); 这表明 super 调用方法时，接收者依然是当前对象 self，只是从父类开始查找方法的实现。 2.3 super 使用示例下面通过一个具体的例子来理解 super 的使用： 123456789101112131415161718192021222324252627282930#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject- (void)eat;@end@implementation Animal- (void)eat &#123; NSLog(@&quot;Animal is eating.&quot;);&#125;@end@interface Dog : Animal- (void)eat;@end@implementation Dog- (void)eat &#123; [super eat]; NSLog(@&quot;Dog is eating.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog *dog = [[Dog alloc] init]; [dog eat]; &#125; return 0;&#125; 在上述代码中，Dog 类继承自 Animal 类，并重写了 eat 方法。在 Dog 类的 eat 方法中，使用 [super eat] 调用了父类 Animal 的 eat 方法，然后再执行自身的逻辑。运行这段代码，输出结果如下： 12Animal is eating.Dog is eating. 这说明 super 成功调用了父类的方法，并且当前对象依然是 Dog 实例。 三、isKindOf 和 isMemberOf 的底层实现3.1 isKindOfClass 方法isKindOfClass 方法用于判断一个对象是否是某个类或者其子类的实例。其底层实现逻辑如下： 12345678910111213+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 从上述代码可以看出，isKindOfClass 方法会沿着继承链向上查找，逐个比较对象所属类及其父类是否与传入的类相等，只要有一个相等就返回 YES，否则返回 NO。 3.2 isKindOfClass 示例1234567891011121314151617181920212223242526#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject@end@implementation Animal@end@interface Dog : Animal@end@implementation Dog@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog *dog = [[Dog alloc] init]; BOOL result1 = [dog isKindOfClass:[Dog class]]; BOOL result2 = [dog isKindOfClass:[Animal class]]; BOOL result3 = [dog isKindOfClass:[NSObject class]]; NSLog(@&quot;Is dog an instance of Dog: %d&quot;, result1); NSLog(@&quot;Is dog an instance of Animal: %d&quot;, result2); NSLog(@&quot;Is dog an instance of NSObject: %d&quot;, result3); &#125; return 0;&#125; 在这个例子中，Dog 类继承自 Animal 类，Animal 类继承自 NSObject 类。dog 实例调用 isKindOfClass 方法分别判断是否为 Dog、Animal 和 NSObject 类的实例。运行结果如下： 123Is dog an instance of Dog: 1Is dog an instance of Animal: 1Is dog an instance of NSObject: 1 这表明 dog 既是 Dog 类的实例，也是 Animal 类和 NSObject 类的实例，因为 isKindOfClass 会考虑继承关系。 3.3 isMemberOfClass 方法isMemberOfClass 方法用于判断一个对象是否是某个类的直接实例，不包括子类。其底层实现逻辑如下： 1234567+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 从代码可知，isMemberOfClass 方法直接比较对象所属类是否与传入的类相等，只有相等时才返回 YES，否则返回 NO。 3.4 isMemberOfClass 示例123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;@interface Animal : NSObject@end@implementation Animal@end@interface Dog : Animal@end@implementation Dog@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog *dog = [[Dog alloc] init]; BOOL result1 = [dog isMemberOfClass:[Dog class]]; BOOL result2 = [dog isMemberOfClass:[Animal class]]; NSLog(@&quot;Is dog a direct instance of Dog: %d&quot;, result1); NSLog(@&quot;Is dog a direct instance of Animal: %d&quot;, result2); &#125; return 0;&#125; 在这个例子中，dog 实例调用 isMemberOfClass 方法分别判断是否为 Dog 类和 Animal 类的直接实例。运行结果如下： 12Is dog a direct instance of Dog: 1Is dog a direct instance of Animal: 0 这表明 dog 是 Dog 类的直接实例，但不是 Animal 类的直接实例，因为 isMemberOfClass 不考虑继承关系。 四、总结深入理解 objc_msgSend 的三个阶段、super 的本质以及 isKindOf 和 isMemberOf 的底层实现，能让我们更清晰地把握Objective - C的消息机制和继承体系。objc_msgSend 的三个阶段为方法调用提供了极大的灵活性，让我们可以在运行时动态添加和转发方法；super 的本质让我们明白它是如何调用父类方法的；isKindOf 和 isMemberOf 的底层实现则帮助我们准确判断对象与类之间的关系。这些知识对于优化代码性能、解决复杂问题以及实现高级功能都有着重要的意义。希望通过本文的介绍，你能对Objective - C Runtime有更深入的认识。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Runtime（一）","path":"/2022/02/04/探索Objective - C底层 - Runtime（一）/","content":"引言在Objective - C的世界里，Runtime（运行时系统）犹如幕后的神秘操控者，它赋予了这门语言动态特性，使得很多在编译时无法确定的操作能够在运行时灵活处理。了解Runtime的底层原理，对于深入掌握Objective - C编程、优化代码性能以及解决复杂问题都有着至关重要的意义。本文将深入剖析Runtime中的几个核心概念，包括isa指针、class的结构以及方法缓存。 一、isa指针详解1.1 isa指针的基本概念在Objective - C里，几乎所有的对象都是objc_object结构体的实例，而objc_object结构体中最重要的成员就是isa指针。isa指针的主要作用是指向对象所属的类，通过这个指针，对象能够知道自己应该调用哪个类的方法。 下面是objc_object结构体的简化定义： 123struct objc_object &#123; Class isa;&#125;; 这里的Class实际上是一个指向objc_class结构体的指针，也就是说isa指针指向的是一个objc_class类型的实例，这个实例代表了对象所属的类。 1.2 isa的本质在早期的Objective - C版本中，isa 确实只是一个简单的指针，直接指向对象所属的类。但从64位系统开始，isa 不再仅仅是一个单纯的指针，而是被设计成了一个 isa_t 类型的共用体（union）。共用体的特点是所有成员共享同一块内存空间，这使得 isa 可以在有限的内存空间里存储更多的信息。 isa_t 共用体的简化定义如下： 123456789101112131415union isa_t &#123; Class cls; uintptr_t bits; struct &#123; uintptr_t nonpointer : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; &#125;;&#125;; 1.3 isa中存储的内容 nonpointer：这是一个标志位，占1位。当它的值为 0 时，表示 isa 是一个普通的指针，仅存储类的地址；当值为 1 时，意味着 isa 是一个非指针类型，除了存储类的地址外，还会存储其他额外信息。 has_assoc：同样是一个标志位，占1位。用于标记对象是否有关联对象。如果对象使用了 objc_setAssociatedObject 方法关联了其他对象，这个标志位会被置为 1。 has_cxx_dtor：1位的标志位，用于判断对象是否有 C++ 析构函数。若对象有 C++ 析构函数，该标志位为 1，在对象销毁时需要调用相应的析构函数。 shiftcls：占据 33 位，这部分存储的是类的指针值。由于内存对齐的原因，类的地址会有一定的偏移，通过右移操作可以得到真正的类地址。 magic：占 6 位，用于调试时判断对象是否已经完成初始化。 weakly_referenced：1位标志位，用来标记对象是否被弱引用指向。如果对象被弱引用引用，该标志位为 1。 deallocating：1位标志位，指示对象是否正在进行析构操作。 has_sidetable_rc：1位标志位，判断对象的引用计数是否存储在 sidetable 中。当对象的引用计数过大，extra_rc 无法存储时，会将部分引用计数存储在 sidetable 中，此时该标志位为 1。 extra_rc：占据 19 位，存储对象的引用计数。当对象的引用计数增加时，extra_rc 的值会相应增加。 1.4 isa指针的指向规则实例对象的isa指针实例对象的isa指针指向其所属的类。例如，当我们创建一个Person类的实例person时，person对象的isa指针就指向Person类。 类对象的isa指针类对象的isa指针指向元类（meta - class）。元类是一种特殊的类，它存储了类方法的信息。当我们调用一个类方法时，实际上是通过类对象的isa指针找到对应的元类，然后在元类中查找并调用相应的方法。 元类的isa指针元类的isa指针指向根元类（root meta - class）。根元类是所有元类的基类，它的isa指针指向自己，形成一个闭环。 1.5 isa指针的走位图通过一个简单的示例和对应的走位图能更直观地理解isa指针的指向关系。假设我们有一个继承自NSObject的Person类： 12345@interface Person : NSObject@end@implementation Person@end 对应的isa指针走位图如下： 二、class的结构2.1 class的基本结构在Runtime中，类是通过objc_class结构体来表示的。下面是objc_class结构体的简化定义： 123456struct objc_class &#123; Class isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; isa指针前面已经详细介绍过，它指向类的元类，用于确定类方法的查找路径。 superclass指针superclass指针指向父类，通过这个指针可以实现类的继承关系。当在当前类中找不到某个方法时，Runtime会沿着superclass指针的路径到父类中继续查找。 cache（方法缓存）cache是一个cache_t类型的结构体，用于缓存已经调用过的方法，以提高方法查找的效率。后续会详细介绍方法缓存的相关内容。 bits（类的数据信息）bits是一个class_data_bits_t类型的结构体，它存储了类的具体数据信息，包括方法列表、属性列表、协议列表等。 2.2 从bits中获取类的信息通过bits可以获取类的各种信息，例如方法列表、属性列表等。以下是一个简单的示例代码，展示如何获取类的方法列表： 1234567891011121314151617181920212223242526#import &lt;objc/runtime.h&gt;@interface Person : NSObject- (void)sayHello;@end@implementation Person- (void)sayHello &#123; NSLog(@&quot;Hello!&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; unsigned int methodCount = 0; Method *methods = class_copyMethodList([Person class], &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i++) &#123; Method method = methods[i]; SEL selector = method_getName(method); NSString *methodName = NSStringFromSelector(selector); NSLog(@&quot;Method name: %@&quot;, methodName); &#125; free(methods); &#125; return 0;&#125; 在这个示例中，我们使用class_copyMethodList函数从Person类的bits中获取方法列表，并遍历打印出每个方法的名称。 三、方法缓存（cache_t）3.1 方法缓存的作用在Objective - C中，方法调用是一个相对复杂的过程，需要在类及其父类的方法列表中查找对应的方法。为了提高方法调用的效率，Runtime引入了方法缓存机制。当一个方法被调用时，Runtime会将该方法的信息（包括方法名和方法实现）缓存到类的cache中。下次再调用相同方法时，会直接从缓存中查找，避免了重复的方法查找过程，从而显著提高了方法调用的速度。 3.2 cache_t结构体的结构cache_t结构体的简化定义如下： 12345struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;; _buckets_buckets是一个指向bucket_t结构体数组的指针，bucket_t结构体存储了方法的具体信息，包括方法名（SEL）和方法实现（IMP）。以下是bucket_t结构体的简化定义： 1234struct bucket_t &#123; SEL _sel; IMP _imp;&#125;; _mask_mask是一个掩码，用于确定_buckets数组的大小。_mask的值通常是2^n - 1的形式，这样在进行哈希计算时可以更高效。 _occupied_occupied表示当前_buckets数组中已经占用的桶（bucket）的数量。 3.3 cache_t是如何缓存的缓存插入当一个方法被调用时，首先会计算该方法选择器（SEL）的哈希值。通常使用 SEL 的值与 _mask 进行按位与运算（hash = _sel &amp; _mask），以此来确定该方法在 _buckets 数组中的初始位置。 如果计算得到的位置为空，那么直接将该方法的信息（SEL 和 IMP）存储到这个 bucket 中。但如果该位置已经被占用，就会采用开放寻址法（通常是线性探测）来寻找下一个可用的位置。线性探测就是依次检查下一个位置，直到找到一个空的 bucket 为止。 以下是简化的插入逻辑伪代码： 12345678hash = _sel &amp; _mask;index = hash;while (_buckets[index] is not empty) &#123; index = (index + 1) &amp; _mask; // 线性探测，寻找下一个位置&#125;_buckets[index]._sel = _sel;_buckets[index]._imp = _imp;_occupied++; 缓存查找当再次调用相同方法时，同样会先计算该方法选择器（SEL）的哈希值，使用相同的哈希计算方式（hash = _sel &amp; _mask）得到在 _buckets 数组中的初始位置。 然后从这个位置开始检查 bucket 中的 SEL 是否与要查找的 SEL 相等。如果相等，就表示找到了对应的方法，直接调用该 bucket 中的 IMP。如果不相等，就按照线性探测的方式继续检查下一个位置，直到找到匹配的 SEL 或者遍历完整个 _buckets 数组。 以下是简化的查找逻辑伪代码： 123456789hash = _sel &amp; _mask;index = hash;while (_buckets[index] is not empty) &#123; if (_buckets[index]._sel == _sel) &#123; return _buckets[index]._imp; // 找到方法实现，返回 &#125; index = (index + 1) &amp; _mask; // 线性探测，检查下一个位置&#125;return nil; // 未找到方法实现 缓存扩容当 _occupied 的值达到一定阈值（通常是 _mask 的 3/4）时，cache_t 会进行扩容操作。扩容时会创建一个更大的 _buckets 数组，新数组的大小一般是原来的两倍。 然后将原数组中的所有 bucket 重新哈希到新数组中。重新哈希的过程就是对原数组中的每个 bucket 重新计算哈希值，然后根据新的 _mask 确定在新数组中的位置，并将其存储到新位置。 以下是简化的扩容逻辑伪代码： 12345678910111213oldBuckets = _buckets;oldMask = _mask;// 创建新的 _buckets 数组，大小为原来的两倍_newBuckets = createNewBuckets(oldMask * 2 + 1); _mask = oldMask * 2 + 1;_occupied = 0;// 遍历原数组，将每个 bucket 重新哈希到新数组中for (i = 0; i &lt;= oldMask; i++) &#123; if (oldBuckets[i] is not empty) &#123; insertIntoNewBuckets(oldBuckets[i]._sel, oldBuckets[i]._imp); &#125;&#125;free(oldBuckets); 四、总结Objective - C的Runtime系统是一个复杂而强大的机制，其中isa指针、class的结构以及方法缓存是Runtime的核心组成部分。isa指针确定了对象、类和元类之间的关系，其本质是一个 isa_t 共用体，存储了丰富的信息，是方法调用的基础；class的结构存储了类的各种信息，包括方法、属性和协议等；方法缓存则提高了方法调用的效率，减少了不必要的方法查找开销。深入理解这些概念，有助于我们更好地掌握Objective - C的动态特性，优化代码性能，解决开发中遇到的各种问题。 希望通过本文的介绍，你能对Objective - C Runtime有更深入的认识，在实际开发中能够更加灵活地运用这些知识。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Block的底层原理","path":"/2022/01/29/探索Objective-C底层 - Block的底层原理/","content":"引言在Objective - C开发中，Block是一个强大且灵活的特性，它允许开发者将代码块作为对象进行传递和存储。无论是在异步操作、回调机制还是数据处理中，Block都发挥着重要作用。然而，要真正掌握Block的使用，理解其底层原理是必不可少的。本文将深入探讨Block的底层结构、内存管理以及循环引用问题的解决方法。 一、Block的底层结构1.1 Block的本质Block本质上是一个结构体，它封装了一段代码以及该代码执行时所需的上下文信息。在底层，Block结构体包含以下几个关键部分： 1.1.1 isa指针类似于Objective - C对象，Block也有一个isa指针，它指向Block所属的类。根据isa指针的不同，Block可以分为三种类型： NSGlobalBlock：存储在全局数据区，当Block不捕获任何外部变量时，会被创建为全局Block。例如：123void (^globalBlock)(void) = ^&#123; NSLog(@&quot;This is a global block.&quot;);&#125;; NSStackBlock：存储在栈区，当Block捕获了外部变量，但没有进行复制操作时，会被创建为栈Block。栈Block的生命周期与所在的栈帧相同，当栈帧销毁时，栈Block也会失效。例如：1234int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;Captured number: %d&quot;, num);&#125;; NSMallocBlock：存储在堆区，当对栈Block进行复制操作时，会将其复制到堆区，成为堆Block。堆Block的生命周期由开发者管理，需要手动释放。例如：12345int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;Captured number: %d&quot;, num);&#125;;void (^heapBlock)(void) = [stackBlock copy]; 1.1.2 函数指针Block结构体中包含一个函数指针，指向Block实际执行的代码块。当调用Block时，实际上是通过这个函数指针来执行代码。 1.1.3 捕获的变量如果Block捕获了外部变量，这些变量会被存储在Block结构体中。捕获的方式根据变量的类型有所不同： 值捕获：对于基本数据类型的局部变量，Block会捕获其值。在Block定义时，会将变量的值复制到Block结构体中，后续变量值的改变不会影响Block内部的值。123456int num = 10;void (^block)(void) = ^&#123; NSLog(@&quot;Captured num: %d&quot;, num);&#125;;num = 20;block(); // 输出: Captured num: 10 引用捕获：对于__block修饰的变量和对象类型的变量，Block会捕获其引用。在Block内部可以修改__block修饰的变量的值，并且对象的引用计数会相应增加。123456__block int num = 10;void (^block)(void) = ^&#123; num++; NSLog(@&quot;Modified num: %d&quot;, num);&#125;;block(); // 输出: Modified num: 11 1.2 Block的结构体定义以下是简化后的Block结构体定义： 123456789101112131415struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; // 捕获的变量&#125;;struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;; isa：指向Block所属的类。 flags：包含一些标志位，用于描述Block的特性。 invoke：指向Block实际执行的函数。 descriptor：指向Block的描述信息结构体，包含Block的大小、复制和释放函数等。 二、Block的内存管理2.1 复制操作对不同类型的Block进行复制操作会有不同的效果： NSGlobalBlock：复制操作不会产生新的Block，仍然返回原来的Block。因为全局Block存储在全局数据区，其生命周期与程序的生命周期相同，不需要额外的内存管理。 NSStackBlock：复制操作会将栈Block复制到堆区，生成一个NSMallocBlock。这是因为栈Block存储在栈区，其生命周期受栈帧的限制，复制到堆区可以延长其生命周期。 NSMallocBlock：复制操作会增加引用计数。堆Block的内存管理遵循引用计数原则，当引用计数为0时，会自动释放内存。 2.2 释放操作当Block的引用计数为0时，会自动调用其dispose函数进行释放操作。对于捕获了对象的Block，dispose函数会对捕获的对象进行释放，减少对象的引用计数。 2.3 示例代码1234567891011121314151617181920212223242526272829303132@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; __block int num = 10; self.myBlock = ^&#123; num++; NSLog(@&quot;Modified num: %d&quot;, num); &#125;; &#125; return self;&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); // 输出: Modified num: 11 obj = nil; // 触发dealloc &#125; return 0;&#125; 在上述示例中，MyClass的myBlock属性使用了copy修饰符，这会将栈Block复制到堆区。当obj被置为nil时，MyClass的dealloc方法会被调用，同时myBlock的引用计数减为0，会自动释放内存。 三、Block的循环引用问题及解决方法3.1 循环引用的产生循环引用是指两个或多个对象之间相互持有对方的强引用，导致引用计数无法降为0，从而造成内存泄漏。在使用Block时，循环引用通常发生在Block捕获了包含它的对象，并且该对象又持有该Block的情况下。例如： 12345678910111213141516171819202122232425262728293031323334@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; self.myBlock = ^&#123; [self doSomething]; &#125;; &#125; return self;&#125;- (void)doSomething &#123; NSLog(@&quot;Doing something.&quot;);&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); obj = nil; // 不会触发dealloc &#125; return 0;&#125; 在上述示例中，MyClass的myBlock属性持有了一个Block，而该Block又捕获了self（即MyClass对象），形成了循环引用。当obj被置为nil时，由于循环引用的存在，MyClass对象的引用计数无法降为0，dealloc方法不会被调用，导致内存泄漏。 3.2 解决循环引用的方法3.2.1 使用__weak修饰符使用__weak修饰符可以创建一个弱引用，不会增加对象的引用计数。在Block内部使用弱引用可以避免循环引用。例如： 1234567891011121314151617181920212223242526272829303132333435@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; __weak typeof(self) weakSelf = self; self.myBlock = ^&#123; [weakSelf doSomething]; &#125;; &#125; return self;&#125;- (void)doSomething &#123; NSLog(@&quot;Doing something.&quot;);&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); obj = nil; // 触发dealloc &#125; return 0;&#125; 在上述示例中，使用__weak typeof(self) weakSelf = self;创建了一个弱引用weakSelf，并在Block内部使用weakSelf代替self，从而避免了循环引用。当obj被置为nil时，MyClass对象的引用计数降为0，dealloc方法会被调用。 3.2.2 使用__strong修饰符在某些情况下，使用__weak修饰符可能会导致在Block执行过程中对象被提前释放。可以在Block内部使用__strong修饰符创建一个强引用，确保在Block执行期间对象不会被释放。例如： 1234567891011121314151617181920212223242526272829303132333435363738@interface MyClass : NSObject@property (nonatomic, copy) void (^myBlock)(void);@end@implementation MyClass- (instancetype)init &#123; self = [super init]; if (self) &#123; __weak typeof(self) weakSelf = self; self.myBlock = ^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomething]; &#125; &#125;; &#125; return self;&#125;- (void)doSomething &#123; NSLog(@&quot;Doing something.&quot;);&#125;- (void)dealloc &#123; NSLog(@&quot;MyClass deallocated.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyClass *obj = [[MyClass alloc] init]; obj.myBlock(); obj = nil; // 触发dealloc &#125; return 0;&#125; 在上述示例中，在Block内部使用__strong typeof(weakSelf) strongSelf = weakSelf;创建了一个强引用strongSelf，并在使用self之前先判断strongSelf是否为nil，确保在Block执行期间对象不会被释放。 四、总结Block是Objective - C中一个强大而灵活的特性，其底层原理涉及到结构体、内存管理和循环引用等多个方面。通过深入理解Block的底层结构和内存管理机制，开发者可以更好地使用Block，避免内存泄漏和循环引用问题。同时，掌握解决循环引用的方法可以确保代码的健壮性和稳定性。希望本文能帮助开发者更深入地探索Objective - C中Block的奥秘。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Block的基本使用","path":"/2022/01/22/探索Objective-C底层 - Block的基本使用/","content":"引言在Objective - C的世界里，Block是一项强大且独特的特性。它本质上是一种自包含的代码块，能够像对象一样被传递、存储和执行，这极大地增强了代码的灵活性和可复用性。Block在iOS和macOS开发中有着广泛的应用，比如在回调、排序、动画等场景中都能看到它的身影。本文将详细介绍Block的基本使用，帮助开发者更好地掌握这一重要特性。 一、Block的定义与基本语法1.1 什么是BlockBlock，也被称为闭包，它是一段可以在将来某个时间点执行的代码。Block可以捕获其所在上下文的变量，并且能够作为参数传递给其他函数或方法，也能作为返回值返回。 1.2 基本语法无参数无返回值的Block1234567// 定义一个无参数无返回值的Blockvoid (^simpleBlock)(void) = ^&#123; NSLog(@&quot;This is a simple block.&quot;);&#125;;// 调用BlocksimpleBlock(); 在上述代码中，void (^simpleBlock)(void) 定义了一个名为 simpleBlock 的Block，它没有参数，也没有返回值。^&#123; ... &#125; 是Block的实现部分，最后通过 simpleBlock(); 来调用这个Block。 有参数有返回值的Block12345678// 定义一个有两个整数参数并返回整数的Blockint (^addBlock)(int, int) = ^(int a, int b) &#123; return a + b;&#125;;// 调用Block并获取返回值int result = addBlock(3, 5);NSLog(@&quot;The result of addition is: %d&quot;, result); 这里，int (^addBlock)(int, int) 定义了一个名为 addBlock 的Block，它接受两个 int 类型的参数，并返回一个 int 类型的值。^(int a, int b) &#123; ... &#125; 是Block的实现，其中 (int a, int b) 是参数列表，return a + b; 是返回值。 二、Block捕获外部变量2.1 捕获局部变量Block可以捕获其所在上下文的局部变量，但需要注意的是，Block捕获的是局部变量的值，而不是变量本身。 12345678910int num = 10;void (^captureBlock)(void) = ^&#123; NSLog(@&quot;The captured number is: %d&quot;, num);&#125;;// 修改外部变量的值num = 20;// 调用BlockcaptureBlock(); // 输出: The captured number is: 10 在这个例子中，captureBlock 捕获了局部变量 num 的值，即使在Block定义之后修改了 num 的值，Block内部使用的仍然是捕获时的值。 2.2 捕获静态变量和全局变量捕获静态变量静态变量会被Block捕获其地址，因此在Block内部可以修改静态变量的值，并且修改会影响到外部的静态变量。 12345678static int staticNum = 10;void (^modifyStaticBlock)(void) = ^&#123; staticNum++; NSLog(@&quot;The modified static number is: %d&quot;, staticNum);&#125;;// 调用BlockmodifyStaticBlock(); // 输出: The modified static number is: 11 捕获全局变量全局变量不会被Block捕获，Block会直接使用全局变量。因此在Block内部修改全局变量的值会影响到外部。 12345678int globalNum = 10;void (^modifyGlobalBlock)(void) = ^&#123; globalNum++; NSLog(@&quot;The modified global number is: %d&quot;, globalNum);&#125;;// 调用BlockmodifyGlobalBlock(); // 输出: The modified global number is: 11 2.3 __block 修饰符如果想要在Block内部修改外部局部变量的值，可以使用 __block 修饰符。使用 __block 修饰的变量会被封装成一个结构体，Block捕获的是该结构体的地址。 12345678__block int blockNum = 10;void (^modifyBlockNum)(void) = ^&#123; blockNum++; NSLog(@&quot;The modified block number is: %d&quot;, blockNum);&#125;;// 调用BlockmodifyBlockNum(); // 输出: The modified block number is: 11 三、Block作为参数传递3.1 自定义函数中使用Block参数12345678910111213// 定义一个接受Block作为参数的函数void performOperation(int a, int b, int (^operation)(int, int)) &#123; int result = operation(a, b); NSLog(@&quot;The result of the operation is: %d&quot;, result);&#125;// 定义一个加法Blockint (^add)(int, int) = ^(int a, int b) &#123; return a + b;&#125;;// 调用函数并传递BlockperformOperation(3, 5, add); 在这个例子中，performOperation 函数接受两个整数和一个Block作为参数，在函数内部调用这个Block并输出结果。 3.2 在系统API中使用Block参数在iOS开发中，很多系统API都使用了Block作为参数，比如数组排序。 12345NSArray *numbers = @[@3, @1, @4, @2];NSArray *sortedNumbers = [numbers sortedArrayUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) &#123; return [obj1 compare:obj2];&#125;];NSLog(@&quot;The sorted numbers are: %@&quot;, sortedNumbers); 这里，sortedArrayUsingComparator: 方法接受一个Block作为参数，这个Block定义了排序的规则。 四、Block作为返回值12345678910111213// 定义一个返回Block的函数int (^returnBlock())(int, int) &#123; return ^(int a, int b) &#123; return a * b; &#125;;&#125;// 调用函数获取Blockint (^multiplyBlock)(int, int) = returnBlock();// 调用Blockint product = multiplyBlock(3, 5);NSLog(@&quot;The product is: %d&quot;, product); 在这个例子中，returnBlock 函数返回一个Block，这个Block实现了两个整数相乘的功能。 五、Block的内存管理5.1 Block的类型根据存储位置的不同，Block可以分为以下三种类型： NSGlobalBlock：当Block不捕获任何外部变量时，会被创建为全局Block，存储在全局数据区。1234void (^globalBlock)(void) = ^&#123; NSLog(@&quot;This is a global block.&quot;);&#125;;NSLog(@&quot;The class of globalBlock is: %@&quot;, [globalBlock class]); // 输出: __NSGlobalBlock__ NSStackBlock：当Block捕获了外部变量，但没有进行复制操作时，会被创建为栈Block，存储在栈区。栈Block在其所在的栈帧销毁后就会失效。12345int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;The number is: %d&quot;, num);&#125;;NSLog(@&quot;The class of stackBlock is: %@&quot;, [stackBlock class]); // 输出: __NSStackBlock__ NSMallocBlock：当对栈Block进行复制操作时，会将其复制到堆区，成为堆Block。堆Block的生命周期由开发者管理。123456int num = 10;void (^stackBlock)(void) = ^&#123; NSLog(@&quot;The number is: %d&quot;, num);&#125;;void (^heapBlock)(void) = [stackBlock copy];NSLog(@&quot;The class of heapBlock is: %@&quot;, [heapBlock class]); // 输出: __NSMallocBlock__ 5.2 复制和释放操作对不同类型的Block进行复制操作会有不同的效果： NSGlobalBlock：复制操作不会产生新的Block，仍然返回原来的Block。 NSStackBlock：复制操作会将栈Block复制到堆区，生成一个NSMallocBlock。 NSMallocBlock：复制操作会增加引用计数。 当Block的引用计数为0时，会自动调用其 dispose 函数进行释放操作。对于捕获了对象的Block，dispose 函数会对捕获的对象进行释放。 六、Block使用中的注意事项6.1 循环引用问题如果Block捕获了包含它的对象，并且该对象又持有该Block，就会产生循环引用。可以使用 __weak 修饰符来避免循环引用。 1234__weak typeof(self) weakSelf = self;self.block = ^&#123; [weakSelf doSomething];&#125;; 6.2 线程安全问题在多线程环境下使用Block时，需要注意线程安全问题。特别是在修改共享数据时，需要进行适当的同步操作。 七、总结Block是Objective - C中一个非常强大的特性，它为开发者提供了一种简洁、高效的方式来处理代码块。通过本文的介绍，我们了解了Block的基本定义、语法、变量捕获、作为参数和返回值的使用、内存管理以及使用中的注意事项。掌握这些基本使用方法，将有助于开发者在实际开发中更加灵活地运用Block，提高代码的质量和可维护性。希望本文能对开发者们有所帮助。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - KVC","path":"/2022/01/15/探索Objective-C底层 - KVC/","content":"引言在Objective - C开发中，Key - Value Coding（KVC）是一项强大且基础的特性。它提供了一种通过属性名（键）间接访问和修改对象属性的方式，而不是直接调用对象的存取方法。这种机制使得代码更加灵活和动态，在许多框架和库中被广泛使用。本文将深入探讨KVC的底层原理、使用方法、应用场景以及可能遇到的问题。 一、KVC基础概念与基本用法1.1 什么是KVCKVC是一种使用字符串（键）来间接访问和修改对象属性的机制。它允许开发者在运行时通过键来获取和设置对象的属性值，而不需要直接调用对象的存取方法。KVC的核心在于NSKeyValueCoding协议，该协议定义了一系列方法，如valueForKey:、setValue:forKey:等，任何遵循该协议的类都可以使用KVC。 1.2 基本用法示例12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; // 使用KVC设置属性值 [person setValue:@&quot;John&quot; forKey:@&quot;name&quot;]; [person setValue:@25 forKey:@&quot;age&quot;]; // 使用KVC获取属性值 NSString *name = [person valueForKey:@&quot;name&quot;]; NSNumber *age = [person valueForKey:@&quot;age&quot;]; NSLog(@&quot;Name: %@, Age: %@&quot;, name, age); &#125; return 0;&#125; 在上述示例中，我们创建了一个Person类，通过setValue:forKey:方法设置属性值，通过valueForKey:方法获取属性值。 二、KVC的底层实现原理2.1 setValue:forKey:方法的查找与赋值过程当调用setValue:forKey:方法时，Objective - C运行时会按照以下步骤进行查找和赋值： 查找设置方法：首先会查找以set&lt;Key&gt;:命名的方法，如果找到则调用该方法进行赋值，如果没找到，则查找以_set&lt;Key&gt;:命名的方法。例如，对于键name，会查找setName:方法。 查找实例变量：如果没有找到设置方法，会查找名为_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的实例变量，直接对其进行赋值。 **调用setValue:forUndefinedKey:**：如果以上步骤都没有找到合适的方法或实例变量，会调用setValue:forUndefinedKey:方法，默认情况下该方法会抛出异常。 2.2 valueForKey:方法的查找与取值过程当调用valueForKey:方法时，运行时会按照以下步骤进行查找和取值： 查找获取方法：首先会查找以&lt;key&gt;、get&lt;Key&gt;、is&lt;Key&gt;、_&lt;Key&gt;命名的方法，如果找到则调用该方法获取值。 查找实例变量：如果没有找到获取方法，会查找名为_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的实例变量，直接获取其值。 **调用valueForUndefinedKey:**：如果以上步骤都没有找到合适的方法或实例变量，会调用valueForUndefinedKey:方法，默认情况下该方法会抛出异常。 三、KVC的高级用法3.1 访问嵌套对象属性KVC支持通过点语法访问嵌套对象的属性。例如： 1234567891011121314151617181920212223242526@interface Address : NSObject@property (nonatomic, copy) NSString *city;@end@implementation Address@end@interface Person : NSObject@property (nonatomic, strong) Address *address;@end@implementation Person@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; Address *address = [[Address alloc] init]; address.city = @&quot;New York&quot;; person.address = address; NSString *city = [person valueForKeyPath:@&quot;address.city&quot;]; NSLog(@&quot;City: %@&quot;, city); &#125; return 0;&#125; 在上述示例中，我们通过valueForKeyPath:方法访问了Person对象中address属性的city属性。 3.2 集合操作KVC还支持对集合对象进行操作，如求和、平均值、最大值、最小值等。例如： 1234567NSArray *numbers = @[@1, @2, @3, @4, @5];NSNumber *sum = [numbers valueForKeyPath:@&quot;@sum.self&quot;];NSNumber *average = [numbers valueForKeyPath:@&quot;@avg.self&quot;];NSNumber *max = [numbers valueForKeyPath:@&quot;@max.self&quot;];NSNumber *min = [numbers valueForKeyPath:@&quot;@min.self&quot;];NSLog(@&quot;Sum: %@, Average: %@, Max: %@, Min: %@&quot;, sum, average, max, min); 在上述示例中，我们使用了@sum、@avg、@max、@min等集合操作符对数组进行操作。 四、KVC的应用场景4.1 数据模型与视图的绑定在iOS开发中，KVC可以用于将数据模型的属性与视图的属性进行绑定。例如，将一个User对象的name属性绑定到一个UILabel的text属性： 1234567891011121314@interface User : NSObject@property (nonatomic, copy) NSString *name;@end@implementation User@end- (void)bindDataToView &#123; User *user = [[User alloc] init]; user.name = @&quot;Alice&quot;; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 100, 30)]; [label setValue:user.name forKey:@&quot;text&quot;]; [self.view addSubview:label];&#125; 4.2 字典与模型的转换KVC可以方便地将字典中的数据映射到对象的属性上，实现字典与模型的转换。例如： 1234567891011@interface Person : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end@implementation Person@endNSDictionary *personDict = @&#123;@&quot;name&quot;: @&quot;Bob&quot;, @&quot;age&quot;: @30&#125;;Person *person = [[Person alloc] init];[person setValuesForKeysWithDictionary:personDict]; 五、KVC可能遇到的问题及解决方案5.1 键不存在的问题当使用setValue:forKey:或valueForKey:方法时，如果键不存在，默认会抛出异常。可以通过重写setValue:forUndefinedKey:和valueForUndefinedKey:方法来避免异常的抛出： 123456789101112@implementation Person- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; // 处理键不存在的情况 NSLog(@&quot;Undefined key: %@&quot;, key);&#125;- (id)valueForUndefinedKey:(NSString *)key &#123; // 处理键不存在的情况 NSLog(@&quot;Undefined key: %@&quot;, key); return nil;&#125;@end 5.2 类型不匹配的问题当使用KVC设置属性值时，如果值的类型与属性的类型不匹配，可能会导致运行时错误。可以在设置值之前进行类型检查和转换： 1234567- (void)setAgeValue:(id)value &#123; if ([value isKindOfClass:[NSNumber class]]) &#123; self.age = [value integerValue]; &#125; else if ([value isKindOfClass:[NSString class]]) &#123; self.age = [value integerValue]; &#125;&#125; 六、总结KVC是Objective - C中一项非常重要的特性，它提供了一种灵活、动态的方式来访问和修改对象的属性。通过深入了解KVC的底层原理、高级用法和应用场景，开发者可以更好地利用这一特性来提高代码的可维护性和灵活性。同时，在使用KVC时，也需要注意可能遇到的问题，并采取相应的解决方案。 希望本文能够帮助你更深入地理解Objective - C中的KVC机制，在实际开发中更加得心应手地使用它。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - KVO","path":"/2022/01/10/探索Objective-C底层 - KVO/","content":"引言Key-Value Observing（KVO）是Objective-C语言中实现数据变化监听的核心机制。其底层通过动态生成子类、修改isa指针、重写setter方法等技术实现。本文将从以下维度深入剖析KVO的运行机制： 一、KVO的基础认知1.1 基本用法12345678910111213// 注册观察者[self addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];// 实现观察方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; // 处理属性变化&#125;// 移除观察者[self removeObserver:self forKeyPath:@&quot;name&quot;]; 1.2 核心特性 自动通知：属性变化时自动触发回调 支持嵌套观察：可监听对象的属性链 两种触发方式：自动触发（默认）和手动触发 性能优化：基于isa指针的动态子类实现 二、KVO的底层实现原理2.1 isa指针的动态修改123456789101112131415// 原始对象@interface Person : NSObject@property (nonatomic, copy) NSString *name;@end// 被KVO监听后生成的子类@implementation NSKVONotifying_Person- (void)setName:(NSString *)name &#123; // 调用父类setter [super setName:name]; // 触发观察通知 [self willChangeValueForKey:@&quot;name&quot;]; [self didChangeValueForKey:@&quot;name&quot;];&#125;@end 2.2 动态子类生成流程 注册观察者时生成子类 子类继承自原始类 子类重写所有被观察属性的setter方法 子类isa指针指向该动态子类 2.3 关键结构体12345678// NSKeyValueObserver结构体struct NSKeyValueObserver &#123; Class _cls; struct NSKeyValueObserver *next; NSString *keyPath; SEL callbackSEL; // 其他字段...&#125;; 三、KVO的触发机制3.1 自动触发流程 调用属性setter方法 子类setter方法调用willChangeValueForKey: 调用父类setter方法更新属性 调用didChangeValueForKey:触发通知 3.2 手动触发方式123[self willChangeValueForKey:@&quot;age&quot;];self-&gt;_age = newValue;[self didChangeValueForKey:@&quot;age&quot;]; 3.3 通知传递路径1setter方法 → NSKVONotifying子类 → Foundation → 观察者回调 四、KVO的内存管理4.1 观察者注册与移除1234// 正确移除方式- (void)dealloc &#123; [self removeObserver:self forKeyPath:@&quot;name&quot;];&#125; 4.2 循环引用问题123// 错误示例：导致循环引用self.observer = [[Observer alloc] init];[self.observer addObserver:self forKeyPath:@&quot;value&quot; ...]; 4.3 弱引用管理12345// 使用弱引用来避免循环__weak typeof(self) weakSelf = self;self.observer = [[Observer alloc] initWithBlock:^(id value) &#123; [weakSelf handleValue:value];&#125;]; 五、KVO与KVC的关系5.1 依赖关系 KVO基于KVC实现属性访问 KVC提供valueForKey:和setValue:forKey:方法 KVO通过KVC修改属性值 5.2 核心方法1234567// KVC设置属性[self setValue:@&quot;newName&quot; forKey:@&quot;name&quot;];// KVO自动触发通知[self willChangeValueForKey:@&quot;name&quot;];[self setPrimitiveValue:@&quot;newName&quot; forKey:@&quot;name&quot;];[self didChangeValueForKey:@&quot;name&quot;]; 六、KVO的高级应用6.1 监听集合属性1234567891011// 监听数组变化[self addObserver:self forKeyPath:@&quot;friends&quot; options:NSKeyValueObservingOptionNew context:nil];// 处理数组变化- (void)observeValueForKeyPath:(NSString *)keyPath ... &#123; if ([keyPath isEqualToString:@&quot;friends&quot;]) &#123; NSArray *oldFriends = change[NSKeyValueChangeOldKey]; NSArray *newFriends = change[NSKeyValueChangeNewKey]; // 处理数组变更 &#125;&#125; 6.2 深度监听12// 监听嵌套对象属性[self addObserver:self forKeyPath:@&quot;user.name&quot; options:NSKeyValueObservingOptionNew context:nil]; 6.3 自定义通知行为1234// 自定义通知选项[self addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; 七、KVO的常见问题7.1 通知未触发 未正确调用setter方法 使用setValue:forKey:时未遵循KVC规范 未注册观察者或错误移除观察者 7.2 性能问题 过度使用KVO导致大量通知回调 监听深层嵌套对象引发性能开销 动态子类生成带来的内存消耗 7.3 线程安全问题 跨线程修改属性导致通知顺序混乱 观察者回调在非主线程执行 八、KVO与其他技术的对比8.1 与Delegate的对比 特性 KVO Delegate 耦合度 低 高 扩展性 支持多个观察者 一对一关系 灵活性 自动触发 需手动调用 调试难度 较高 较低 8.2 与Notification的对比 特性 KVO Notification 监听范围 特定属性 全局事件 性能 较高 较低 内存管理 需手动移除观察者 自动释放 数据传递 直接获取变更值 通过字典传递 九、总结KVO的本质是： 基于运行时的动态子类机制 isa指针的动态修改 属性变更的自动通知系统 掌握KVO底层原理能帮助开发者： 正确使用KVO避免内存泄漏 优化属性监听逻辑 解决复杂数据同步问题 理解iOS框架的数据绑定机制 建议通过以下方式深入学习： 分析objc源码中的NSKeyValueObserver结构体 使用LLDB调试动态子类生成过程 研究NSKeyValueChange枚举的使用场景 实现自定义KVO框架 附录：关键技术点 isa-swizzling：修改对象的isa指针指向动态子类 NSKVONotifying：自动生成的子类前缀 willChangeValueForKey:&#x2F;**didChangeValueForKey:**：触发通知的核心方法 NSKeyValueObservingOption：通知选项枚举 KVO调试命令：po [object class]查看动态子类 通过对KVO底层原理的深入探索，我们能更高效地利用这一强大机制，构建出响应式强、可维护性高的iOS应用。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - Category","path":"/2022/01/07/探索Objective-C底层 - Category/","content":"引言Category（类别）是Objective-C语言的重要特性之一，允许在不修改原有类的情况下为其添加方法。理解Category的底层实现原理，对于掌握OC动态特性、优化代码结构至关重要。本文将从以下维度展开深入分析： 一、Category的基础认知1.1 基本用法1234567891011// NSString+Additions.h@interface NSString (Additions)- (NSString *)reverseString;@end// NSString+Additions.m@implementation NSString (Additions)- (NSString *)reverseString &#123; // 实现字符串反转&#125;@end 1.2 核心特性 动态扩展：无需修改原类即可添加方法 模块化设计：将类的功能拆分成多个文件 方法覆盖：Category的方法会覆盖原类方法 无实例变量：不能直接添加实例变量 二、Category的底层结构2.1 objc_category结构体123456789// objc-runtime-new.h中的定义struct category_t &#123; const char *name; // 类名 classref_t cls; // 类引用 struct method_list_t *instanceMethods; // 实例方法 struct method_list_t *classMethods; // 类方法 struct protocol_list_t *protocols; // 协议 struct property_list_t *instanceProperties; // 实例属性&#125;; 2.2 编译产物分析通过clang -rewrite-objc生成C++代码： 12345678910111213141516171819202122// 原始OC代码@interface NSString (Additions)@property (nonatomic, copy) NSString *desc;- (void)print;@end// 转换后的C++代码static struct /*_category_t*/ &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties;&#125; _OBJC_$_CATEGORY_NSString_$_Additions __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123; &quot;NSString&quot;, 0, // &amp;OBJC_CLASS_$_NSString, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_NSString_$_Additions, 0, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_NSString_$_Additions&#125;; 三、Category的加载与合并过程3.1 加载流程 编译阶段生成category_t结构体 链接阶段合并到Mach-O文件的__objc_const段 运行时通过_read_images函数处理所有category 3.2 方法合并机制123456789101112131415161718// objc-runtime-new.mm中的核心逻辑void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses) &#123; // 处理所有category for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 合并方法、协议、属性 if (cat-&gt;instanceMethods) &#123; addUnattachedCategoryForClass(cls, cat); &#125; &#125; &#125; // 最终合并到类结构中 attachCategories(..., cats_list, cats_count);&#125; 3.3 方法覆盖优先级 当前类方法 Category方法（后编译的Category优先） 父类方法 四、Category的动态行为4.1 方法决议1234567+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(dynamicMethod)) &#123; class_addMethod(self, sel, (IMP)dynamicMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 4.2 消息转发123456- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if ([self respondsToSelector:aSelector]) &#123; return self; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 五、Category的内存管理5.1 关联对象（Associated Object）12345// 添加关联对象objc_setAssociatedObject(self, &amp;AssociatedKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);// 获取关联对象id value = objc_getAssociatedObject(self, &amp;AssociatedKey); 5.2 内存泄漏场景12// 错误用法：导致循环引用objc_setAssociatedObject(self, &amp;kAssociatedKey, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC); 六、Category与其他技术的对比6.1 与继承的对比 特性 Category 继承 代码修改 无需修改原类 需要创建子类 方法覆盖 可覆盖原类方法 需重写父类方法 实例变量 不可添加 可添加新实例变量 编译依赖 动态加载 静态依赖 6.2 与Extension的对比 特性 Category Extension 声明位置 .h文件 .m文件 方法实现 必须在.m文件 可隐式实现 访问控制 公开方法 通常为私有方法 作用域 全局可见 仅限当前类 七、Category的应用场景7.1 模块化开发将类的不同功能拆分到多个Category： 1234567@interface UIViewController (Network)- (void)fetchData;@end@interface UIViewController (UI)- (void)updateUI;@end 7.2 修复系统类缺陷为NSString添加安全处理方法： 123@interface NSString (Safety)- (NSString *)safeStringByTrimmingWhitespace;@end 7.3 实现AOP通过Category进行方法交换： 123456789101112@implementation UIViewController (AOP)+ (void)load &#123; Method originalMethod = class_getInstanceMethod(self, @selector(viewDidLoad)); Method swizzledMethod = class_getInstanceMethod(self, @selector(aop_viewDidLoad)); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;- (void)aop_viewDidLoad &#123; [self aop_viewDidLoad]; NSLog(@&quot;View did load&quot;);&#125;@end 八、Category的常见问题8.1 方法覆盖导致的问题12345678// 两个Category声明同名方法@interface NSString (A)- (void)log;@end@interface NSString (B)- (void)log;@end 8.2 内存泄漏12// 未正确释放关联对象objc_setAssociatedObject(self, &amp;key, [NSObject new], OBJC_ASSOCIATION_RETAIN_NONATOMIC); 8.3 二进制兼容性问题123// 跨版本添加方法导致崩溃NSString *str = @&quot;test&quot;;[str newMethod]; // 旧版本不存在该方法 九、总结Category的本质是： 运行时动态扩展机制 方法集合的动态合并 OC语言动态特性的重要体现 掌握Category底层原理能帮助开发者： 合理设计代码结构 避免方法冲突 正确使用关联对象 实现高级编程技巧（如AOP） 建议通过以下方式深入学习： 分析objc源码中的_read_images函数 使用class-dump查看Category结构 通过LLDB调试方法合并过程 研究关联对象的内存管理策略 附录：关键技术点 objc_category结构体：存储Category元数据 方法合并流程：_read_images -&gt; attachCategories 关联对象API：objc_setAssociatedObject&#x2F;objc_getAssociatedObject 编译命令：clang -rewrite-objc -fobjc-arc YourFile.m 调试工具：class-dump, LLDB, Dyld 通过对Category底层原理的深入探索，我们能更高效地利用这一强大特性，写出结构清晰、扩展性强的iOS代码。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - OC对象的本质","path":"/2022/01/04/探索Objective-C底层 - OC对象的本质/","content":"引言Objective-C（OC）对象是iOS开发的核心抽象单元。理解OC对象的本质需要深入剖析其底层结构、内存布局以及运行时行为。本文将从以下维度展开详细分析： 一、OC对象的底层结构1.1 objc_object结构体OC对象在底层由objc_object结构体表示： 1234// objc.h中的定义struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; isa指针：指向对象的类（Class） 内存布局：对象实例变量存储在isa指针之后的内存区域 1.2 类对象的结构类对象由objc_class结构体构成： 12345struct objc_class : objc_object &#123; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 类数据存储&#125;; 1.3 实例变量的存储123456789101112@interface Person : NSObject &#123; NSString *_name; // 实例变量 int _age;&#125;@end// 底层内存布局struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; // 继承自NSObject NSString *_name; int _age;&#125;; 二、isa指针的深度解析2.1 isa指针的作用 指向对象的类（Class） 决定对象的行为和属性 运行时消息传递的核心依据 2.2 isa指针的优化 non-pointer isa（64位系统）： 存储类指针 包含对象的引用计数 标记对象是否被释放 标记是否为弱引用对象 2.3 isa指针的调试通过LLDB可以查看isa指针的值： 12345(lldb) po [person class]Person(lldb) p/x person-&gt;isa(unsigned long) $0 = 0x00000001000025d8 三、类与元类的层级关系3.1 类对象的构成 实例对象：通过alloc创建的对象 类对象：存储实例方法、属性、协议 元类对象：存储类方法 3.2 类的继承体系1NSObject ← Person ← Student 3.3 根元类 NSObject的元类称为根元类 根元类的isa指针指向自身 形成类层级的闭环结构 四、对象的创建与销毁4.1 对象创建流程 调用alloc分配内存 初始化isa指针 调用init方法 关联对象处理 4.2 内存分配机制 zone：早期用于管理对象内存 tls：线程本地存储 散列表：快速查找可用内存块 4.3 对象销毁流程 调用dealloc方法 释放实例变量 调用super dealloc 内存回收 五、对象的内存管理5.1 引用计数机制12345678- (void)retain &#123; _Nonnull self; return ((id)self)-&gt;rootRetain();&#125;- (oneway void)release &#123; ((id)self)-&gt;rootRelease();&#125; 5.2 ARC的底层实现 __strong：强引用 __weak：弱引用 __unsafe_unretained：不安全的非保留引用 5.3 自动释放池123@autoreleasepool &#123; // 自动释放对象&#125; 六、OC对象的高级特性6.1 关联对象（Associated Object）12objc_setAssociatedObject(self, &amp;key, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);objc_getAssociatedObject(self, &amp;key); 6.2 动态类型检查123if ([object isKindOfClass:[NSString class]]) &#123; // 类型检查&#125; 6.3 方法替换123Method originalMethod = class_getInstanceMethod([self class], @selector(originalMethod));Method swizzledMethod = class_getInstanceMethod([self class], @selector(swizzledMethod));method_exchangeImplementations(originalMethod, swizzledMethod); 七、OC对象的调试技巧7.1 使用class-dump分析类结构1class-dump -H YourApp -o Headers 7.2 查看对象内存布局1po malloc_size((__bridge const void *)(object)) 7.3 分析isa指针12(lldb) p/x object-&gt;isa(lldb) p (Class)object-&gt;isa 八、总结OC对象的本质是： 结构体实例：由isa指针和实例变量构成 动态实体：行为由运行时决定 内存管理单元：遵循引用计数规则 掌握对象的底层原理可以帮助我们： 优化内存使用 解决野指针问题 实现高级编程技巧（如AOP） 深入理解iOS框架设计 建议通过以下方式深入学习： 阅读Apple开源objc4源码 使用Clang进行代码转换 通过LLDB调试对象生命周期 分析内存分配工具（如Heapshot） 附录：关键术语对照表 术语 说明 objc_object 对象的底层结构体 isa指针 指向类的指针 元类 存储类方法的类 方法缓存 提升消息传递效率 关联对象 为类添加动态属性 自动释放池 管理临时对象的内存 引用计数 内存管理的核心机制 通过对OC对象本质的深入探究，我们能够更好地理解iOS系统的运行机制，写出更高效、健壮的代码。","categories":["iOS","Objective-C底层原理"]},{"title":"探索Objective-C底层 - OC的本质","path":"/2022/01/01/探索Objective-C底层 - OC的本质/","content":"引言Objective-C（简称OC）作为iOS开发的核心语言，其底层实现机制一直是开发者进阶的必经之路。理解OC的本质不仅能帮助我们写出更高效的代码，还能深入掌握iOS运行时机制、内存管理等底层逻辑。本文将从以下几个维度展开分析： 一、OC的运行时机制（Objective-C Runtime）OC是一门动态语言，其核心特性依赖于objc库实现。运行时机制在程序运行时动态处理类、对象、方法调用等操作，主要包含以下核心组件： 1.1 objc库的核心结构123456789// objc.h中定义的核心结构体struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; // 其他字段...&#125;;struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 1.2 动态语言特性 动态类型（Dynamic Typing）：对象类型检查在运行时完成 动态绑定（Dynamic Binding）：方法调用与实现的绑定在运行时确定 动态加载（Dynamic Loading）：程序运行时可加载新代码 二、对象与类的底层结构2.1 对象的本质OC对象在底层由objc_object结构体表示： 123struct objc_object &#123; Class isa;&#125;; isa指针：指向对象的类（Class） 类对象：存储方法列表、属性列表等元数据 2.2 类的结构类对象由objc_class结构体构成： 123456struct objc_class : objc_object &#123; // Class ISA; 继承自objc_object Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 类数据&#125;; 2.3 元类（Meta Class） 每个类都有对应的元类 元类存储类方法（Class Method） 根元类（Root Meta Class）的isa指针指向自身 三、消息传递与转发机制3.1 消息传递（Message Passing）OC的方法调用本质是消息传递： 12345// OC代码[person run];// 底层实现objc_msgSend(person, @selector(run)); 3.2 SEL与IMP SEL（Selector）：方法选择器，唯一标识一个方法 IMP（Implementation）：方法的具体实现，指向函数指针 3.3 动态方法决议1234567+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(run)) &#123; class_addMethod(self, sel, (IMP)runFunction, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 3.4 消息转发 快速转发（Fast Forwarding） 标准转发（Standard Forwarding） 完整转发流程示例：1234567891011- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return otherObject;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; // 返回方法签名&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // 处理未识别的消息&#125; 四、内存管理机制4.1 引用计数（Reference Counting） retainCount：对象当前的引用计数 retain&#x2F;release&#x2F;autorelease：手动管理内存 autoreleasepool：自动释放池实现原理 4.2 ARC的底层实现 LLVM编译器自动插入内存管理代码 __strong&#x2F;__weak&#x2F;__unsafe_unretained修饰符 弱引用表（Side Table）的实现机制 4.3 僵尸对象（Zombie Object） 调试工具：NSZombieEnabled 原理：对象释放后变为僵尸对象，防止野指针 五、OC与C++的关联5.1 OC的动态特性与C++的对比 特性 OC C++ 多态 动态绑定 静态绑定 内存管理 ARC&#x2F;MRC 手动管理 类型检查 运行时 编译时 5.2 OC类的C++实现通过clang -rewrite-objc命令可以将OC代码转换为C++： 12345678910// OC代码@interface Person : NSObject@property (nonatomic, copy) NSString *name;@end// 转换后的C++代码struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;; 六、总结OC的本质是基于C语言的动态语言扩展，其底层实现涉及： 对象与类的结构设计 消息传递与转发机制 内存管理策略 动态语言特性 掌握这些底层原理能帮助开发者： 写出更高效、健壮的代码 深入理解iOS框架设计思想 解决复杂的内存问题 实现高级特性（如AOP、热更新） 建议开发者通过以下方式深入学习： 阅读Apple官方文档《Objective-C Runtime Programming Guide》 分析objc源码（Apple开源代码） 使用class-dump分析二进制文件 通过LLDB调试运行时行为 附录：常用工具与命令 clang -rewrite-objc：将OC代码转换为C++ class-dump：解析二进制文件的类结构 malloc_history：追踪内存分配 NSZombieEnabled：调试僵尸对象 objc_msgsend：手动发送消息 通过深入理解OC的底层原理，我们能真正掌握iOS开发的核心逻辑，写出更优秀的应用程序。","categories":["iOS","Objective-C底层原理"]}]