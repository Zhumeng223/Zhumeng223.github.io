[{"title":"12种Flutter开发工具推荐","path":"/2024/03/10/12种Flutter开发工具推荐/","content":"Panache：Flutter material 主题编辑器 Panache 是Flutter 的开源、基于浏览器的 material 主题编辑器，可让你为 Flutter 应用创建美观且可高度自定义的主题。使用这个 Flutter 开发工具，你可以自定义组件和小部件的颜色，并将主题导出为 theme.dart 文件。 项目地址 https://rxlabz.github.io/panache Supernova：Flutter 设计到代码工具 Supernova 是一款功能强大的设计到代码工具，可将你的 Sketch 和 Adobe XD 移动设计转换为适用于 iOS、Android、ReactNative，当然还有 Flutter 的原生前端代码。导入应用设计时，Supernova 还可以处理资产创建和重复数据删除工作，并允许你编辑设计并实时查看代码更改。Supernova 目前仅提供了 macOS 应用，但很快就会发布云端版本。 项目地址 https://supernova.io/ Codemagic：FlutterCI&#x2F;CD 工具 Codemagic 是 Nevercode 创建的第一个专注于 Flutter 的 CI&#x2F;CD 工具。它可以轻松识别你的 Flutter 应用，并与所有你喜欢的工具集成，以自动化你的整个构建、测试和发布流程。Codemagic 还相当实惠，每月提供 500 个免费的 Mac mini 构建分钟，以及按需付费的额外分钟计费方案。 项目地址 https://codemagic.io/ Sylph：Flutter 设备农场测试工具 Sylph 是由 Maurice McCabe 创建的开源命令行工具，本质上是 AWS 设备农场的包装器。借助 Sylph，你可以在 AWS 设备农场中一次在数百个真实的 iOS 和 Android 设备上运行 Flutter 集成和端到端测试。 项目地址 https://pub.dev/packages/sylph Amplitude：Flutter 应用内分析工具 Amplitude 是一种著名的应用内分析工具，可帮助你了解用户如何与你的应用交互。现在，它也是一种流行的 Flutter 开发工具，可以帮助你跟踪和监视各种数据，并与所有流行的移动应用开发流程集成，从而使你能够根据数据采取行动。 项目地址 https://github.com/mmcc007 Count.ly：Flutter 应用内分析工具 Count.ly 是一个开源分析工具，专注于数据的安全性和隐私性。Count.ly 的免费版本允许你跟踪显示应用性能的基本指标和 KPI。但它们还提供付费版本，其中包含一组更广泛的指标以及其他许多功能。Count.ly 的付费版本可以在内部或云中托管，并提供额外的特性标志、A&#x2F;B 测试和推送通知功能。 项目地址 https://count.ly/ AppsFlyer：Flutter 归因工具 AppsFlyer 是一种移动归因工具，可帮助你了解用户的来源并了解应用安装量和特定营销活动之间的联系。它提供了一个仪表板，可以帮助你了解营销渠道和广告系列在各种设备和应用上的效果如何，并与 6000 多家媒体合作伙伴集成。 项目地址 https://www.appsflyer.com/ Instabug：Flutter 应用内错误报告、崩溃报告和调查工具 Instabug 是一个用于移动应用实时上下文洞察的平台，可用于应用内错误报告、崩溃报告、调查和功能请求。将 Instabug 的 Flutter SDK 集成到你的应用中后，你就可以允许用户在不离开应用的情况下报告他们遇到的错误。Instabug 可以捕获截图，支持用户注释和模糊，并能捕获全面的日志和设备详细信息，以帮助你更快地发现和解决问题。崩溃报告也会与你定位确切问题所需的所有日志和设备详细信息一起发送。你还可以向你的用户发送定向调查，以更好地了解用户操作背后的原因，并允许用户请求功能，对请求进行投票。 项目地址 https://instabug.com/?src=InstabugBlog&amp;mdm=internal&amp;term=flutter_tools Airship：Flutter 应用内消息工具 Airship 是一个客户参与平台，允许你向用户发送推送通知和应用内消息，以吸引他们并改善他们的转化率。它还允许你创建一个应用内消息中心，该中心创建一个应用内收件箱，你可以在其中向用户发送持久消息。 项目地址 https://www.airship.com/ WonderPush：Fluttet 推送通知工具 WonderPush 是另一个通知推送和应用内消息传递工具，你可以在 Flutter 应用中使用该工具来提高用户的参与度。它以低廉的价格提供了许多强大的功能，包括细分和定位、地理位置定位以及 A&#x2F;B 测试。 项目地址 https://www.wonderpush.com/ Revenue Cat：Flutter 应用内购买工具 RevenueCat 是一款应用内购买和订阅管理工具，支持 iOS、Android 和 Stripe。使用这一工具，你可以轻松创建和管理应用内购买和订阅模块，它可以完成所有繁重的工作并处理计费基础架构。它还支持开箱即用的 LTV、MRR、客户流失率等指标测量，来跟踪你的应用成绩。 项目地址 https://www.revenuecat.com/ Square：Flutter 应用内支付工具 Square 是一个应用内支付管理平台，可为你处理支付操作带来的所有复杂性。借助其 Flutter SDK，你可以通过易于定制的 UI 接收应用内付款，该 UI 支持数字钱包和存储卡以进行快速结帐。 项目地址 https://www.revenuecat.com/","categories":["Flutter","资源库"]},{"title":"iOS资源整理","path":"/2024/03/09/iOS资源整理/","content":"RunTimeRuntime 10种用法（没有比这更全的了 开源项目成为iOS顶尖高手，你必须来这里(这里有最好的开源项目和文章) MVVMTableView之MVVM与MVC之对比 使用MVVM减少控制器代码实战(减少56%) 面向协议的 MVVM 架构介绍 网络iOS 升级HTTPS通过ATS你所要知道的 iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求 iOS开发之AFNetworking 3.0.4使用 iOS开发 AFNetworking 3.0使用遇到的问题补充 正确使用AFNetworking的SSL保证网络安全 iOS开发中WiFi相关功能总结 iOS应用支持IPV6，就那点事儿 基于iOS 10、realm封装的下载器（支持存储读取、断点续传、后台下载、杀死APP重启后的断点续传等功能） 网络层的搭建需要解决哪些问题 YTKNetwork集成教程以及相关问题思考 关于iOS工程中网络请求管理的头脑风暴 计算机网络中的TCP&#x2F;UDP协议到底是怎么回事（一） 计算机网络中的TCP&#x2F;UDP协议到底是怎么回事（二）","categories":["iOS","资源库"]},{"title":"iOS开发兵器进阶","path":"/2024/03/08/iOS开发兵器进阶/","content":"开篇 悟空道：“我自生身之后，出家修行，得一个无生无灭之体。近因教演儿孙，守护山洞，奈何没件兵器。久闻贤邻享乐瑶宫贝阙，必有多余神器，特来告求一件。” – 《西游记》第三回 四海千山皆拱伏 九幽十类尽除名 常言道：“工欲善其事，必先利其器。”各位看官，今天咱们就介绍几件在 iOS 开发中几件趁手的兵器。 开发Reveal 教程：iOS开发中集成Reveal 破解版用于学习途径，请自行搜索。 Charles 教程：Charles 从入门到精通 下载：Charles 官网 破解版用于学习途径，请自行搜索。 SimPholdersSimPholders 是一款Mac上的iOS开发辅助工具，能够在菜单栏上快速的访问iPhone Simulator中的应用的文件夹，从而帮助我们进行应用开发。 下载：Simpholders PaintCode 教程：PaintCode 教程 (1) | PaintCode 教程 (2) 下载：PaintCode 官网 Conerstone 教程：用CornerStone配置SVN，HTTP及svn简单使用说明 破解版用于学习途径，请自行搜索。 iFunBoxiFunBox是一款小巧的iPhone文件管理软件，界面类似于windows资源管理器，以简练时尚的窗口方式浏览和管理iPhone、iPad、iPod touch上的文件和目录。既可以在手机与电脑之间同步传递数据，使你轻松上传电影、音乐、电子书、桌面、照片以及应用程序。 下载：iFunBox 官网 iTerm 你应该知道的 iTerm2 使用方法–MAC终端工具 iTerm2 - macOS Terminal Replacement 官网 zsh zsh 全程指南 zsh 官网 VisualDifferVisualDiffer比较文件夹和文件并排侧使用颜色直观地显示差异。 防火墙 Little Snitch主要用途，阻止 Mac 内具体哪个应用联网，实时查看电脑流量是否有异常。 介绍：你的隐私看门人：Mac 双向防火墙 Little Snitch flux长期看电脑屏幕，护眼软件。 flux 官网 效率有道词典不多说，阅读英文文档和翻译的辅助。全球 Mac Appstore 均有销售。 Dash全栈工程师开发文档大全。全球 Mac Appstore 均有销售。 MindNode Pro思维导图，帮助梳理逻辑。 StarUML画UML，类图的工具。StarUML 官网 OmniGraffle画UML，类图的工具，与StarUML比较看个人爱好了。 知识输入印象笔记印象笔记，有道笔记，为知笔记，笔记是一定要有的，那么多东西谁天天记在脑子了，关键的东西记笔记里，如果实在忘了，Google一下。 Reeder常看的blog记得订阅。 知识输出Markdown + Quiver + 坚果云 程序员专用笔记软件Quiver 坚果云怎么样？ - 网盘 - 知乎 U图床 + 七牛云 U 图床：MacAppStore 下载 U 图床：Github 开源 搭配 Markdown 书写，够了。 LicecapLicecap 是一款屏幕录制工具，支持导出 GIF 动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围。 官方主页 GitHub最好的开源项目集散地(没有“之一”)。同样是你的作品得到认可的地方。 Blog技术blog非常棒，好的技术或方案应该记录下并传播出去，坚持做下去。Hexo+gitpage 搭建个人技术博客 简书大牛都在简书上写博客，你不跟着节奏么？ 开发者头条技术自媒体发散渠道，同时也是好的知识输入渠道。 掘金技术自媒体发散渠道，同时也是好的知识输入渠道。 科学上网科学上网用于学习途径，关于 ShadowsockesX 的内容，来自 使用ShadowSocks科学上网及突破公司内网这篇文章。 ShadowsockesXShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由@clowwindy开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。 ShadowsocksX-NG:Github Proxifier该工具的作用就是接管运行中的所有应用发出的所有请求，然后通过代理进行转发，这样就可以让不支持代理的应用也可以走代理了。 Proxifier 官网 破解和使用教程看这篇：proxifier注册码以及配合shadowsocks上网 - 科学上网 其他姿势科学上网，有需要请私信我。Chrome 插件翻墙后，全球 Chrome 商店均有销售。 Proxy SwitchyOmegaChrome 浏览器 配合 Proxy SwitchyOmega 插件 + 代理服务器，轻松登陆Google。 FireShot截取整个网页的截屏工具 有道词典不多说，网页浏览英文随时翻译。 开发者头条第一时间掌握技术圈最新自媒体动态。 掘金第一时间掌握技术圈最新自媒体动态，和github每日更新仓库。 Copy as Markdown配合 Markdown 图片、链接跳转方便粘贴。 AdBlock去除广告，专注网页内容。 印象笔记·剪藏配合印象笔记，知识输入重要来源，点击一下，直接将网页正文存入印象笔记。 新浪微博图床免费开源的微博图床。 新浪微博图床：Github 结尾 悟空笑道：“古人云：‘愁海龙王没宝哩！’你再去寻寻看。若有可意的，一一奉价。” 这是小生工作中常用的几件工具介绍给大家，也欢迎有好的工具咱们奔走相告，提高工作效率的同时，也学习工具开发者的设计思想。","categories":["iOS","资源库"]},{"title":"几个超棒的iOS学习网站","path":"/2024/03/07/几个超棒的iOS学习网站/","content":"我相信，要想从一个“还不错”的人编程一个卓越的人，我们需要不停地向他人学习，同时还要尽早地适应最新的技术和工具。除了苹果官方文档网站之外，我列举了一些能获取有价值的文章和资源的网站，这些网站能够帮助我们更上一个台阶！ 让我们先看一些原创的内容博客： objc.io这个网站由世界级的iOS工程师每月进行更新。上面可以看到关于某些话题的高质量文章和深度讨论，同时他们还提供了基于订阅的杂志iPad应用。该网站由Chris Eidhof、Daniel Eggert和Florian Kugler发现并提供。 Subjective-C该网站以解析和重构创新模式和著名应用的UI而闻名。该网站为他们的实验提供程序性文章和代码库。由Sam Page主笔。有点遗憾的是，作者决定暂停更新网站，不过好在那些旧的教程仍然很值得一看。 NSHipster以类为基础进行逐步讲解并附有示例代码的网站。其文章探讨了编程风格，以及最前沿的类的使用和实现。由AFNetworking的作者Mattt Thompson创建，目前由Nate Cook进行管理。 Peter Steinberger本站为个人博客，其作者是著名的iOS商业PDF库的创始人，该产品曾被Dropbox和Evernote这样著名的应用使用过。网站内容包括一些令人惊叹的黑客资源和debug资源，以帮助开发者学习和实践。 Ole Begemann本博客重点分享个人经历,同时讨论代码样式和API设计,有时还会透露一些苹果所使用的私密而有趣的类。 Florian KuglerObjC.IO的合著者所写的个人博客。你可以在上面找到很多关于性能检测的文章和讨论，包括应用于多核心数据的UI绘制。 NSBlog用有趣的问答形式创作，包含了关于Objective-C和其他主题的深度问题。如果你对于重建像NSObject这样的基本类持有疑问，可以向Mike Ash提出。 Cocoa从iOS开发者的Tumblr上摘取的iOS开发源码和深度观察，有点随机但是还是很有用。 下面有一些博客，可以帮我们获取最新讯息。 iOS Dev Weekly自2011年起每周更新，订阅者已经超过20,000。它可以帮我们从网络上获取有用的iOS文章。还提供了Safari的推送通知功能。由Dave Verwer发现并提供。 iOS Developer Tips2008年以来最早的几个每天更新的iOS推送资源之一。包括很多领域的文章，例如开发小技巧、UX、流言、个人经历和故事等。由John Muchow策划。 iOS Goodies较新的iOS资讯站。内容包括论文、控件&#x2F;工具、商务、UI以及各种媒体类型等等。由Rui Peres和Tiago Almeida每周更新。 AppCoda由我在香港的一个开发者朋友创建，他最近辞掉了工作来专心维护这个网站。包括在线的文章和支付后可下载的文章，重点在用于执行的最新的API和结构上。由Simon Ng创建，值得一看。 两个有价值的原创内容博客。 Krzysztof Zab?ocki提供关于代码结构、工具和Xcode的技巧，当然，在我第一次发表这篇博客的时候我把它给遗漏了。我们从这些高阶的文章中学到了很多。 iOS Development tips相对较新的博客，有一些关于使用Xcode和API的细致的提示，即使你再匆忙也值得去看一眼。作者是Rounak Jain。 时间很宝贵，所以我们必须聪明地选择新闻来源。 读的越好,做的越好。 读的越多，做的越少。","categories":["iOS","资源库"]},{"title":"iOS面试题","path":"/2024/03/06/iOS面试题/","content":"1、一个NSObject对象占用多少内存？回答：系统分配了16个字节给NSObject对象（通过malloc_size函数获得）（因为内存对齐，必须是16的倍数）但NSObject对象内部只有一个isa指针，只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 2、对象的isa指针指向哪里？回答：instance对象的isa指针指向class对象class对象的isa指针指向meta-class对象meta-class对象的isa指针指向基类的meta-class对象 3、OC的类信息存放在哪里？回答：对象方法、属性、成员变量、协议信息，存放在class对象中类方法，存放在meta-class对象中成员变量的具体值，存放在instance对象中 4、iOS用什么方式实现对一个对象的KVO？（KVO的本质是什么？）回答：利用RuntimeAPI生成一个子类NSKVOXXXNotifying，并且让instance对象的isa指针指向这个全新的子类当修改instance对象的属性时，会调用Foundation框架中的_NSSetXXXValueAndNotify函数（重写了setter方法）：willChangeValueForKey:父类原来的setter方法didChangeValueForKey:内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context） 5、如何手动触发KVO？回答：手动去调用willChangeValueForKey:和didChangeValueForKey:的方法 6、直接修改成员变量会触发KVO吗？回答：不会，因为修改成员变量并不会调用setter方法 7、通过KVC修改属性会触发KVO吗？回答：会触发KVO，通过KVC修改相当于手动调用了willChangeValueForKey:和didChangeValueForKey: 8、KVC的赋值和取值的过程是怎样的？原理是什么？回答：赋值：取值： 9、Category的使用场合是什么？回答：类包含了很多个方法实现，而这些方法需要不同团队的成员来实现当你在使用基础类库中的类时，你不想继承这些类，而只是想添加一些方法的时候 10、Category的实现原理回答：Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中） 11、Category和Class Extension的区别是什么？回答：Class Extension是在程序编译的时候，它的数据就已经包含在类信息中了Category在底层是以结构体的形式存在，在程序运行的时候，才会将数据合并到类信息中 12、Category中有load方法吗？load方法是什么时候调用的？load方法能继承吗？回答：有load方法load方法在runtime加载类、分类的时候调用，而且只调用一次load方法可以继承，但是一般情况下不会主动去调用load方法，都是让系统自动调用 13、load、initialize方法的区别是什么？它们在category中的调用顺序？以及出现继承时它们之间的调用过程？回答：load方法load方法会在Runtime加载类、分类的时候调用每个类、分类的load，在程序运行的过程中只调用一次调用顺序：先调用类的load按照编译的先后顺序调用（先编译，先调用）调用子类的load之前会先调用父类的load再调用分类的load按照编译先后顺序调用（先编译，先调用）load方法系统调用和主动调用的区别系统调用load是直接找到类或分类中的方法的内存地址直接调用主动调用load是通过消息机制来发送消息的，会在对应的消息列表里按顺序遍历一层层查找，找到就调用initialize方法initialize方法会在类第一次接收到消息时调用调用顺序：先调用父类的initialize，再调用子类的initialize，每个类只会初始化1次（如果子类没有实现initialize方法，会调用父类的initialize方法，所以父类的initialize方法可能会调用多次）initialize的调用是通过消息机制来发送消息的 14、Category能否添加成员变量？如果可以，如何给Category添加成员变量？回答：不能直接给Category添加成员变量，但是可以简介实现Category有成员变量的效果——关联对象 15、Block的原理是怎样的？Block的本质是什么？回答：其本质就是封装了函数调用以及调用环境的OC对象 16、__block的作用是什么？有什么使用注意点？回答：可以将修饰的对象包装成一个对象，解决在block内部无法修改外部变量的问题。__block内部会进行内存管理，在MRC环境下不会对对象进行强引用。 17、看下面代码，分别输出的值是什么？1234567891011121314151617181920212223int a = 10;static int b = 10;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; auto int age = 10; static int height = 10; void (^block)(void) = ^&#123; NSLog(@&quot;age is %d, height is %d&quot;, age, height); NSLog(@&quot;a is %d, b is %d&quot;, a, b); &#125;; age = 20; height = 20; a = 20; b = 20; block();\t&#125; return 0;&#125; 回答：输出结果为：age&#x3D;10，height&#x3D;20，a&#x3D;20，b&#x3D;20 age是自动变量，是值传递height表示的是指针传递，block获取的是该变量的地址而a/b都是全局变量，block不会捕获，需要时直接拿取当前最新的值就可以了12345678910111213141516171819202122232425262728293031323334int a = 10;static int b = 10;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; int *height; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int *_height, int flags=0) : age(_age), height(_height) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; auto int age = 10; static int height = 10; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age, &amp;height)); age = 20; height = 20; a = 20; b = 20; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); &#125; return 0;&#125; 18、看下面代码，block内部会不会捕获self？123456789101112131415161718192021222324252627@interface Person : NSObject@property (copy, nonatomic) NSString *name;- (instancetype)initWithName:(NSString *)name;@end@implementation Person- (void)test&#123; void (^block)(void) = ^&#123; NSLog(@&quot;-------%d&quot;, [self name]); &#125;; block();&#125; - (instancetype)initWithName:(NSString *)name&#123; if (self = [super init]) &#123; self.name = name; &#125; return self;&#125;@end 回答：会捕获，因为self本质上也是一个局部变量，block内部会生成一个变量来保存Person对象的地址123456789101112131415161718struct __Person__test_block_impl_0 &#123; struct __block_impl impl; struct __Person__test_block_desc_0* Desc; Person *self; __Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *_self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// 函数都会生成隐式参数self和_cmdstatic void _I_Person_test(Person * self, SEL _cmd) &#123; void (*block)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);&#125; 19、Block的属性词为什么是Copy？使用Block有哪些注意事项？回答：block如果没有进行copy操作，就不会放在堆上。放到堆上的主要目的是方便我们来控制它的生命周期，可以更有效的进行内存管理。注意事项：注意不要产生循环引用"},{"title":"iOS易忘图","path":"/2024/03/05/易忘图/","content":"isa和superclass指针 KVCsetValue:forKey:的原理 KVCvalueForKey:的原理 关联对象的本质 @encode&#96;字符串编码 类的底层结构 常见的深浅拷贝 同步异步&#x2F;串行并发 动态方法解析 消息转发 排序算法时间复杂度","categories":["iOS"]},{"title":"Mac常用代码","path":"/2024/03/04/Mac常用代码/","content":"一、Git创建新分支1git checkout -b dev 相当于以下两条命令： 12git branch devgit checkout dev 提交的时候执行： 1git push --set-upstream origin dev 二、文件夹的显示和隐藏1、Mac显示隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean true;killall Finder 2、Mac隐藏文件夹1defaults write com.apple.finder AppleShowAllFiles -boolean false;killall Finder 三、给安卓手机安装软件1adb install -r（然后拖入apk文件） 四、OC代码转为C++代码1xcrun -sdk iphoneos clang arm64 -rewrite-objc main.m 如果代码里有weak的话使用以下代码： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m"},{"title":"Hello World","path":"/2024/03/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"探索Objective-C底层 - OC的本质","path":"/2022/01/01/探索Objective-C底层 - OC的本质/","content":"引言Objective-C（简称OC）作为iOS开发的核心语言，其底层实现机制一直是开发者进阶的必经之路。理解OC的本质不仅能帮助我们写出更高效的代码，还能深入掌握iOS运行时机制、内存管理等底层逻辑。本文将从以下几个维度展开分析： 一、OC的运行时机制（Objective-C Runtime）OC是一门动态语言，其核心特性依赖于objc库实现。运行时机制在程序运行时动态处理类、对象、方法调用等操作，主要包含以下核心组件： 1.1 objc库的核心结构123456789// objc.h中定义的核心结构体struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; // 其他字段...&#125;;struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 1.2 动态语言特性 动态类型（Dynamic Typing）：对象类型检查在运行时完成 动态绑定（Dynamic Binding）：方法调用与实现的绑定在运行时确定 动态加载（Dynamic Loading）：程序运行时可加载新代码 二、对象与类的底层结构2.1 对象的本质OC对象在底层由objc_object结构体表示： 123struct objc_object &#123; Class isa;&#125;; isa指针：指向对象的类（Class） 类对象：存储方法列表、属性列表等元数据 2.2 类的结构类对象由objc_class结构体构成： 123456struct objc_class : objc_object &#123; // Class ISA; 继承自objc_object Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 类数据&#125;; 2.3 元类（Meta Class） 每个类都有对应的元类 元类存储类方法（Class Method） 根元类（Root Meta Class）的isa指针指向自身 三、消息传递与转发机制3.1 消息传递（Message Passing）OC的方法调用本质是消息传递： 12345// OC代码[person run];// 底层实现objc_msgSend(person, @selector(run)); 3.2 SEL与IMP SEL（Selector）：方法选择器，唯一标识一个方法 IMP（Implementation）：方法的具体实现，指向函数指针 3.3 动态方法决议1234567+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(run)) &#123; class_addMethod(self, sel, (IMP)runFunction, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125; 3.4 消息转发 快速转发（Fast Forwarding） 标准转发（Standard Forwarding） 完整转发流程示例：1234567891011- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return otherObject;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; // 返回方法签名&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; // 处理未识别的消息&#125; 四、内存管理机制4.1 引用计数（Reference Counting） retainCount：对象当前的引用计数 retain&#x2F;release&#x2F;autorelease：手动管理内存 autoreleasepool：自动释放池实现原理 4.2 ARC的底层实现 LLVM编译器自动插入内存管理代码 __strong&#x2F;__weak&#x2F;__unsafe_unretained修饰符 弱引用表（Side Table）的实现机制 4.3 僵尸对象（Zombie Object） 调试工具：NSZombieEnabled 原理：对象释放后变为僵尸对象，防止野指针 五、OC与C++的关联5.1 OC的动态特性与C++的对比 特性 OC C++ 多态 动态绑定 静态绑定 内存管理 ARC&#x2F;MRC 手动管理 类型检查 运行时 编译时 5.2 OC类的C++实现通过clang -rewrite-objc命令可以将OC代码转换为C++： 12345678910// OC代码@interface Person : NSObject@property (nonatomic, copy) NSString *name;@end// 转换后的C++代码struct Person_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;; 六、总结OC的本质是基于C语言的动态语言扩展，其底层实现涉及： 对象与类的结构设计 消息传递与转发机制 内存管理策略 动态语言特性 掌握这些底层原理能帮助开发者： 写出更高效、健壮的代码 深入理解iOS框架设计思想 解决复杂的内存问题 实现高级特性（如AOP、热更新） 建议开发者通过以下方式深入学习： 阅读Apple官方文档《Objective-C Runtime Programming Guide》 分析objc源码（Apple开源代码） 使用class-dump分析二进制文件 通过LLDB调试运行时行为 附录：常用工具与命令 clang -rewrite-objc：将OC代码转换为C++ class-dump：解析二进制文件的类结构 malloc_history：追踪内存分配 NSZombieEnabled：调试僵尸对象 objc_msgsend：手动发送消息 通过深入理解OC的底层原理，我们能真正掌握iOS开发的核心逻辑，写出更优秀的应用程序。","categories":["iOS","Objective-C底层原理"]}]